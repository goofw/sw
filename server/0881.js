function(module, exports, __webpack_require__) {
    const querystring = __webpack_require__(28), sax = __webpack_require__(175), miniget = __webpack_require__(146), utils = __webpack_require__(95), {setTimeout: setTimeout} = __webpack_require__(117), formatUtils = __webpack_require__(435), urlUtils = __webpack_require__(436), extras = __webpack_require__(883), sig = __webpack_require__(438), Cache = __webpack_require__(439), BASE_URL = "https://www.youtube.com/watch?v=";
    exports.cache = new Cache, exports.cookieCache = new Cache(864e5), exports.watchPageCache = new Cache;
    let cver = "2.20210622.10.00";
    class UnrecoverableError extends Error {}
    const AGE_RESTRICTED_URLS = [ "support.google.com/youtube/?p=age_restrictions", "youtube.com/t/community_guidelines" ];
    exports.getBasicInfo = async (id, options) => {
        const retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);
        options.requestOptions = Object.assign({}, options.requestOptions, {}), options.requestOptions.headers = Object.assign({}, {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36"
        }, options.requestOptions.headers);
        let info = await pipeline([ id, options ], (info => {
            let playErr = utils.playError(info.player_response, [ "ERROR" ], UnrecoverableError), privateErr = privateVideoError(info.player_response);
            if (playErr || privateErr) throw playErr || privateErr;
            return info && info.player_response && (info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response));
        }), retryOptions, [ getWatchHTMLPage, getWatchJSONPage, getVideoInfoPage ]);
        Object.assign(info, {
            formats: parseFormats(info.player_response),
            related_videos: extras.getRelatedVideos(info)
        });
        const media = extras.getMedia(info), additional = {
            author: extras.getAuthor(info),
            media: media,
            likes: extras.getLikes(info),
            dislikes: extras.getDislikes(info),
            age_restricted: !!(media && media.notice_url && AGE_RESTRICTED_URLS.some((url => media.notice_url.includes(url)))),
            video_url: BASE_URL + id,
            storyboards: extras.getStoryboards(info),
            chapters: extras.getChapters(info)
        };
        return info.videoDetails = extras.cleanVideoDetails(Object.assign({}, info.player_response && info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer, info.player_response && info.player_response.videoDetails, additional), info), 
        info;
    };
    const privateVideoError = player_response => {
        let playability = player_response && player_response.playabilityStatus;
        return playability && "LOGIN_REQUIRED" === playability.status && playability.messages && playability.messages.filter((m => /This is a private video/.test(m))).length ? new UnrecoverableError(playability.reason || playability.messages && playability.messages[0]) : null;
    }, isRental = player_response => {
        let playability = player_response.playabilityStatus;
        return playability && "UNPLAYABLE" === playability.status && playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;
    }, isNotYetBroadcasted = player_response => {
        let playability = player_response.playabilityStatus;
        return playability && "LIVE_STREAM_OFFLINE" === playability.status;
    }, getWatchHTMLURL = (id, options) => `${BASE_URL + id}&hl=${options.lang || "en"}`, getWatchHTMLPageBody = (id, options) => {
        const url = getWatchHTMLURL(id, options);
        return exports.watchPageCache.getOrSet(url, (() => utils.exposedMiniget(url, options).text()));
    }, getHTML5player = body => {
        let html5playerRes = /<script\s+src="([^"]+)"(?:\s+type="text\/javascript")?\s+name="player_ias\/base"\s*>|"jsUrl":"([^"]+)"/.exec(body);
        return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;
    }, pipeline = async (args, validate, retryOptions, endpoints) => {
        let info;
        for (let func of endpoints) try {
            const newInfo = await retryFunc(func, args.concat([ info ]), retryOptions);
            if (newInfo.player_response && (newInfo.player_response.videoDetails = assign(info && info.player_response && info.player_response.videoDetails, newInfo.player_response.videoDetails), 
            newInfo.player_response = assign(info && info.player_response, newInfo.player_response)), 
            info = assign(info, newInfo), validate(info, !1)) break;
        } catch (err) {
            if (err instanceof UnrecoverableError || func === endpoints[endpoints.length - 1]) throw err;
        }
        return info;
    }, assign = (target, source) => {
        if (!target || !source) return target || source;
        for (let [key, value] of Object.entries(source)) null != value && (target[key] = value);
        return target;
    }, retryFunc = async (func, args, options) => {
        let result, currentTry = 0;
        for (;currentTry <= options.maxRetries; ) try {
            result = await func(...args);
            break;
        } catch (err) {
            if (err instanceof UnrecoverableError || err instanceof miniget.MinigetError && err.statusCode < 500 || currentTry >= options.maxRetries) throw err;
            let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);
            await new Promise((resolve => setTimeout(resolve, wait)));
        }
        return result;
    }, jsonClosingChars = /^[)\]}'\s]+/, parseJSON = (source, varName, json) => {
        if (!json || "object" == typeof json) return json;
        try {
            return json = json.replace(jsonClosingChars, ""), JSON.parse(json);
        } catch (err) {
            throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);
        }
    }, findJSON = (source, varName, body, left, right, prependJSON) => {
        let jsonStr = utils.between(body, left, right);
        if (!jsonStr) throw Error(`Could not find ${varName} in ${source}`);
        return parseJSON(source, varName, utils.cutAfterJSON(`${prependJSON}${jsonStr}`));
    }, findPlayerResponse = (source, info) => {
        const player_response = info && (info.args && info.args.player_response || info.player_response || info.playerResponse || info.embedded_player_response);
        return parseJSON(source, "player_response", player_response);
    }, getWatchJSONPage = async (id, options) => {
        const reqOptions = Object.assign({
            headers: {}
        }, options.requestOptions);
        let cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;
        reqOptions.headers = Object.assign({
            "x-youtube-client-name": "1",
            "x-youtube-client-version": cver,
            "x-youtube-identity-token": exports.cookieCache.get(cookie || "browser") || ""
        }, reqOptions.headers);
        const setIdentityToken = async (key, throwIfNotFound) => {
            reqOptions.headers["x-youtube-identity-token"] || (reqOptions.headers["x-youtube-identity-token"] = await ((id, options, key, throwIfNotFound) => exports.cookieCache.getOrSet(key, (async () => {
                let match = (await getWatchHTMLPageBody(id, options)).match(/(["'])ID_TOKEN\1[:,]\s?"([^"]+)"/);
                if (!match && throwIfNotFound) throw new UnrecoverableError("Cookie header used in request, but unable to find YouTube identity token");
                return match && match[2];
            })))(id, options, key, throwIfNotFound));
        };
        cookie && await setIdentityToken(cookie, !0);
        const jsonUrl = ((id, options) => `${getWatchHTMLURL(id, options)}&pbj=1`)(id, options), body = await utils.exposedMiniget(jsonUrl, options, reqOptions).text();
        let parsedBody = parseJSON("watch.json", "body", body);
        if ("now" === parsedBody.reload && await setIdentityToken("browser", !1), "now" === parsedBody.reload || !Array.isArray(parsedBody)) throw Error("Unable to retrieve video metadata in watch.json");
        let info = parsedBody.reduce(((part, curr) => Object.assign(curr, part)), {});
        return info.player_response = findPlayerResponse("watch.json", info), info.html5player = info.player && info.player.assets && info.player.assets.js, 
        info;
    }, getWatchHTMLPage = async (id, options) => {
        let body = await getWatchHTMLPageBody(id, options), info = {
            page: "watch"
        };
        try {
            cver = utils.between(body, '{"key":"cver","value":"', '"}'), info.player_response = findJSON("watch.html", "player_response", body, /\bytInitialPlayerResponse\s*=\s*\{/i, "<\/script>", "{");
        } catch (err) {
            let args = findJSON("watch.html", "player_response", body, /\bytplayer\.config\s*=\s*{/, "<\/script>", "{");
            info.player_response = findPlayerResponse("watch.html", args);
        }
        return info.response = findJSON("watch.html", "response", body, /\bytInitialData("\])?\s*=\s*\{/i, "<\/script>", "{"), 
        info.html5player = getHTML5player(body), info;
    }, getVideoInfoPage = async (id, options) => {
        const url = new URL("https://www.youtube.com/get_video_info");
        url.searchParams.set("video_id", id), url.searchParams.set("c", "TVHTML5"), url.searchParams.set("cver", `7${cver.substr(1)}`), 
        url.searchParams.set("eurl", "https://youtube.googleapis.com/v/" + id), url.searchParams.set("ps", "default"), 
        url.searchParams.set("gl", "US"), url.searchParams.set("hl", options.lang || "en"), 
        url.searchParams.set("html5", "1");
        const body = await utils.exposedMiniget(url.toString(), options).text();
        let info = querystring.parse(body);
        return info.player_response = findPlayerResponse("get_video_info", info), info;
    }, parseFormats = player_response => {
        let formats = [];
        return player_response && player_response.streamingData && (formats = formats.concat(player_response.streamingData.formats || []).concat(player_response.streamingData.adaptiveFormats || [])), 
        formats;
    };
    exports.getInfo = async (id, options) => {
        let info = await exports.getBasicInfo(id, options);
        const hasManifest = info.player_response && info.player_response.streamingData && (info.player_response.streamingData.dashManifestUrl || info.player_response.streamingData.hlsManifestUrl);
        let funcs = [];
        if (info.formats.length) {
            if (info.html5player = info.html5player || getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await ((id, options) => {
                const embedUrl = `${"https://www.youtube.com/embed/" + id}?hl=${options.lang || "en"}`;
                return utils.exposedMiniget(embedUrl, options).text();
            })(id, options)), !info.html5player) throw Error("Unable to find html5player file");
            const html5player = new URL(info.html5player, BASE_URL).toString();
            funcs.push(sig.decipherFormats(info.formats, html5player, options));
        }
        if (hasManifest && info.player_response.streamingData.dashManifestUrl) {
            let url = info.player_response.streamingData.dashManifestUrl;
            funcs.push(getDashManifest(url, options));
        }
        if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {
            let url = info.player_response.streamingData.hlsManifestUrl;
            funcs.push(getM3U8(url, options));
        }
        let results = await Promise.all(funcs);
        return info.formats = Object.values(Object.assign({}, ...results)), info.formats = info.formats.map(formatUtils.addFormatMeta), 
        info.formats.sort(formatUtils.sortFormats), info.full = !0, info;
    };
    const getDashManifest = (url, options) => new Promise(((resolve, reject) => {
        let formats = {};
        const parser = sax.parser(!1);
        let adaptationSet;
        parser.onerror = reject, parser.onopentag = node => {
            if ("ADAPTATIONSET" === node.name) adaptationSet = node.attributes; else if ("REPRESENTATION" === node.name) {
                const itag = parseInt(node.attributes.ID);
                isNaN(itag) || (formats[url] = Object.assign({
                    itag: itag,
                    url: url,
                    bitrate: parseInt(node.attributes.BANDWIDTH),
                    mimeType: `${adaptationSet.MIMETYPE}; codecs="${node.attributes.CODECS}"`
                }, node.attributes.HEIGHT ? {
                    width: parseInt(node.attributes.WIDTH),
                    height: parseInt(node.attributes.HEIGHT),
                    fps: parseInt(node.attributes.FRAMERATE)
                } : {
                    audioSampleRate: node.attributes.AUDIOSAMPLINGRATE
                }));
            }
        }, parser.onend = () => {
            resolve(formats);
        };
        const req = utils.exposedMiniget(new URL(url, BASE_URL).toString(), options);
        req.setEncoding("utf8"), req.on("error", reject), req.on("data", (chunk => {
            parser.write(chunk);
        })), req.on("end", parser.close.bind(parser));
    })), getM3U8 = async (url, options) => {
        url = new URL(url, BASE_URL);
        const body = await utils.exposedMiniget(url.toString(), options).text();
        let formats = {};
        return body.split("\n").filter((line => /^https?:\/\//.test(line))).forEach((line => {
            const itag = parseInt(line.match(/\/itag\/(\d+)\//)[1]);
            formats[line] = {
                itag: itag,
                url: line
            };
        })), formats;
    };
    for (let funcName of [ "getBasicInfo", "getInfo" ]) {
        const func = exports[funcName];
        exports[funcName] = async (link, options = {}) => {
            utils.checkForUpdates();
            let id = await urlUtils.getVideoID(link);
            const key = [ funcName, id, options.lang ].join("-");
            return exports.cache.getOrSet(key, (() => func(id, options)));
        };
    }
    exports.validateID = urlUtils.validateID, exports.validateURL = urlUtils.validateURL, 
    exports.getURLVideoID = urlUtils.getURLVideoID, exports.getVideoID = urlUtils.getVideoID;
}, function(module, exports) {
    module.exports = {
        5: {
            mimeType: 'video/flv; codecs="Sorenson H.283, mp3"',
            qualityLabel: "240p",
            bitrate: 25e4,
            audioBitrate: 64
        },
        6: {
            mimeType: 'video/flv; codecs="Sorenson H.263, mp3"',
            qualityLabel: "270p",
            bitrate: 8e5,
            audioBitrate: 64
        },
        13: {
            mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
            qualityLabel: null,
            bitrate: 5e5,
            audioBitrate: null
        },
        17: {
            mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
            qualityLabel: "144p",
            bitrate: 5e4,
            audioBitrate: 24
        },
        18: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 5e5,
            audioBitrate: 96
        },
        22: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 2e6,
            audioBitrate: 192
        },
        34: {
            mimeType: 'video/flv; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 5e5,
            audioBitrate: 128
        },
        35: {
            mimeType: 'video/flv; codecs="H.264, aac"',
            qualityLabel: "480p",
            bitrate: 8e5,
            audioBitrate: 128
        },
        36: {
            mimeType: 'video/3gp; codecs="MPEG-4 Visual, aac"',
            qualityLabel: "240p",
            bitrate: 175e3,
            audioBitrate: 32
        },
        37: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "1080p",
            bitrate: 3e6,
            audioBitrate: 192
        },
        38: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "3072p",
            bitrate: 35e5,
            audioBitrate: 192
        },
        43: {
            mimeType: 'video/webm; codecs="VP8, vorbis"',
            qualityLabel: "360p",
            bitrate: 5e5,
            audioBitrate: 128
        },
        44: {
            mimeType: 'video/webm; codecs="VP8, vorbis"',
            qualityLabel: "480p",
            bitrate: 1e6,
            audioBitrate: 128
        },
        45: {
            mimeType: 'video/webm; codecs="VP8, vorbis"',
            qualityLabel: "720p",
            bitrate: 2e6,
            audioBitrate: 192
        },
        46: {
            mimeType: 'audio/webm; codecs="vp8, vorbis"',
            qualityLabel: "1080p",
            bitrate: null,
            audioBitrate: 192
        },
        82: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 5e5,
            audioBitrate: 96
        },
        83: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "240p",
            bitrate: 5e5,
            audioBitrate: 96
        },
        84: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 2e6,
            audioBitrate: 192
        },
        85: {
            mimeType: 'video/mp4; codecs="H.264, aac"',
            qualityLabel: "1080p",
            bitrate: 3e6,
            audioBitrate: 192
        },
        91: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "144p",
            bitrate: 1e5,
            audioBitrate: 48
        },
        92: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "240p",
            bitrate: 15e4,
            audioBitrate: 48
        },
        93: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "360p",
            bitrate: 5e5,
            audioBitrate: 128
        },
        94: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "480p",
            bitrate: 8e5,
            audioBitrate: 128
        },
        95: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 15e5,
            audioBitrate: 256
        },
        96: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "1080p",
            bitrate: 25e5,
            audioBitrate: 256
        },
        100: {
            mimeType: 'audio/webm; codecs="VP8, vorbis"',
            qualityLabel: "360p",
            bitrate: null,
            audioBitrate: 128
        },
        101: {
            mimeType: 'audio/webm; codecs="VP8, vorbis"',
            qualityLabel: "360p",
            bitrate: null,
            audioBitrate: 192
        },
        102: {
            mimeType: 'audio/webm; codecs="VP8, vorbis"',
            qualityLabel: "720p",
            bitrate: null,
            audioBitrate: 192
        },
        120: {
            mimeType: 'video/flv; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 2e6,
            audioBitrate: 128
        },
        127: {
            mimeType: 'audio/ts; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 96
        },
        128: {
            mimeType: 'audio/ts; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 96
        },
        132: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "240p",
            bitrate: 15e4,
            audioBitrate: 48
        },
        133: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "240p",
            bitrate: 2e5,
            audioBitrate: null
        },
        134: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "360p",
            bitrate: 3e5,
            audioBitrate: null
        },
        135: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "480p",
            bitrate: 5e5,
            audioBitrate: null
        },
        136: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "720p",
            bitrate: 1e6,
            audioBitrate: null
        },
        137: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "1080p",
            bitrate: 25e5,
            audioBitrate: null
        },
        138: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "4320p",
            bitrate: 135e5,
            audioBitrate: null
        },
        139: {
            mimeType: 'audio/mp4; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 48
        },
        140: {
            mimeType: 'audio/m4a; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 128
        },
        141: {
            mimeType: 'audio/mp4; codecs="aac"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 256
        },
        151: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 5e4,
            audioBitrate: 24
        },
        160: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "144p",
            bitrate: 1e5,
            audioBitrate: null
        },
        171: {
            mimeType: 'audio/webm; codecs="vorbis"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 128
        },
        172: {
            mimeType: 'audio/webm; codecs="vorbis"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 192
        },
        242: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "240p",
            bitrate: 1e5,
            audioBitrate: null
        },
        243: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "360p",
            bitrate: 25e4,
            audioBitrate: null
        },
        244: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "480p",
            bitrate: 5e5,
            audioBitrate: null
        },
        247: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "720p",
            bitrate: 7e5,
            audioBitrate: null
        },
        248: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1080p",
            bitrate: 15e5,
            audioBitrate: null
        },
        249: {
            mimeType: 'audio/webm; codecs="opus"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 48
        },
        250: {
            mimeType: 'audio/webm; codecs="opus"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 64
        },
        251: {
            mimeType: 'audio/webm; codecs="opus"',
            qualityLabel: null,
            bitrate: null,
            audioBitrate: 160
        },
        264: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "1440p",
            bitrate: 4e6,
            audioBitrate: null
        },
        266: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "2160p",
            bitrate: 125e5,
            audioBitrate: null
        },
        271: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1440p",
            bitrate: 9e6,
            audioBitrate: null
        },
        272: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "4320p",
            bitrate: 2e7,
            audioBitrate: null
        },
        278: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "144p 30fps",
            bitrate: 8e4,
            audioBitrate: null
        },
        298: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "720p",
            bitrate: 3e6,
            audioBitrate: null
        },
        299: {
            mimeType: 'video/mp4; codecs="H.264"',
            qualityLabel: "1080p",
            bitrate: 55e5,
            audioBitrate: null
        },
        300: {
            mimeType: 'video/ts; codecs="H.264, aac"',
            qualityLabel: "720p",
            bitrate: 1318e3,
            audioBitrate: 48
        },
        302: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "720p HFR",
            bitrate: 25e5,
            audioBitrate: null
        },
        303: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1080p HFR",
            bitrate: 5e6,
            audioBitrate: null
        },
        308: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1440p HFR",
            bitrate: 1e7,
            audioBitrate: null
        },
        313: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "2160p",
            bitrate: 13e6,
            audioBitrate: null
        },
        315: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "2160p HFR",
            bitrate: 2e7,
            audioBitrate: null
        },
        330: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "144p HDR, HFR",
            bitrate: 8e4,
            audioBitrate: null
        },
        331: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "240p HDR, HFR",
            bitrate: 1e5,
            audioBitrate: null
        },
        332: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "360p HDR, HFR",
            bitrate: 25e4,
            audioBitrate: null
        },
        333: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "240p HDR, HFR",
            bitrate: 5e5,
            audioBitrate: null
        },
        334: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "720p HDR, HFR",
            bitrate: 1e6,
            audioBitrate: null
        },
        335: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1080p HDR, HFR",
            bitrate: 15e5,
            audioBitrate: null
        },
        336: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "1440p HDR, HFR",
            bitrate: 5e6,
            audioBitrate: null
        },
        337: {
            mimeType: 'video/webm; codecs="VP9"',
            qualityLabel: "2160p HDR, HFR",
            bitrate: 12e6,
            audioBitrate: null
        }
    };
}, function(module, exports, __webpack_require__) {
    const utils = __webpack_require__(95), qs = __webpack_require__(28), {parseTimestamp: parseTimestamp} = __webpack_require__(217), BASE_URL = "https://www.youtube.com/watch?v=", TITLE_TO_CATEGORY = {
        song: {
            name: "Music",
            url: "https://music.youtube.com/"
        }
    }, getText = obj => obj ? obj.runs ? obj.runs[0].text : obj.simpleText : null;
    exports.getMedia = info => {
        let media = {}, results = [];
        try {
            results = info.response.contents.twoColumnWatchNextResults.results.results.contents;
        } catch (err) {}
        let result = results.find((v => v.videoSecondaryInfoRenderer));
        if (!result) return {};
        try {
            let metadataRows = (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer).metadataRowContainerRenderer.rows;
            for (let row of metadataRows) if (row.metadataRowRenderer) {
                let title = getText(row.metadataRowRenderer.title).toLowerCase(), contents = row.metadataRowRenderer.contents[0];
                media[title] = getText(contents);
                let runs = contents.runs;
                runs && runs[0].navigationEndpoint && (media[`${title}_url`] = new URL(runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString()), 
                title in TITLE_TO_CATEGORY && (media.category = TITLE_TO_CATEGORY[title].name, media.category_url = TITLE_TO_CATEGORY[title].url);
            } else if (row.richMetadataRowRenderer) {
                let contents = row.richMetadataRowRenderer.contents, boxArt = contents.filter((meta => "RICH_METADATA_RENDERER_STYLE_BOX_ART" === meta.richMetadataRenderer.style));
                for (let {richMetadataRenderer: richMetadataRenderer} of boxArt) {
                    let meta = richMetadataRenderer;
                    media.year = getText(meta.subtitle);
                    let type = getText(meta.callToAction).split(" ")[1];
                    media[type] = getText(meta.title), media[`${type}_url`] = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString(), 
                    media.thumbnails = meta.thumbnail.thumbnails;
                }
                let topic = contents.filter((meta => "RICH_METADATA_RENDERER_STYLE_TOPIC" === meta.richMetadataRenderer.style));
                for (let {richMetadataRenderer: richMetadataRenderer} of topic) {
                    let meta = richMetadataRenderer;
                    media.category = getText(meta.title), media.category_url = new URL(meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();
                }
            }
        } catch (err) {}
        return media;
    };
    const isVerified = badges => !(!badges || !badges.find((b => "Verified" === b.metadataBadgeRenderer.tooltip)));
    exports.getAuthor = info => {
        let channelId, subscriberCount, thumbnails = [], verified = !1;
        try {
            let videoOwnerRenderer = info.response.contents.twoColumnWatchNextResults.results.results.contents.find((v2 => v2.videoSecondaryInfoRenderer && v2.videoSecondaryInfoRenderer.owner && v2.videoSecondaryInfoRenderer.owner.videoOwnerRenderer)).videoSecondaryInfoRenderer.owner.videoOwnerRenderer;
            channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId, thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map((thumbnail => (thumbnail.url = new URL(thumbnail.url, BASE_URL).toString(), 
            thumbnail))), subscriberCount = utils.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText)), 
            verified = isVerified(videoOwnerRenderer.badges);
        } catch (err) {}
        try {
            let videoDetails = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer, id = videoDetails && videoDetails.channelId || channelId || info.player_response.videoDetails.channelId, author = {
                id: id,
                name: videoDetails ? videoDetails.ownerChannelName : info.player_response.videoDetails.author,
                user: videoDetails ? videoDetails.ownerProfileUrl.split("/").slice(-1)[0] : null,
                channel_url: `https://www.youtube.com/channel/${id}`,
                external_channel_url: videoDetails ? `https://www.youtube.com/channel/${videoDetails.externalChannelId}` : "",
                user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : "",
                thumbnails: thumbnails,
                verified: verified,
                subscriber_count: subscriberCount
            };
            return thumbnails.length && utils.deprecate(author, "avatar", author.thumbnails[0].url, "author.avatar", "author.thumbnails[0].url"), 
            author;
        } catch (err) {
            return {};
        }
    };
    const parseRelatedVideo = (details, rvsParams) => {
        if (details) try {
            let viewCount = getText(details.viewCountText), shortViewCount = getText(details.shortViewCountText), rvsDetails = rvsParams.find((elem => elem.id === details.videoId));
            /^\d/.test(shortViewCount) || (shortViewCount = rvsDetails && rvsDetails.short_view_count_text || ""), 
            viewCount = (/^\d/.test(viewCount) ? viewCount : shortViewCount).split(" ")[0];
            let browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint, channelId = browseEndpoint.browseId, name = getText(details.shortBylineText), user = (browseEndpoint.canonicalBaseUrl || "").split("/").slice(-1)[0], video = {
                id: details.videoId,
                title: getText(details.title),
                published: getText(details.publishedTimeText),
                author: {
                    id: channelId,
                    name: name,
                    user: user,
                    channel_url: `https://www.youtube.com/channel/${channelId}`,
                    user_url: `https://www.youtube.com/user/${user}`,
                    thumbnails: details.channelThumbnail.thumbnails.map((thumbnail => (thumbnail.url = new URL(thumbnail.url, BASE_URL).toString(), 
                    thumbnail))),
                    verified: isVerified(details.ownerBadges),
                    [Symbol.toPrimitive]: () => (console.warn("`relatedVideo.author` will be removed in a near future release, use `relatedVideo.author.name` instead."), 
                    video.author.name)
                },
                short_view_count_text: shortViewCount.split(" ")[0],
                view_count: viewCount.replace(/,/g, ""),
                length_seconds: details.lengthText ? Math.floor(parseTimestamp(getText(details.lengthText)) / 1e3) : rvsParams && `${rvsParams.length_seconds}`,
                thumbnails: details.thumbnail.thumbnails,
                richThumbnails: details.richThumbnail ? details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails : [],
                isLive: !(!details.badges || !details.badges.find((b => "LIVE NOW" === b.metadataBadgeRenderer.label)))
            };
            return utils.deprecate(video, "author_thumbnail", video.author.thumbnails[0].url, "relatedVideo.author_thumbnail", "relatedVideo.author.thumbnails[0].url"), 
            utils.deprecate(video, "ucid", video.author.id, "relatedVideo.ucid", "relatedVideo.author.id"), 
            utils.deprecate(video, "video_thumbnail", video.thumbnails[0].url, "relatedVideo.video_thumbnail", "relatedVideo.thumbnails[0].url"), 
            video;
        } catch (err) {}
    };
    exports.getRelatedVideos = info => {
        let rvsParams = [], secondaryResults = [];
        try {
            rvsParams = info.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(",").map((e => qs.parse(e)));
        } catch (err) {}
        try {
            secondaryResults = info.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;
        } catch (err) {
            return [];
        }
        let videos = [];
        for (let result of secondaryResults || []) {
            let details = result.compactVideoRenderer;
            if (details) {
                let video = parseRelatedVideo(details, rvsParams);
                video && videos.push(video);
            } else {
                let autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;
                if (!autoplay || !Array.isArray(autoplay.contents)) continue;
                for (let content of autoplay.contents) {
                    let video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);
                    video && videos.push(video);
                }
            }
        }
        return videos;
    }, exports.getLikes = info => {
        try {
            let like = info.response.contents.twoColumnWatchNextResults.results.results.contents.find((r => r.videoPrimaryInfoRenderer)).videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons.find((b => b.toggleButtonRenderer && "LIKE" === b.toggleButtonRenderer.defaultIcon.iconType));
            return parseInt(like.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\D+/g, ""));
        } catch (err) {
            return null;
        }
    }, exports.getDislikes = info => {
        try {
            let dislike = info.response.contents.twoColumnWatchNextResults.results.results.contents.find((r => r.videoPrimaryInfoRenderer)).videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons.find((b => b.toggleButtonRenderer && "DISLIKE" === b.toggleButtonRenderer.defaultIcon.iconType));
            return parseInt(dislike.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\D+/g, ""));
        } catch (err) {
            return null;
        }
    }, exports.cleanVideoDetails = (videoDetails, info) => (videoDetails.thumbnails = videoDetails.thumbnail.thumbnails, 
    delete videoDetails.thumbnail, utils.deprecate(videoDetails, "thumbnail", {
        thumbnails: videoDetails.thumbnails
    }, "videoDetails.thumbnail.thumbnails", "videoDetails.thumbnails"), videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description), 
    delete videoDetails.shortDescription, utils.deprecate(videoDetails, "shortDescription", videoDetails.description, "videoDetails.shortDescription", "videoDetails.description"), 
    videoDetails.lengthSeconds = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer.lengthSeconds || info.player_response.videoDetails.lengthSeconds, 
    videoDetails), exports.getStoryboards = info => {
        const parts = info.player_response.storyboards && info.player_response.storyboards.playerStoryboardSpecRenderer && info.player_response.storyboards.playerStoryboardSpecRenderer.spec && info.player_response.storyboards.playerStoryboardSpecRenderer.spec.split("|");
        if (!parts) return [];
        const url = new URL(parts.shift());
        return parts.map(((part, i) => {
            let [thumbnailWidth, thumbnailHeight, thumbnailCount, columns, rows, interval, nameReplacement, sigh] = part.split("#");
            url.searchParams.set("sigh", sigh), thumbnailCount = parseInt(thumbnailCount, 10), 
            columns = parseInt(columns, 10), rows = parseInt(rows, 10);
            const storyboardCount = Math.ceil(thumbnailCount / (columns * rows));
            return {
                templateUrl: url.toString().replace("$L", i).replace("$N", nameReplacement),
                thumbnailWidth: parseInt(thumbnailWidth, 10),
                thumbnailHeight: parseInt(thumbnailHeight, 10),
                thumbnailCount: thumbnailCount,
                interval: parseInt(interval, 10),
                columns: columns,
                rows: rows,
                storyboardCount: storyboardCount
            };
        }));
    }, exports.getChapters = info => {
        const playerOverlayRenderer = info.response && info.response.playerOverlays && info.response.playerOverlays.playerOverlayRenderer, playerBar = playerOverlayRenderer && playerOverlayRenderer.decoratedPlayerBarRenderer && playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer && playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer.playerBar, markersMap = playerBar && playerBar.multiMarkersPlayerBarRenderer && playerBar.multiMarkersPlayerBarRenderer.markersMap, marker = Array.isArray(markersMap) && markersMap.find((m => m.value && Array.isArray(m.value.chapters)));
        return marker ? marker.value.chapters.map((chapter => ({
            title: getText(chapter.chapterRenderer.title),
            start_time: chapter.chapterRenderer.timeRangeStartMillis / 1e3
        }))) : [];
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const stream_1 = __webpack_require__(3);
    class m3u8Parser extends stream_1.Writable {
        constructor() {
            super(), this._lastLine = "", this._seq = 0, this._nextItemDuration = null, this._nextItemRange = null, 
            this._lastItemRangeEnd = 0, this.on("finish", (() => {
                this._parseLine(this._lastLine), this.emit("end");
            }));
        }
        _parseAttrList(value) {
            let match, attrs = {}, regex = /([A-Z0-9-]+)=(?:"([^"]*?)"|([^,]*?))/g;
            for (;null != (match = regex.exec(value)); ) attrs[match[1]] = match[2] || match[3];
            return attrs;
        }
        _parseRange(value) {
            if (!value) return null;
            let svalue = value.split("@"), start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1, range = {
                start: start,
                end: start + parseInt(svalue[0]) - 1
            };
            return this._lastItemRangeEnd = range.end, range;
        }
        _parseLine(line) {
            let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);
            if (match) {
                const tag = match[1], value = match[2] || "";
                switch (tag) {
                  case "EXT-X-PROGRAM-DATE-TIME":
                    this.emit("starttime", new Date(value).getTime());
                    break;

                  case "EXT-X-MEDIA-SEQUENCE":
                    this._seq = parseInt(value);
                    break;

                  case "EXT-X-MAP":
                    {
                        let attrs = this._parseAttrList(value);
                        if (!attrs.URI) return void this.destroy(new Error("`EXT-X-MAP` found without required attribute `URI`"));
                        this.emit("item", {
                            url: attrs.URI,
                            seq: this._seq,
                            init: !0,
                            duration: 0,
                            range: this._parseRange(attrs.BYTERANGE)
                        });
                        break;
                    }

                  case "EXT-X-BYTERANGE":
                    this._nextItemRange = this._parseRange(value);
                    break;

                  case "EXTINF":
                    this._nextItemDuration = Math.round(1e3 * parseFloat(value.split(",")[0]));
                    break;

                  case "EXT-X-ENDLIST":
                    this.emit("endlist");
                }
            } else !/^#/.test(line) && line.trim() && (this.emit("item", {
                url: line.trim(),
                seq: this._seq++,
                duration: this._nextItemDuration,
                range: this._nextItemRange
            }), this._nextItemRange = null);
        }
        _write(chunk, encoding, callback) {
            let lines = chunk.toString("utf8").split("\n");
            this._lastLine && (lines[0] = this._lastLine + lines[0]), lines.forEach(((line, i) => {
                this.destroyed || (i < lines.length - 1 ? this._parseLine(line) : this._lastLine = line);
            })), callback();
        }
    }
    exports.default = m3u8Parser;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __importDefault = this && this.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : {
            default: mod
        };
    };
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const stream_1 = __webpack_require__(3), sax_1 = __importDefault(__webpack_require__(175)), parse_time_1 = __webpack_require__(437);
    class DashMPDParser extends stream_1.Writable {
        constructor(targetID) {
            let lastTag;
            super(), this._parser = sax_1.default.createStream(!1, {
                lowercase: !0
            }), this._parser.on("error", this.destroy.bind(this));
            let segmentTemplate, timescale, offset, duration, baseURL, isStatic, treeLevel, periodStart, currtime = 0, seq = 0, timeline = [], getSegments = !1, gotSegments = !1;
            const tmpl = str => {
                const context = {
                    RepresentationID: targetID,
                    Number: seq,
                    Time: currtime
                };
                return str.replace(/\$(\w+)\$/g, ((m, p1) => context[p1] + ""));
            };
            this._parser.on("opentag", (node => {
                switch (node.name) {
                  case "mpd":
                    currtime = node.attributes.availabilitystarttime ? new Date(node.attributes.availabilitystarttime).getTime() : 0, 
                    isStatic = "dynamic" !== node.attributes.type;
                    break;

                  case "period":
                    seq = 0, timescale = 1e3, duration = 0, offset = 0, baseURL = [], treeLevel = 0, 
                    periodStart = parse_time_1.durationStr(node.attributes.start) || 0;
                    break;

                  case "segmentlist":
                    seq = parseInt(node.attributes.startnumber) || seq, timescale = parseInt(node.attributes.timescale) || timescale, 
                    duration = parseInt(node.attributes.duration) || duration, offset = parseInt(node.attributes.presentationtimeoffset) || offset;
                    break;

                  case "segmenttemplate":
                    segmentTemplate = node.attributes, seq = parseInt(node.attributes.startnumber) || seq, 
                    timescale = parseInt(node.attributes.timescale) || timescale;
                    break;

                  case "segmenttimeline":
                  case "baseurl":
                    lastTag = node.name;
                    break;

                  case "s":
                    timeline.push({
                        duration: parseInt(node.attributes.d),
                        repeat: parseInt(node.attributes.r),
                        time: parseInt(node.attributes.t)
                    });
                    break;

                  case "adaptationset":
                  case "representation":
                    treeLevel++, null == targetID && (targetID = node.attributes.id), getSegments = node.attributes.id === targetID + "", 
                    getSegments && (periodStart && (currtime += periodStart), offset && (currtime -= offset / timescale * 1e3), 
                    this.emit("starttime", currtime));
                    break;

                  case "initialization":
                    getSegments && this.emit("item", {
                        url: baseURL.filter((s => !!s)).join("") + node.attributes.sourceurl,
                        seq: seq,
                        init: !0,
                        duration: 0
                    });
                    break;

                  case "segmenturl":
                    if (getSegments) {
                        gotSegments = !0;
                        let tl = timeline.shift(), segmentDuration = (tl && tl.duration || duration) / timescale * 1e3;
                        this.emit("item", {
                            url: baseURL.filter((s => !!s)).join("") + node.attributes.media,
                            seq: seq++,
                            duration: segmentDuration
                        }), currtime += segmentDuration;
                    }
                }
            }));
            const onEnd = () => {
                isStatic && this.emit("endlist"), getSegments ? this.emit("end") : this.destroy(Error(`Representation '${targetID}' not found`));
            };
            this._parser.on("closetag", (tagName => {
                switch (tagName) {
                  case "adaptationset":
                  case "representation":
                    if (treeLevel--, segmentTemplate && timeline.length) {
                        gotSegments = !0, segmentTemplate.initialization && this.emit("item", {
                            url: baseURL.filter((s => !!s)).join("") + tmpl(segmentTemplate.initialization),
                            seq: seq,
                            init: !0,
                            duration: 0
                        });
                        for (let {duration: duration, repeat: repeat, time: time} of timeline) {
                            duration = duration / timescale * 1e3, repeat = repeat || 1, currtime = time || currtime;
                            for (let i = 0; i < repeat; i++) this.emit("item", {
                                url: baseURL.filter((s => !!s)).join("") + tmpl(segmentTemplate.media),
                                seq: seq++,
                                duration: duration
                            }), currtime += duration;
                        }
                    }
                    gotSegments && (this.emit("endearly"), onEnd(), this._parser.removeAllListeners(), 
                    this.removeAllListeners("finish"));
                }
            })), this._parser.on("text", (text => {
                "baseurl" === lastTag && (baseURL[treeLevel] = text, lastTag = null);
            })), this.on("finish", onEnd);
        }
        _write(chunk, encoding, callback) {
            this._parser.write(chunk, encoding), callback();
        }
    }
    exports.default = DashMPDParser;
}, function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.default = class {
        constructor(worker, options = {}) {
            this._worker = worker, this._concurrency = options.concurrency || 1, this.tasks = [], 
            this.total = 0, this.active = 0;
        }
        push(item, callback) {
            this.tasks.push({
                item: item,
                callback: callback
            }), this.total++, this._next();
        }
        _next() {
            if (this.active >= this._concurrency || !this.tasks.length) return;
            const {item: item, callback: callback} = this.tasks.shift();
            let callbackCalled = !1;
            this.active++, this._worker(item, ((err, result) => {
                callbackCalled || (this.active--, callbackCalled = !0, callback && callback(err, result), 
                this._next());
            }));
        }
        die() {
            this.tasks = [];
        }
    };
}, function(module, exports, __webpack_require__) {
    var fs = __webpack_require__(2), path = __webpack_require__(4), tmp = __webpack_require__(440), child = __webpack_require__(31), fetch = __webpack_require__(33), pump = __webpack_require__(162), URL = (__webpack_require__(889), 
    __webpack_require__(7).URL), castingUtils = __webpack_require__(218), Discovery = __webpack_require__(890), ExternalDiscovery = __webpack_require__(891), MDNSDiscovery = __webpack_require__(896), SSDPDiscovery = __webpack_require__(905), ChromecastClient = __webpack_require__(941), DLNAClient = __webpack_require__(951), Router = __webpack_require__(111), discovery = new Discovery([ SSDPDiscovery, MDNSDiscovery, ExternalDiscovery ]), noop = Function.prototype;
    function Casting(executables) {
        var self = this;
        this.ffmpegErrors = "ignore", this.players = {}, this.executables = executables, 
        this.middleware = Router(), this.middleware.param("devID", (function(req, res, next, devID) {
            if (!discovery.devices[devID]) return console.log(" ^ Device not found!"), res.statusCode = 404, 
            res.setHeader("Content-Type", "text/plain; charset=utf8"), res.end("Device not found");
            var player = self.players[devID];
            switch (discovery.devices[devID].type) {
              case "chromecast":
                player = player || new ChromecastClient(discovery.devices[devID], self.executables);
                break;

              case "tv":
                player = player || new DLNAClient(discovery.devices[devID], self.executables);
                break;

              case "external":
                (player = discovery.devices[devID]).time = 0;
            }
            if (self.players[devID] = player, !player) return next(new Error("Unsupported device " + discovery.devices[devID].type));
            req.player = player, next();
        })), this.middleware.get("/", (function(req, res) {
            res.setHeader("Content-Type", "application/json; charset=utf8"), res.end(JSON.stringify(Object.keys(discovery.devices).map((function(key) {
                return discovery.devices[key];
            }))));
        })), this.middleware.get("/transcode:ext?", this.transcode.bind(this)), this.middleware.get("/convert:ext?", this.transcode.bind(this)), 
        this.middleware.get("/:devID", (function(req, res, next) {
            res.setHeader("Content-Type", "application/json; charset=utf8"), res.end(JSON.stringify(discovery.devices[req.params.devID]));
        })), this.middleware.all("/:devID/player", (function(req, res, next) {
            return req.player.middleware.bind(req.player)(req, res, next);
        }));
    }
    Casting.prototype.makeSubs = function(subsUrl, offset) {
        if (!subsUrl) return Promise.resolve();
        var self = this;
        return fetch("http://127.0.0.1:11470/subtitles.srt?from=" + encodeURIComponent(subsUrl)).then((function(res) {
            return res.text();
        })).then((function(text) {
            return new Promise((function(resolve, reject) {
                tmp.file({
                    prefix: "subs-",
                    postfix: ".srt"
                }, (function(err, path, fd) {
                    if (err) return reject(err);
                    var written = fs.close.bind(fs, fd, resolve.bind(null, path)), subs = Buffer.from(text.replace(/\r/g, ""), "utf8");
                    fs.write(fd, subs, 0, subs.length, 0, written);
                }));
            }));
        })).then((function(sourceSubsFn) {
            return offset ? new Promise((function(resolve, reject) {
                tmp.file({
                    prefix: "subs-",
                    postfix: ".srt",
                    discardDescriptor: !0
                }, (function(err, path) {
                    if (err) return reject(err);
                    var args = [ "-ss", offset, "-i", sourceSubsFn, "-y", path ], procOpts = {
                        detached: !0,
                        stdio: [ "ignore", "ignore", self.ffmpegErrors ]
                    };
                    child.spawn(self.executables.ffmpeg, args, procOpts).once("close", (function(code) {
                        return code ? reject("ffmpeg error " + code + " while subtitles alignment") : (fs.unlink(sourceSubsFn, noop), 
                        resolve(path));
                    }));
                }));
            })) : sourceSubsFn;
        })).catch((function(err) {
            console.log("Subtitles error", err);
        }));
    }, Casting.prototype.transcode = function(req, res) {
        if (!req.query.video) return res.statusCode = 400, void res.end("provide ?video");
        req.once("error", noop);
        var isFMP4 = req.query.fmp4, audioTrack = req.query.audioTrack, offset = parseInt(req.query.time, 10) || 0, subtitlesDelay = parseInt(req.query.subtitlesDelay, 10) || 0;
        Promise.all([ castingUtils.getVideoInfo(this.executables.ffmpeg, req.query.video), castingUtils.getRemoteFileMeta(req.query.video), this.makeSubs(req.query.subtitles, Math.max(0, offset - subtitlesDelay)), this.executables.ffmpeg, this.ffmpegErrors ]).then((function(data) {
            var duration = data[0].duration, length = data[1].length, subtitles = (data[1].type, 
            data[2]), ffmpegPath = data[3], ffmpegErrors = data[4];
            duration && (length -= length * offset / duration, duration -= offset);
            var headers = {
                "Content-Type": isFMP4 ? "video/mp4" : "video/x-mkv",
                "Transfer-Encoding": "chunked",
                "Accept-Ranges": "none",
                Connection: "Close",
                "transferMode.dlna.org": "Streaming",
                "contentFeatures.dlna.org": "DLNA.ORG_OP=01;DLNA.ORG_CI=1;DLNA.ORG_FLAGS=01300000000000000000000000000000"
            };
            if (req.headers["getmediainfo.sec"] && (headers["MediaInfo.sec"] = "SEC_Duration=" + 1e3 * duration + ";"), 
            res.writeHead(200, headers), console.log("RESPONSE HEADERS", res._header), "HEAD" != req.method) {
                var audioStream, copyVideo = !subtitles, copyAudio = !0, videoStream = data[0].streams.find((function(stream) {
                    return "Video" == stream.type && "h264" == stream.codec;
                }));
                videoStream || (copyVideo = !1, videoStream = data[0].streams.find((function(stream) {
                    return "Video" == stream.type;
                }))), (audioStream = audioTrack ? data[0].streams.find((function(stream) {
                    return "Audio" == stream.type && stream.id == audioTrack;
                })) : data[0].streams.find((function(stream) {
                    return "Audio" == stream.type && stream.default;
                }))) && (copyAudio = "aac" == audioStream.codec && "stereo" == audioStream.channels), 
                audioStream && duration || (copyAudio = !1, audioStream = data[0].streams.find((function(stream) {
                    return "Audio" == stream.type;
                })));
                var transmuxing = copyAudio && copyVideo, args = [];
                req.query.flagRe && args.push("-re");
                var videoURL = req.query.video;
                videoURL.startsWith("file:") && (videoURL = decodeURI(new URL(videoURL).pathname).replace(/^\/([a-z]+:\/)/i, "$1").replace("/", path.sep)), 
                args.push("-copyts", "-ss", duration > 0 ? offset : 0, "-i", videoURL), duration > 0 && args.push("-t", duration + offset), 
                videoStream && args.push("-map", videoStream.id), audioStream && args.push("-map", audioStream.id), 
                transmuxing ? args.push("-c", "copy") : (videoStream && (copyVideo ? args.push("-c:v", "copy") : (args.push("-c:v", "libx264", "-preset", "ultrafast", "-tune", "zerolatency", "-pix_fmt", "yuv420p"), 
                subtitles && args.push("-vf", "subtitles=" + subtitles))), audioStream && (copyAudio ? args.push("-c:a", "copy") : args.push("-strict", "-2", "-c:a", "aac", "-ac", "2"))), 
                isFMP4 && args.push("-movflags", "frag_keyframe+empty_moov"), args.push("-f", isFMP4 ? "mp4" : "matroska", "-threads", "0", "pipe:1"), 
                console.log("Arguments " + args.join(" "));
                var procOpts = {
                    detached: !0,
                    stdio: [ "ignore", null, ffmpegErrors ]
                }, transcodingProc = child.spawn(ffmpegPath, args, procOpts);
                pump(transcodingProc.stdout, res, (function(e) {
                    console.log(" ---\x3e CLOSE", e ? e.message : ""), transcodingProc.kill("SIGKILL"), 
                    subtitles && fs.unlink(subtitles, noop);
                }));
            } else res.end();
        })).catch((function(e) {
            console.log("Transcoding error:", e), res.end(e.message);
        }));
    }, module.exports = Casting;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var isWindows = "win32" === process.platform, trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;
    module.exports = function() {
        var path;
        return path = isWindows ? process.env.TEMP || process.env.TMP || (process.env.SystemRoot || process.env.windir) + "\\temp" : process.env.TMPDIR || process.env.TMP || process.env.TEMP || "/tmp", 
        trailingSlashRe.test(path) && (path = path.slice(0, -1)), path;
    };
}, function(module, exports) {
    module.exports = require("domain");
}, function(module, exports, __webpack_require__) {
    "use strict";
    function Discovery(Facilities) {
        if (!Array.isArray(Facilities)) throw new TypeError("Invalid facilities");
        for (var i in this.facilities = [], this.devices = {}, Facilities) {
            var facility = new (0, Facilities[i]);
            facility.on("device", this.collect.bind(this)), facility.search(), this.facilities.push(facility);
        }
    }
    Discovery.prototype.collect = function(device) {
        this.devices[device.id] || (console.log('Discovery of new %s device "%s" - %s', device.type, device.id, device.name), 
        this.devices[device.id] = device);
    }, module.exports = Discovery;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var EventEmitter = __webpack_require__(5), util = __webpack_require__(0), externalPlayers = __webpack_require__(892);
    function ExternalDiscovery() {
        EventEmitter.call(this);
        var self = this;
        this.devices = {
            groups: {},
            update: function() {
                self.devices.groups.external.forEach(self.emit.bind(self, "device"));
            }
        };
    }
    util.inherits(ExternalDiscovery, EventEmitter), ExternalDiscovery.prototype.search = function() {
        externalPlayers(this.devices);
    }, module.exports = ExternalDiscovery;
}, function(module, exports, __webpack_require__) {
    var child = __webpack_require__(31), fs = __webpack_require__(2), stremioCast = __webpack_require__(893), enginefs = __webpack_require__(155), http = __webpack_require__(11), os = __webpack_require__(21), path = __webpack_require__(4);
    module.exports = function(devices) {
        var players = {
            vlc: {
                title: "VLC",
                args: [ "--no-video-title-show" ],
                subArg: "--sub-file=",
                timeArg: "--start-time=",
                playArg: "",
                darwin: {
                    path: [ "/Applications/VLC.app/Contents/MacOS/VLC" ]
                },
                linux: {
                    path: [ "/usr/bin/vlc", "/usr/local/bin/vlc" ]
                },
                win32: {
                    path: [ '"C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe"', '"C:\\Program Files\\VideoLAN\\VLC\\vlc.exe"' ]
                }
            },
            mplayerx: {
                title: "MPlayerX",
                args: [ "" ],
                subArg: "-SubFileNameRule ",
                timeArg: "-SeekStepTimeU ",
                playArg: "-url ",
                darwin: {
                    path: [ "/Applications/MPlayerX.app/Contents/MacOS/MPlayerX" ]
                },
                linux: {
                    path: []
                },
                win32: {
                    path: []
                }
            },
            mplayer: {
                title: "MPlayer",
                args: [ "" ],
                subArg: "-sub ",
                timeArg: "-ss ",
                playArg: "",
                darwin: {
                    path: [ "/usr/local/bin/mplayer", "/opt/local/bin/mplayer", "/sw/bin/mplayer" ]
                },
                linux: {
                    path: [ "/usr/bin/mplayer" ]
                },
                win32: {
                    path: []
                }
            },
            mpv: {
                title: "MPV",
                args: [ "--no-terminal" ],
                subArg: "--sub-file=",
                timeArg: "--start=",
                playArg: "",
                darwin: {
                    path: [ "/usr/local/bin/mpv", "/opt/local/bin/mpv", "/sw/bin/mpv" ]
                },
                linux: {
                    path: [ "/usr/bin/mpv" ]
                },
                win32: {
                    path: []
                }
            },
            bomi: {
                title: "Bomi",
                args: [],
                subArg: "--set-subtitle ",
                timeArg: "",
                playArg: "",
                darwin: {
                    path: []
                },
                linux: {
                    path: [ "/usr/bin/bomi" ]
                },
                win32: {
                    path: []
                }
            },
            mpcBe: {
                title: "MPC-BE",
                args: [ "" ],
                subArg: "/sub ",
                timeArg: "start ",
                playArg: "",
                darwin: {
                    path: []
                },
                linux: {
                    path: []
                },
                win32: {
                    path: [ '"C:\\Program Files (x86)\\MPC-BE x64\\mpc-be4.exe"', '"C:\\Program Files\\MPC-BE x64\\mpc-be64.exe"' ]
                }
            }
        };
        devices.groups.external = [], Object.keys(players).forEach((function(el) {
            var player = players[el];
            player[process.platform] && player[process.platform].path.forEach((function(p) {
                fs.existsSync(p.replace(/"/gi, "")) && devices.groups.external.push((function(player, platform) {
                    var playerObj = players[player], platformObj = playerObj[platform];
                    return {
                        name: playerObj.title,
                        type: "external",
                        id: player,
                        onlyHtml5Formats: playerObj.onlyHtml5Formats,
                        play: function(src) {
                            var torrentUrl = src.match(/\/(?<ih>[0-9a-f]{40})\/(?<id>[0-9]+)$/);
                            if (torrentUrl) {
                                var fileIdx = torrentUrl.groups.id, filename = enginefs.getFilename(torrentUrl.groups.ih, fileIdx);
                                filename && (src = src.replace(new RegExp(fileIdx + "$"), encodeURIComponent(filename)));
                            }
                            var self = this;
                            setTimeout((function() {
                                var port = enginefs.baseUrl.match(".*?:([0-9]+)")[1], host = enginefs.baseUrl.match("^http://(.*):[0-9]+$")[1], subsPath = self.subtitlesSrc, time = self.time, subsFile = "", playExternal = function() {
                                    var playerPaths = platformObj.path.filter((function(path) {
                                        return fs.existsSync(path.replace(/"/gi, ""));
                                    }));
                                    if (playerPaths.length > 0) {
                                        var wrappedSrc = '"' + src + '"', subsCmd = subsFile && players[player].subArg && players[player].subArg.length > 0 ? players[player].subArg + subsFile : "", argsCmd = players[player].args && players[player].args.length > 0 ? players[player].args.join(" ") : "", timeCmd = players[player].timeArg && players[player].timeArg.length > 0 ? players[player].timeArg + parseInt(time / 1e3) : "", playCmd = players[player].playArg && players[player].playArg.length > 0 ? players[player].playArg + wrappedSrc : wrappedSrc, fullCmd = playerPaths[0] + " " + timeCmd + " " + argsCmd + " " + subsCmd + " " + playCmd;
                                        child.exec(fullCmd, (function(error) {
                                            console.error("Failed executing external player command:", error);
                                        })).on("exit", (function() {
                                            if (subsFile) try {
                                                fs.unlinkSync(subsFile);
                                            } catch (e) {
                                                console.error("Cannot remove the subtitles file:", e);
                                            }
                                        }));
                                    }
                                };
                                subsPath ? (subsFile = path.join(os.tmpdir(), "stremio-" + player + "-subtitles.srt"), 
                                http.request({
                                    host: host,
                                    path: "/subtitles.srt?from=" + encodeURIComponent(subsPath),
                                    port: port
                                }, (function(response) {
                                    var data = "";
                                    response.on("data", (function(d) {
                                        data += d.toString();
                                    })), response.on("end", (function() {
                                        try {
                                            fs.writeFileSync(subsFile, data.toString());
                                        } catch (e) {
                                            console.error("Cannot get the subtitles:", e), subsFile = "";
                                        }
                                        playExternal();
                                    }));
                                })).end()) : playExternal();
                            }), 1500);
                        }
                    };
                })(el, process.platform));
            }));
        })), devices.groups.external.forEach((function(dev) {
            dev.usePlayerUI = !0, dev.stop = function() {}, dev.middleware = new stremioCast.Server(dev);
        })), devices.update();
    };
}, function(module, exports, __webpack_require__) {
    module.exports = {
        Client: __webpack_require__(894),
        Server: __webpack_require__(895)
    };
}, function(module, exports, __webpack_require__) {
    var fetch = "undefined" != typeof window ? window.fetch : __webpack_require__(33), events = __webpack_require__(5), PROPS = [ "audio", "audioTrack", "volume", "time", "paused", "state", "length", "mediaSessionId", "subtitlesSrc", "subtitlesDelay", "subtitlesSize" ];
    module.exports = function(url) {
        var self = new events.EventEmitter;
        self.initialized = !1;
        var status = {}, modified = {}, timer = null;
        function sync() {
            var p = fetch(url, {
                method: "POST",
                body: JSON.stringify(modified),
                headers: {
                    "content-type": "application/json"
                }
            });
            modified = {}, p.then((function(res) {
                return res.json();
            })).then((function(resp) {
                var old, current;
                old = status, (current = status = resp).state === old.state && current.source === old.source && current.mediaSessionId === old.mediaSessionId || self.emit("statechanged", {
                    state: current.state
                }), current.time !== old.time && self.emit("timeupdate", {
                    time: current.time
                }), resetTimer();
            }));
        }
        function resetTimer(t) {
            clearTimeout(timer), timer = self.source ? setTimeout(sync, t || 1e3) : null;
        }
        return PROPS.forEach((function(p) {
            Object.defineProperty(self, p, {
                get: function() {
                    return modified.hasOwnProperty(p) ? modified[p] : status[p];
                },
                set: function(v) {
                    modified[p] = v, resetTimer(50), "volume" === p && self.emit("volumechanged");
                }
            });
        })), self.play = function(src) {
            self.source = modified.source = src, resetTimer(50);
        }, self.stop = function() {
            self.source && (resetTimer(50), self.source = modified.source = null);
        }, self;
    };
}, function(module, exports) {
    var PROPS = [ "volume", "time", "paused", "state", "length", "source", "mediaSessionId", "subtitlesSrc", "subtitlesDelay", "subtitlesSize" ];
    module.exports = function(player, manifest) {
        return function(req, res, next) {
            if (!req.body) return res.end(400);
            var modifications = req.body || {};
            Object.keys(modifications).forEach((function(k) {
                "source" === k && (modifications.source ? player.play(modifications.source) : player.stop()), 
                modifications[k] !== player[k] && (player[k] = modifications[k]);
            })), (function(next) {
                player.update ? player.update(next) : next();
            })((function() {
                var status = {};
                PROPS.forEach((function(k) {
                    status[k] = player[k];
                })), res.setHeader("content-type", "application/json"), res.end(JSON.stringify(status));
            }));
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var EventEmitter = __webpack_require__(5), txt = __webpack_require__(897)(), MDNS = __webpack_require__(899);
    function MDNSDiscovery() {
        EventEmitter.call(this), this.MDNSServices = {
            "_googlecast._tcp.local": "chromecast"
        }, this.mdns = MDNS({
            loopback: !0,
            reuseAddr: !0
        }), this.mdns.on("response", this.onResponse.bind(this)), this.mdns.on("error", (function(e) {
            console.log("MDNS error", e);
        }));
    }
    __webpack_require__(0).inherits(MDNSDiscovery, EventEmitter), MDNSDiscovery.prototype.search = function() {
        for (var service in this.MDNSServices) this.mdns.query(service, "PTR");
    }, MDNSDiscovery.prototype.propMap = function(res, item) {
        return res[item.type] = item.data, res;
    }, MDNSDiscovery.prototype.onResponse = function(response) {
        if (0 !== response.answers.length && void 0 !== this.MDNSServices[response.answers[0].name]) {
            var records = response.additionals.reduce(this.propMap, {});
            if (response.answers.reduce(this.propMap, records), records.TXT && records.SRV) {
                var device = {
                    facility: "MDNS",
                    id: records.SRV.target.slice(0, records.SRV.target.indexOf(".local") >>> 0),
                    name: txt.decode(records.TXT).fn || records.PTR.replace("." + response.answers[0].name, ""),
                    host: records.A,
                    location: records.A,
                    type: this.MDNSServices[response.answers[0].name],
                    icon: "chromecast",
                    playerUIRoles: [ "playpause", "seek", "dub", "subtitles", "volume" ],
                    usePlayerUI: !0,
                    onlyHtml5Formats: !1
                };
                this.emit("device", device);
            }
        }
    }, module.exports = MDNSDiscovery;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bindexOf = __webpack_require__(898), equalSign = new Buffer("=");
    function decodeBlock(buf, offset) {
        var len = buf[offset], to = offset + 1 + len, b = buf.slice(offset + 1, to > buf.length ? buf.length : to);
        return decodeBlock.bytes = len + 1, b;
    }
    module.exports = function(opts) {
        var binary = !!opts && opts.binary, that = {
            encode: function(data, buf, offset) {
                data || (data = {}), offset || (offset = 0), buf || (buf = new Buffer(that.encodingLength(data) + offset));
                var oldOffset = offset, keys = Object.keys(data);
                return 0 === keys.length && (buf[offset] = 0, offset++), keys.forEach((function(key) {
                    var val = data[key], oldOffset = offset;
                    if (offset++, !0 === val) offset += buf.write(key, offset); else if (Buffer.isBuffer(val)) {
                        offset += buf.write(key + "=", offset);
                        var len = val.length;
                        val.copy(buf, offset, 0, len), offset += len;
                    } else offset += buf.write(key + "=" + val, offset);
                    buf[oldOffset] = offset - oldOffset - 1;
                })), that.encode.bytes = offset - oldOffset, buf;
            },
            decode: function(buf, offset, len) {
                offset || (offset = 0), Number.isFinite(len) || (len = buf.length);
                for (var data = {}, oldOffset = offset; offset < len; ) {
                    var b = decodeBlock(buf, offset), i = bindexOf(b, equalSign);
                    if (offset += decodeBlock.bytes, 0 !== b.length) if (-1 === i) data[b.toString().toLowerCase()] = !0; else {
                        if (0 === i) continue;
                        var key = b.slice(0, i).toString().toLowerCase();
                        if (key in data) continue;
                        data[key] = binary ? b.slice(i + 1) : b.slice(i + 1).toString();
                    }
                }
                return that.decode.bytes = offset - oldOffset, data;
            },
            encodingLength: function(data) {
                if (!data) return 1;
                var keys = Object.keys(data);
                return 0 === keys.length ? 1 : keys.reduce((function(total, key) {
                    var val = data[key];
                    return total += Buffer.byteLength(key) + 1, Buffer.isBuffer(val) ? total += val.length + 1 : !0 !== val && (total += Buffer.byteLength(String(val)) + 1), 
                    total;
                }), 0);
            }
        };
        return that;
    };
}, function(module, exports) {
    module.exports = function(buff, search, offset, encoding) {
        if (!Buffer.isBuffer(buff)) throw TypeError("buffer is not a buffer");
        if (void 0 === encoding && "string" == typeof offset && (encoding = offset, offset = void 0), 
        "string" == typeof search) search = new Buffer(search, encoding || "utf8"); else if ("number" != typeof search || isNaN(search)) {
            if (!Buffer.isBuffer(search)) throw TypeError("search is not a bufferable object");
        } else search = new Buffer([ search ]);
        if (0 === search.length) return -1;
        if (void 0 === offset || "number" == typeof offset && isNaN(offset)) offset = 0; else if ("number" != typeof offset) throw TypeError("offset is not a number");
        offset < 0 && (offset = buff.length + offset), offset < 0 && (offset = 0);
        for (var m = 0, s = -1, i = offset; i < buff.length && (buff[i] != search[m] && (s = -1, 
        i -= m - 1, m = 0), buff[i] != search[m] || (-1 == s && (s = i), ++m != search.length)); ++i) ;
        return s > -1 && buff.length - s < search.length ? -1 : s;
    };
}, function(module, exports, __webpack_require__) {
    var packet = __webpack_require__(900), dgram = __webpack_require__(69), thunky = __webpack_require__(904), events = __webpack_require__(5), os = __webpack_require__(21), noop = function() {};
    module.exports = function(opts) {
        opts || (opts = {});
        var that = new events.EventEmitter, port = "number" == typeof opts.port ? opts.port : 5353, type = opts.type || "udp4", ip = opts.ip || opts.host || ("udp4" === type ? "224.0.0.251" : null), me = {
            address: ip,
            port: port
        }, memberships = {}, destroyed = !1, interval = null;
        if (!("udp6" !== type || ip && opts.interface)) throw new Error("For IPv6 multicast you must specify `ip` and `interface`");
        var socket = opts.socket || dgram.createSocket({
            type: type,
            reuseAddr: !1 !== opts.reuseAddr,
            toString: function() {
                return type;
            }
        });
        socket.on("error", (function(err) {
            "EACCES" === err.code || "EADDRINUSE" === err.code ? that.emit("error", err) : that.emit("warning", err);
        })), socket.on("message", (function(message, rinfo) {
            try {
                message = packet.decode(message);
            } catch (err) {
                return void that.emit("warning", err);
            }
            that.emit("packet", message, rinfo), "query" === message.type && that.emit("query", message, rinfo), 
            "response" === message.type && that.emit("response", message, rinfo);
        })), socket.on("listening", (function() {
            port || (port = me.port = socket.address().port), !1 !== opts.multicast && (that.update(), 
            interval = setInterval(that.update, 5e3), socket.setMulticastTTL(opts.ttl || 255), 
            socket.setMulticastLoopback(!1 !== opts.loopback));
        }));
        var bind = thunky((function(cb) {
            if (!port) return cb(null);
            socket.once("error", cb), socket.bind(port, opts.interface, (function() {
                socket.removeListener("error", cb), cb(null);
            }));
        }));
        return bind((function(err) {
            if (err) return that.emit("error", err);
            that.emit("ready");
        })), that.send = function(value, rinfo, cb) {
            if ("function" == typeof rinfo) return that.send(value, null, rinfo);
            cb || (cb = noop), rinfo || (rinfo = me), bind((function(err) {
                if (destroyed) return cb();
                if (err) return cb(err);
                var message = packet.encode(value);
                socket.send(message, 0, message.length, rinfo.port, rinfo.address || rinfo.host, cb);
            }));
        }, that.response = that.respond = function(res, rinfo, cb) {
            Array.isArray(res) && (res = {
                answers: res
            }), res.type = "response", res.flags = (res.flags || 0) | packet.AUTHORITATIVE_ANSWER, 
            that.send(res, rinfo, cb);
        }, that.query = function(q, type, rinfo, cb) {
            return "function" == typeof type ? that.query(q, null, null, type) : "object" == typeof type && type && type.port ? that.query(q, null, type, rinfo) : "function" == typeof rinfo ? that.query(q, type, null, rinfo) : (cb || (cb = noop), 
            "string" == typeof q && (q = [ {
                name: q,
                type: type || "ANY"
            } ]), Array.isArray(q) && (q = {
                type: "query",
                questions: q
            }), q.type = "query", void that.send(q, rinfo, cb));
        }, that.destroy = function(cb) {
            if (cb || (cb = noop), destroyed) return process.nextTick(cb);
            destroyed = !0, clearInterval(interval), socket.once("close", cb), socket.close();
        }, that.update = function() {
            for (var ifaces = opts.interface ? [].concat(opts.interface) : (function() {
                for (var networks = os.networkInterfaces(), names = Object.keys(networks), res = [], i = 0; i < names.length; i++) for (var net = networks[names[i]], j = 0; j < net.length; j++) {
                    var iface = net[j];
                    if ("IPv4" === iface.family) {
                        res.push(iface.address);
                        break;
                    }
                }
                return res;
            })(), updated = !1, i = 0; i < ifaces.length; i++) {
                var addr = ifaces[i];
                if (!memberships[addr]) {
                    memberships[addr] = !0, updated = !0;
                    try {
                        socket.addMembership(ip, addr);
                    } catch (err) {
                        that.emit("warning", err);
                    }
                }
            }
            updated && socket.setMulticastInterface && socket.setMulticastInterface(opts.interface || (function() {
                for (var networks = os.networkInterfaces(), names = Object.keys(networks), i = 0; i < names.length; i++) for (var net = networks[names[i]], j = 0; j < net.length; j++) {
                    var iface = net[j];
                    if ("IPv4" === iface.family && !iface.internal) return iface.address;
                }
                return "127.0.0.1";
            })());
        }, that;
    };
}, function(module, exports, __webpack_require__) {
    var types = __webpack_require__(901), rcodes = __webpack_require__(902), opcodes = __webpack_require__(903), ip = __webpack_require__(116), Buffer = __webpack_require__(23).Buffer, name = exports.txt = exports.name = {};
    name.encode = function(str, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(name.encodingLength(str))), offset || (offset = 0);
        var oldOffset = offset, n = str.replace(/^\.|\.$/gm, "");
        if (n.length) for (var list = n.split("."), i = 0; i < list.length; i++) {
            var len = buf.write(list[i], offset + 1);
            buf[offset] = len, offset += len + 1;
        }
        return buf[offset++] = 0, name.encode.bytes = offset - oldOffset, buf;
    }, name.encode.bytes = 0, name.decode = function(buf, offset) {
        offset || (offset = 0);
        var list = [], oldOffset = offset, len = buf[offset++];
        if (0 === len) return name.decode.bytes = 1, ".";
        if (len >= 192) {
            var res = name.decode(buf, buf.readUInt16BE(offset - 1) - 49152);
            return name.decode.bytes = 2, res;
        }
        for (;len; ) {
            if (len >= 192) {
                list.push(name.decode(buf, buf.readUInt16BE(offset - 1) - 49152)), offset++;
                break;
            }
            list.push(buf.toString("utf-8", offset, offset + len)), offset += len, len = buf[offset++];
        }
        return name.decode.bytes = offset - oldOffset, list.join(".");
    }, name.decode.bytes = 0, name.encodingLength = function(n) {
        return Buffer.byteLength(n) + 2;
    };
    var string = {
        encode: function(s, buf, offset) {
            buf || (buf = Buffer.allocUnsafe(string.encodingLength(s))), offset || (offset = 0);
            var len = buf.write(s, offset + 1);
            return buf[offset] = len, string.encode.bytes = len + 1, buf;
        }
    };
    string.encode.bytes = 0, string.decode = function(buf, offset) {
        offset || (offset = 0);
        var len = buf[offset], s = buf.toString("utf-8", offset + 1, offset + 1 + len);
        return string.decode.bytes = len + 1, s;
    }, string.decode.bytes = 0, string.encodingLength = function(s) {
        return Buffer.byteLength(s) + 1;
    };
    var header = {
        encode: function(h, buf, offset) {
            buf || (buf = header.encodingLength(h)), offset || (offset = 0);
            var flags = 32767 & (h.flags || 0), type = "response" === h.type ? 32768 : 0;
            return buf.writeUInt16BE(h.id || 0, offset), buf.writeUInt16BE(flags | type, offset + 2), 
            buf.writeUInt16BE(h.questions.length, offset + 4), buf.writeUInt16BE(h.answers.length, offset + 6), 
            buf.writeUInt16BE(h.authorities.length, offset + 8), buf.writeUInt16BE(h.additionals.length, offset + 10), 
            buf;
        }
    };
    header.encode.bytes = 12, header.decode = function(buf, offset) {
        if (offset || (offset = 0), buf.length < 12) throw new Error("Header must be 12 bytes");
        var flags = buf.readUInt16BE(offset + 2);
        return {
            id: buf.readUInt16BE(offset),
            type: 32768 & flags ? "response" : "query",
            flags: 32767 & flags,
            flag_qr: 1 == (flags >> 15 & 1),
            opcode: opcodes.toString(flags >> 11 & 15),
            flag_auth: 1 == (flags >> 10 & 1),
            flag_trunc: 1 == (flags >> 9 & 1),
            flag_rd: 1 == (flags >> 8 & 1),
            flag_ra: 1 == (flags >> 7 & 1),
            flag_z: 1 == (flags >> 6 & 1),
            flag_ad: 1 == (flags >> 5 & 1),
            flag_cd: 1 == (flags >> 4 & 1),
            rcode: rcodes.toString(15 & flags),
            questions: new Array(buf.readUInt16BE(offset + 4)),
            answers: new Array(buf.readUInt16BE(offset + 6)),
            authorities: new Array(buf.readUInt16BE(offset + 8)),
            additionals: new Array(buf.readUInt16BE(offset + 10))
        };
    }, header.decode.bytes = 12, header.encodingLength = function() {
        return 12;
    };
    var runknown = exports.unknown = {};
    runknown.encode = function(data, buf, offset) {
        return buf || (buf = Buffer.allocUnsafe(runknown.encodingLength(data))), offset || (offset = 0), 
        buf.writeUInt16BE(data.length, offset), data.copy(buf, offset + 2), runknown.encode.bytes = data.length + 2, 
        buf;
    }, runknown.encode.bytes = 0, runknown.decode = function(buf, offset) {
        offset || (offset = 0);
        var len = buf.readUInt16BE(offset), data = buf.slice(offset + 2, offset + 2 + len);
        return runknown.decode.bytes = len + 2, data;
    }, runknown.decode.bytes = 0, runknown.encodingLength = function(data) {
        return data.length + 2;
    };
    var rns = exports.ns = {};
    rns.encode = function(data, buf, offset) {
        return buf || (buf = Buffer.allocUnsafe(rns.encodingLength(data))), offset || (offset = 0), 
        name.encode(data, buf, offset + 2), buf.writeUInt16BE(name.encode.bytes, offset), 
        rns.encode.bytes = name.encode.bytes + 2, buf;
    }, rns.encode.bytes = 0, rns.decode = function(buf, offset) {
        offset || (offset = 0);
        var len = buf.readUInt16BE(offset), dd = name.decode(buf, offset + 2);
        return rns.decode.bytes = len + 2, dd;
    }, rns.decode.bytes = 0, rns.encodingLength = function(data) {
        return name.encodingLength(data) + 2;
    };
    var rsoa = exports.soa = {};
    rsoa.encode = function(data, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(rsoa.encodingLength(data))), offset || (offset = 0);
        var oldOffset = offset;
        return offset += 2, name.encode(data.mname, buf, offset), offset += name.encode.bytes, 
        name.encode(data.rname, buf, offset), offset += name.encode.bytes, buf.writeUInt32BE(data.serial || 0, offset), 
        offset += 4, buf.writeUInt32BE(data.refresh || 0, offset), offset += 4, buf.writeUInt32BE(data.retry || 0, offset), 
        offset += 4, buf.writeUInt32BE(data.expire || 0, offset), offset += 4, buf.writeUInt32BE(data.minimum || 0, offset), 
        offset += 4, buf.writeUInt16BE(offset - oldOffset - 2, oldOffset), rsoa.encode.bytes = offset - oldOffset, 
        buf;
    }, rsoa.encode.bytes = 0, rsoa.decode = function(buf, offset) {
        offset || (offset = 0);
        var oldOffset = offset, data = {};
        return offset += 2, data.mname = name.decode(buf, offset), offset += name.decode.bytes, 
        data.rname = name.decode(buf, offset), offset += name.decode.bytes, data.serial = buf.readUInt32BE(offset), 
        offset += 4, data.refresh = buf.readUInt32BE(offset), offset += 4, data.retry = buf.readUInt32BE(offset), 
        offset += 4, data.expire = buf.readUInt32BE(offset), offset += 4, data.minimum = buf.readUInt32BE(offset), 
        offset += 4, rsoa.decode.bytes = offset - oldOffset, data;
    }, rsoa.decode.bytes = 0, rsoa.encodingLength = function(data) {
        return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname);
    };
    var rtxt = exports.txt = exports.null = {}, rnull = rtxt;
    rtxt.encode = function(data, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(rtxt.encodingLength(data))), offset || (offset = 0), 
        "string" == typeof data && (data = Buffer.from(data)), data || (data = Buffer.allocUnsafe(0));
        var oldOffset = offset;
        offset += 2;
        var len = data.length;
        return data.copy(buf, offset, 0, len), offset += len, buf.writeUInt16BE(offset - oldOffset - 2, oldOffset), 
        rtxt.encode.bytes = offset - oldOffset, buf;
    }, rtxt.encode.bytes = 0, rtxt.decode = function(buf, offset) {
        offset || (offset = 0);
        var oldOffset = offset, len = buf.readUInt16BE(offset);
        offset += 2;
        var data = buf.slice(offset, offset + len);
        return offset += len, rtxt.decode.bytes = offset - oldOffset, data;
    }, rtxt.decode.bytes = 0, rtxt.encodingLength = function(data) {
        return data ? (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2 : 2;
    };
    var rhinfo = exports.hinfo = {};
    rhinfo.encode = function(data, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(rhinfo.encodingLength(data))), offset || (offset = 0);
        var oldOffset = offset;
        return offset += 2, string.encode(data.cpu, buf, offset), offset += string.encode.bytes, 
        string.encode(data.os, buf, offset), offset += string.encode.bytes, buf.writeUInt16BE(offset - oldOffset - 2, oldOffset), 
        rhinfo.encode.bytes = offset - oldOffset, buf;
    }, rhinfo.encode.bytes = 0, rhinfo.decode = function(buf, offset) {
        offset || (offset = 0);
        var oldOffset = offset, data = {};
        return offset += 2, data.cpu = string.decode(buf, offset), offset += string.decode.bytes, 
        data.os = string.decode(buf, offset), offset += string.decode.bytes, rhinfo.decode.bytes = offset - oldOffset, 
        data;
    }, rhinfo.decode.bytes = 0, rhinfo.encodingLength = function(data) {
        return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2;
    };
    var rptr = exports.ptr = {}, rcname = exports.cname = rptr, rdname = exports.dname = rptr;
    rptr.encode = function(data, buf, offset) {
        return buf || (buf = Buffer.allocUnsafe(rptr.encodingLength(data))), offset || (offset = 0), 
        name.encode(data, buf, offset + 2), buf.writeUInt16BE(name.encode.bytes, offset), 
        rptr.encode.bytes = name.encode.bytes + 2, buf;
    }, rptr.encode.bytes = 0, rptr.decode = function(buf, offset) {
        offset || (offset = 0);
        var data = name.decode(buf, offset + 2);
        return rptr.decode.bytes = name.decode.bytes + 2, data;
    }, rptr.decode.bytes = 0, rptr.encodingLength = function(data) {
        return name.encodingLength(data) + 2;
    };
    var rsrv = exports.srv = {};
    rsrv.encode = function(data, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(rsrv.encodingLength(data))), offset || (offset = 0), 
        buf.writeUInt16BE(data.priority || 0, offset + 2), buf.writeUInt16BE(data.weight || 0, offset + 4), 
        buf.writeUInt16BE(data.port || 0, offset + 6), name.encode(data.target, buf, offset + 8);
        var len = name.encode.bytes + 6;
        return buf.writeUInt16BE(len, offset), rsrv.encode.bytes = len + 2, buf;
    }, rsrv.encode.bytes = 0, rsrv.decode = function(buf, offset) {
        offset || (offset = 0);
        var len = buf.readUInt16BE(offset), data = {};
        return data.priority = buf.readUInt16BE(offset + 2), data.weight = buf.readUInt16BE(offset + 4), 
        data.port = buf.readUInt16BE(offset + 6), data.target = name.decode(buf, offset + 8), 
        rsrv.decode.bytes = len + 2, data;
    }, rsrv.decode.bytes = 0, rsrv.encodingLength = function(data) {
        return 8 + name.encodingLength(data.target);
    };
    var rcaa = exports.caa = {};
    rcaa.ISSUER_CRITICAL = 128, rcaa.encode = function(data, buf, offset) {
        var len = rcaa.encodingLength(data);
        return buf || (buf = Buffer.allocUnsafe(rcaa.encodingLength(data))), offset || (offset = 0), 
        data.issuerCritical && (data.flags = rcaa.ISSUER_CRITICAL), buf.writeUInt16BE(len - 2, offset), 
        offset += 2, buf.writeUInt8(data.flags || 0, offset), offset += 1, string.encode(data.tag, buf, offset), 
        offset += string.encode.bytes, buf.write(data.value, offset), offset += Buffer.byteLength(data.value), 
        rcaa.encode.bytes = len, buf;
    }, rcaa.encode.bytes = 0, rcaa.decode = function(buf, offset) {
        offset || (offset = 0);
        var len = buf.readUInt16BE(offset), oldOffset = offset += 2, data = {};
        return data.flags = buf.readUInt8(offset), offset += 1, data.tag = string.decode(buf, offset), 
        offset += string.decode.bytes, data.value = buf.toString("utf-8", offset, oldOffset + len), 
        data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL), rcaa.decode.bytes = len + 2, 
        data;
    }, rcaa.decode.bytes = 0, rcaa.encodingLength = function(data) {
        return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2;
    };
    var ra = exports.a = {};
    ra.encode = function(host, buf, offset) {
        return buf || (buf = Buffer.allocUnsafe(ra.encodingLength(host))), offset || (offset = 0), 
        buf.writeUInt16BE(4, offset), offset += 2, ip.toBuffer(host, buf, offset), ra.encode.bytes = 6, 
        buf;
    }, ra.encode.bytes = 0, ra.decode = function(buf, offset) {
        offset || (offset = 0), offset += 2;
        var host = ip.toString(buf, offset, 4);
        return ra.decode.bytes = 6, host;
    }, ra.decode.bytes = 0, ra.encodingLength = function() {
        return 6;
    };
    var raaaa = exports.aaaa = {};
    raaaa.encode = function(host, buf, offset) {
        return buf || (buf = Buffer.allocUnsafe(raaaa.encodingLength(host))), offset || (offset = 0), 
        buf.writeUInt16BE(16, offset), offset += 2, ip.toBuffer(host, buf, offset), raaaa.encode.bytes = 18, 
        buf;
    }, raaaa.encode.bytes = 0, raaaa.decode = function(buf, offset) {
        offset || (offset = 0), offset += 2;
        var host = ip.toString(buf, offset, 16);
        return raaaa.decode.bytes = 18, host;
    }, raaaa.decode.bytes = 0, raaaa.encodingLength = function() {
        return 18;
    };
    var renc = exports.record = function(type) {
        switch (type.toUpperCase()) {
          case "A":
            return ra;

          case "PTR":
            return rptr;

          case "CNAME":
            return rcname;

          case "DNAME":
            return rdname;

          case "TXT":
            return rtxt;

          case "NULL":
            return rnull;

          case "AAAA":
            return raaaa;

          case "SRV":
            return rsrv;

          case "HINFO":
            return rhinfo;

          case "CAA":
            return rcaa;

          case "NS":
            return rns;

          case "SOA":
            return rsoa;
        }
        return runknown;
    }, answer = exports.answer = {};
    answer.encode = function(a, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(answer.encodingLength(a))), offset || (offset = 0);
        var oldOffset = offset;
        name.encode(a.name, buf, offset), offset += name.encode.bytes, buf.writeUInt16BE(types.toType(a.type), offset);
        var klass = void 0 === a.class ? 1 : a.class;
        a.flush && (klass |= 32768), buf.writeUInt16BE(klass, offset + 2), buf.writeUInt32BE(a.ttl || 0, offset + 4);
        var enc = renc(a.type);
        return enc.encode(a.data, buf, offset + 8), offset += 8 + enc.encode.bytes, answer.encode.bytes = offset - oldOffset, 
        buf;
    }, answer.encode.bytes = 0, answer.decode = function(buf, offset) {
        offset || (offset = 0);
        var a = {}, oldOffset = offset;
        a.name = name.decode(buf, offset), offset += name.decode.bytes, a.type = types.toString(buf.readUInt16BE(offset)), 
        a.class = buf.readUInt16BE(offset + 2), a.ttl = buf.readUInt32BE(offset + 4), a.flush = !!(32768 & a.class), 
        a.flush && (a.class &= -32769);
        var enc = renc(a.type);
        return a.data = enc.decode(buf, offset + 8), offset += 8 + enc.decode.bytes, answer.decode.bytes = offset - oldOffset, 
        a;
    }, answer.decode.bytes = 0, answer.encodingLength = function(a) {
        return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(a.data);
    };
    var question = exports.question = {};
    function encodingLengthList(list, enc) {
        for (var len = 0, i = 0; i < list.length; i++) len += enc.encodingLength(list[i]);
        return len;
    }
    function encodeList(list, enc, buf, offset) {
        for (var i = 0; i < list.length; i++) enc.encode(list[i], buf, offset), offset += enc.encode.bytes;
        return offset;
    }
    function decodeList(list, enc, buf, offset) {
        for (var i = 0; i < list.length; i++) list[i] = enc.decode(buf, offset), offset += enc.decode.bytes;
        return offset;
    }
    question.encode = function(q, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(question.encodingLength(q))), offset || (offset = 0);
        var oldOffset = offset;
        return name.encode(q.name, buf, offset), offset += name.encode.bytes, buf.writeUInt16BE(types.toType(q.type), offset), 
        offset += 2, buf.writeUInt16BE(void 0 === q.class ? 1 : q.class, offset), offset += 2, 
        question.encode.bytes = offset - oldOffset, q;
    }, question.encode.bytes = 0, question.decode = function(buf, offset) {
        offset || (offset = 0);
        var oldOffset = offset, q = {};
        return q.name = name.decode(buf, offset), offset += name.decode.bytes, q.type = types.toString(buf.readUInt16BE(offset)), 
        offset += 2, q.class = buf.readUInt16BE(offset), offset += 2, !!(32768 & q.class) && (q.class &= -32769), 
        question.decode.bytes = offset - oldOffset, q;
    }, question.decode.bytes = 0, question.encodingLength = function(q) {
        return name.encodingLength(q.name) + 4;
    }, exports.AUTHORITATIVE_ANSWER = 1024, exports.TRUNCATED_RESPONSE = 512, exports.RECURSION_DESIRED = 256, 
    exports.RECURSION_AVAILABLE = 128, exports.AUTHENTIC_DATA = 32, exports.CHECKING_DISABLED = 16, 
    exports.encode = function(result, buf, offset) {
        buf || (buf = Buffer.allocUnsafe(exports.encodingLength(result))), offset || (offset = 0);
        var oldOffset = offset;
        return result.questions || (result.questions = []), result.answers || (result.answers = []), 
        result.authorities || (result.authorities = []), result.additionals || (result.additionals = []), 
        header.encode(result, buf, offset), offset += header.encode.bytes, offset = encodeList(result.questions, question, buf, offset), 
        offset = encodeList(result.answers, answer, buf, offset), offset = encodeList(result.authorities, answer, buf, offset), 
        offset = encodeList(result.additionals, answer, buf, offset), exports.encode.bytes = offset - oldOffset, 
        buf;
    }, exports.encode.bytes = 0, exports.decode = function(buf, offset) {
        offset || (offset = 0);
        var oldOffset = offset, result = header.decode(buf, offset);
        return offset += header.decode.bytes, offset = decodeList(result.questions, question, buf, offset), 
        offset = decodeList(result.answers, answer, buf, offset), offset = decodeList(result.authorities, answer, buf, offset), 
        offset = decodeList(result.additionals, answer, buf, offset), exports.decode.bytes = offset - oldOffset, 
        result;
    }, exports.decode.bytes = 0, exports.encodingLength = function(result) {
        return header.encodingLength(result) + encodingLengthList(result.questions || [], question) + encodingLengthList(result.answers || [], answer) + encodingLengthList(result.authorities || [], answer) + encodingLengthList(result.additionals || [], answer);
    };
}, function(module, exports) {
    exports.toString = function(type) {
        switch (type) {
          case 1:
            return "A";

          case 10:
            return "NULL";

          case 28:
            return "AAAA";

          case 18:
            return "AFSDB";

          case 42:
            return "APL";

          case 257:
            return "CAA";

          case 60:
            return "CDNSKEY";

          case 59:
            return "CDS";

          case 37:
            return "CERT";

          case 5:
            return "CNAME";

          case 49:
            return "DHCID";

          case 32769:
            return "DLV";

          case 39:
            return "DNAME";

          case 48:
            return "DNSKEY";

          case 43:
            return "DS";

          case 55:
            return "HIP";

          case 13:
            return "HINFO";

          case 45:
            return "IPSECKEY";

          case 25:
            return "KEY";

          case 36:
            return "KX";

          case 29:
            return "LOC";

          case 15:
            return "MX";

          case 35:
            return "NAPTR";

          case 2:
            return "NS";

          case 47:
            return "NSEC";

          case 50:
            return "NSEC3";

          case 51:
            return "NSEC3PARAM";

          case 12:
            return "PTR";

          case 46:
            return "RRSIG";

          case 17:
            return "RP";

          case 24:
            return "SIG";

          case 6:
            return "SOA";

          case 99:
            return "SPF";

          case 33:
            return "SRV";

          case 44:
            return "SSHFP";

          case 32768:
            return "TA";

          case 249:
            return "TKEY";

          case 52:
            return "TLSA";

          case 250:
            return "TSIG";

          case 16:
            return "TXT";

          case 252:
            return "AXFR";

          case 251:
            return "IXFR";

          case 41:
            return "OPT";

          case 255:
            return "ANY";
        }
        return "UNKNOWN_" + type;
    }, exports.toType = function(name) {
        switch (name.toUpperCase()) {
          case "A":
            return 1;

          case "NULL":
            return 10;

          case "AAAA":
            return 28;

          case "AFSDB":
            return 18;

          case "APL":
            return 42;

          case "CAA":
            return 257;

          case "CDNSKEY":
            return 60;

          case "CDS":
            return 59;

          case "CERT":
            return 37;

          case "CNAME":
            return 5;

          case "DHCID":
            return 49;

          case "DLV":
            return 32769;

          case "DNAME":
            return 39;

          case "DNSKEY":
            return 48;

          case "DS":
            return 43;

          case "HIP":
            return 55;

          case "HINFO":
            return 13;

          case "IPSECKEY":
            return 45;

          case "KEY":
            return 25;

          case "KX":
            return 36;

          case "LOC":
            return 29;

          case "MX":
            return 15;

          case "NAPTR":
            return 35;

          case "NS":
            return 2;

          case "NSEC":
            return 47;

          case "NSEC3":
            return 50;

          case "NSEC3PARAM":
            return 51;

          case "PTR":
            return 12;

          case "RRSIG":
            return 46;

          case "RP":
            return 17;

          case "SIG":
            return 24;

          case "SOA":
            return 6;

          case "SPF":
            return 99;

          case "SRV":
            return 33;

          case "SSHFP":
            return 44;

          case "TA":
            return 32768;

          case "TKEY":
            return 249;

          case "TLSA":
            return 52;

          case "TSIG":
            return 250;

          case "TXT":
            return 16;

          case "AXFR":
            return 252;

          case "IXFR":
            return 251;

          case "OPT":
            return 41;

          case "ANY":
          case "*":
            return 255;
        }
        return 0;
    };
}, function(module, exports) {
    exports.toString = function(rcode) {
        switch (rcode) {
          case 0:
            return "NOERROR";

          case 1:
            return "FORMERR";

          case 2:
            return "SERVFAIL";

          case 3:
            return "NXDOMAIN";

          case 4:
            return "NOTIMP";

          case 5:
            return "REFUSED";

          case 6:
            return "YXDOMAIN";

          case 7:
            return "YXRRSET";

          case 8:
            return "NXRRSET";

          case 9:
            return "NOTAUTH";

          case 10:
            return "NOTZONE";

          case 11:
            return "RCODE_11";

          case 12:
            return "RCODE_12";

          case 13:
            return "RCODE_13";

          case 14:
            return "RCODE_14";

          case 15:
            return "RCODE_15";
        }
        return "RCODE_" + rcode;
    }, exports.toRcode = function(code) {
        switch (code.toUpperCase()) {
          case "NOERROR":
            return 0;

          case "FORMERR":
            return 1;

          case "SERVFAIL":
            return 2;

          case "NXDOMAIN":
            return 3;

          case "NOTIMP":
            return 4;

          case "REFUSED":
            return 5;

          case "YXDOMAIN":
            return 6;

          case "YXRRSET":
            return 7;

          case "NXRRSET":
            return 8;

          case "NOTAUTH":
            return 9;

          case "NOTZONE":
            return 10;

          case "RCODE_11":
            return 11;

          case "RCODE_12":
            return 12;

          case "RCODE_13":
            return 13;

          case "RCODE_14":
            return 14;

          case "RCODE_15":
            return 15;
        }
        return 0;
    };
}, function(module, exports) {
    exports.toString = function(opcode) {
        switch (opcode) {
          case 0:
            return "QUERY";

          case 1:
            return "IQUERY";

          case 2:
            return "STATUS";

          case 3:
            return "OPCODE_3";

          case 4:
            return "NOTIFY";

          case 5:
            return "UPDATE";

          case 6:
            return "OPCODE_6";

          case 7:
            return "OPCODE_7";

          case 8:
            return "OPCODE_8";

          case 9:
            return "OPCODE_9";

          case 10:
            return "OPCODE_10";

          case 11:
            return "OPCODE_11";

          case 12:
            return "OPCODE_12";

          case 13:
            return "OPCODE_13";

          case 14:
            return "OPCODE_14";

          case 15:
            return "OPCODE_15";
        }
        return "OPCODE_" + opcode;
    }, exports.toOpcode = function(code) {
        switch (code.toUpperCase()) {
          case "QUERY":
            return 0;

          case "IQUERY":
            return 1;

          case "STATUS":
            return 2;

          case "OPCODE_3":
            return 3;

          case "NOTIFY":
            return 4;

          case "UPDATE":
            return 5;

          case "OPCODE_6":
            return 6;

          case "OPCODE_7":
            return 7;

          case "OPCODE_8":
            return 8;

          case "OPCODE_9":
            return 9;

          case "OPCODE_10":
            return 10;

          case "OPCODE_11":
            return 11;

          case "OPCODE_12":
            return 12;

          case "OPCODE_13":
            return 13;

          case "OPCODE_14":
            return 14;

          case "OPCODE_15":
            return 15;
        }
        return 0;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var nextTick = function(fn, a, b) {
        process.nextTick((function() {
            fn(a, b);
        }));
    };
    function isError(err) {
        return "[object Error]" === Object.prototype.toString.call(err);
    }
    function noop() {}
    function apply(callback, args) {
        callback.apply(null, args);
    }
    process.nextTick((function(val) {
        42 === val && (nextTick = process.nextTick);
    }), 42), module.exports = function(fn) {
        var state = function run(callback) {
            var stack = [ callback ];
            state = function(callback) {
                stack.push(callback);
            }, fn((function(err) {
                var args = arguments;
                for (state = isError(err) ? run : finished; stack.length; ) finished(stack.shift());
                function finished(callback) {
                    nextTick(apply, callback, args);
                }
            }));
        };
        return function(callback) {
            state(callback || noop);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var url = __webpack_require__(7), EventEmitter = __webpack_require__(5), parseXML = __webpack_require__(219).promisify(__webpack_require__(172).parseString), fetch = __webpack_require__(33), SSDP = __webpack_require__(936).Client;
    function SSDPDiscovery() {
        EventEmitter.call(this), this.SSDPServices = {
            "urn:dial-multiscreen-org:device:dial:1": "chromecast",
            "urn:schemas-upnp-org:device:MediaRenderer:1": "tv"
        }, this.ssdp = new SSDP, this.ssdp.on("response", this.handleResponse.bind(this)), 
        this.ssdp.on("error", (function(err) {
            console.log("SSDP error:", err);
        }));
    }
    __webpack_require__(0).inherits(SSDPDiscovery, EventEmitter), SSDPDiscovery.prototype.search = function() {
        for (var service in this.SSDPServices) this.ssdp.browse(service);
    }, SSDPDiscovery.prototype.normalizeObject = function(location, ssdpData) {
        try {
            if (!this.SSDPServices[ssdpData.root.device[0].deviceType[0]]) return;
            var device = {
                facility: "SSDP",
                id: ssdpData.root.device[0].UDN[0].slice(5),
                name: ssdpData.root.device[0].friendlyName[0],
                host: url.parse(location).hostname,
                location: location,
                type: this.SSDPServices[ssdpData.root.device[0].deviceType[0]],
                icon: this.SSDPServices[ssdpData.root.device[0].deviceType[0]],
                playerUIRoles: [ "playpause", "seek", "dub", "subtitles", "volume" ],
                usePlayerUI: !0,
                onlyHtml5Formats: !1
            };
            this.emit("device", device);
        } catch (e) {
            console.log("SSDP Parse error", e.toString(), ssdpData.root.device);
        }
    }, SSDPDiscovery.prototype.handleResponse = function(response) {
        var location = response.headers.LOCATION;
        location && fetch(location).then((function(res) {
            return res.text();
        })).then(parseXML).then(this.normalizeObject.bind(this, location)).catch((function(err) {
            console.log("SSDP Location error:", err);
        }));
    }, module.exports = SSDPDiscovery;
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function() {
        var makeSelfResolutionError = function() {
            return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
        }, reflectHandler = function() {
            return new Promise.PromiseInspection(this._target());
        }, apiRejection = function(msg) {
            return Promise.reject(new TypeError(msg));
        };
        function Proxyable() {}
        var getDomain, UNDEFINED_BINDING = {}, util = __webpack_require__(16);
        getDomain = util.isNode ? function() {
            var ret = process.domain;
            return void 0 === ret && (ret = null), ret;
        } : function() {
            return null;
        }, util.notEnumerableProp(Promise, "_getDomain", getDomain);
        var es5 = __webpack_require__(66), Async = __webpack_require__(907), async = new Async;
        es5.defineProperty(Promise, "_async", {
            value: async
        });
        var errors = __webpack_require__(55), TypeError = Promise.TypeError = errors.TypeError;
        Promise.RangeError = errors.RangeError;
        var CancellationError = Promise.CancellationError = errors.CancellationError;
        Promise.TimeoutError = errors.TimeoutError, Promise.OperationalError = errors.OperationalError, 
        Promise.RejectionError = errors.OperationalError, Promise.AggregateError = errors.AggregateError;
        var INTERNAL = function() {}, APPLY = {}, NEXT_FILTER = {}, tryConvertToPromise = __webpack_require__(910)(Promise, INTERNAL), PromiseArray = __webpack_require__(911)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable), Context = __webpack_require__(912)(Promise), createContext = Context.create, debug = __webpack_require__(913)(Promise, Context), PassThroughHandlerContext = (debug.CapturedTrace, 
        __webpack_require__(914)(Promise, tryConvertToPromise, NEXT_FILTER)), catchFilter = __webpack_require__(441)(NEXT_FILTER), nodebackForPromise = __webpack_require__(442), errorObj = util.errorObj, tryCatch = util.tryCatch;
        function Promise(executor) {
            executor !== INTERNAL && (function(self, executor) {
                if (null == self || self.constructor !== Promise) throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
                if ("function" != typeof executor) throw new TypeError("expecting a function but got " + util.classString(executor));
            })(this, executor), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, 
            this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(executor), 
            this._promiseCreated(), this._fireEvent("promiseCreated", this);
        }
        function deferResolve(v) {
            this.promise._resolveCallback(v);
        }
        function deferReject(v) {
            this.promise._rejectCallback(v, !1);
        }
        function fillTypes(value) {
            var p = new Promise(INTERNAL);
            p._fulfillmentHandler0 = value, p._rejectionHandler0 = value, p._promise0 = value, 
            p._receiver0 = value;
        }
        return Promise.prototype.toString = function() {
            return "[object Promise]";
        }, Promise.prototype.caught = Promise.prototype.catch = function(fn) {
            var len = arguments.length;
            if (len > 1) {
                var i, catchInstances = new Array(len - 1), j = 0;
                for (i = 0; i < len - 1; ++i) {
                    var item = arguments[i];
                    if (!util.isObject(item)) return apiRejection("Catch statement predicate: expecting an object but got " + util.classString(item));
                    catchInstances[j++] = item;
                }
                if (catchInstances.length = j, "function" != typeof (fn = arguments[i])) throw new TypeError("The last argument to .catch() must be a function, got " + util.toString(fn));
                return this.then(void 0, catchFilter(catchInstances, fn, this));
            }
            return this.then(void 0, fn);
        }, Promise.prototype.reflect = function() {
            return this._then(reflectHandler, reflectHandler, void 0, this, void 0);
        }, Promise.prototype.then = function(didFulfill, didReject) {
            if (debug.warnings() && arguments.length > 0 && "function" != typeof didFulfill && "function" != typeof didReject) {
                var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
                arguments.length > 1 && (msg += ", " + util.classString(didReject)), this._warn(msg);
            }
            return this._then(didFulfill, didReject, void 0, void 0, void 0);
        }, Promise.prototype.done = function(didFulfill, didReject) {
            this._then(didFulfill, didReject, void 0, void 0, void 0)._setIsFinal();
        }, Promise.prototype.spread = function(fn) {
            return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : this.all()._then(fn, void 0, void 0, APPLY, void 0);
        }, Promise.prototype.toJSON = function() {
            var ret = {
                isFulfilled: !1,
                isRejected: !1,
                fulfillmentValue: void 0,
                rejectionReason: void 0
            };
            return this.isFulfilled() ? (ret.fulfillmentValue = this.value(), ret.isFulfilled = !0) : this.isRejected() && (ret.rejectionReason = this.reason(), 
            ret.isRejected = !0), ret;
        }, Promise.prototype.all = function() {
            return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), 
            new PromiseArray(this).promise();
        }, Promise.prototype.error = function(fn) {
            return this.caught(util.originatesFromRejection, fn);
        }, Promise.getNewLibraryCopy = module.exports, Promise.is = function(val) {
            return val instanceof Promise;
        }, Promise.fromNode = Promise.fromCallback = function(fn) {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            var multiArgs = arguments.length > 1 && !!Object(arguments[1]).multiArgs, result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
            return result === errorObj && ret._rejectCallback(result.e, !0), ret._isFateSealed() || ret._setAsyncGuaranteed(), 
            ret;
        }, Promise.all = function(promises) {
            return new PromiseArray(promises).promise();
        }, Promise.cast = function(obj) {
            var ret = tryConvertToPromise(obj);
            return ret instanceof Promise || ((ret = new Promise(INTERNAL))._captureStackTrace(), 
            ret._setFulfilled(), ret._rejectionHandler0 = obj), ret;
        }, Promise.resolve = Promise.fulfilled = Promise.cast, Promise.reject = Promise.rejected = function(reason) {
            var ret = new Promise(INTERNAL);
            return ret._captureStackTrace(), ret._rejectCallback(reason, !0), ret;
        }, Promise.setScheduler = function(fn) {
            if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
            return async.setScheduler(fn);
        }, Promise.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
            var haveInternalData = void 0 !== internalData, promise = haveInternalData ? internalData : new Promise(INTERNAL), target = this._target(), bitField = target._bitField;
            haveInternalData || (promise._propagateFrom(this, 3), promise._captureStackTrace(), 
            void 0 === receiver && 0 != (2097152 & this._bitField) && (receiver = 0 != (50397184 & bitField) ? this._boundValue() : target === this ? void 0 : this._boundTo), 
            this._fireEvent("promiseChained", this, promise));
            var domain = getDomain();
            if (0 != (50397184 & bitField)) {
                var handler, value, settler = target._settlePromiseCtx;
                0 != (33554432 & bitField) ? (value = target._rejectionHandler0, handler = didFulfill) : 0 != (16777216 & bitField) ? (value = target._fulfillmentHandler0, 
                handler = didReject, target._unsetRejectionIsUnhandled()) : (settler = target._settlePromiseLateCancellationObserver, 
                value = new CancellationError("late cancellation observer"), target._attachExtraTrace(value), 
                handler = didReject), async.invoke(settler, target, {
                    handler: null === domain ? handler : "function" == typeof handler && util.domainBind(domain, handler),
                    promise: promise,
                    receiver: receiver,
                    value: value
                });
            } else target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
            return promise;
        }, Promise.prototype._length = function() {
            return 65535 & this._bitField;
        }, Promise.prototype._isFateSealed = function() {
            return 0 != (117506048 & this._bitField);
        }, Promise.prototype._isFollowing = function() {
            return 67108864 == (67108864 & this._bitField);
        }, Promise.prototype._setLength = function(len) {
            this._bitField = -65536 & this._bitField | 65535 & len;
        }, Promise.prototype._setFulfilled = function() {
            this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
        }, Promise.prototype._setRejected = function() {
            this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
        }, Promise.prototype._setFollowing = function() {
            this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
        }, Promise.prototype._setIsFinal = function() {
            this._bitField = 4194304 | this._bitField;
        }, Promise.prototype._isFinal = function() {
            return (4194304 & this._bitField) > 0;
        }, Promise.prototype._unsetCancelled = function() {
            this._bitField = -65537 & this._bitField;
        }, Promise.prototype._setCancelled = function() {
            this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
        }, Promise.prototype._setWillBeCancelled = function() {
            this._bitField = 8388608 | this._bitField;
        }, Promise.prototype._setAsyncGuaranteed = function() {
            async.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField);
        }, Promise.prototype._receiverAt = function(index) {
            var ret = 0 === index ? this._receiver0 : this[4 * index - 4 + 3];
            if (ret !== UNDEFINED_BINDING) return void 0 === ret && this._isBound() ? this._boundValue() : ret;
        }, Promise.prototype._promiseAt = function(index) {
            return this[4 * index - 4 + 2];
        }, Promise.prototype._fulfillmentHandlerAt = function(index) {
            return this[4 * index - 4 + 0];
        }, Promise.prototype._rejectionHandlerAt = function(index) {
            return this[4 * index - 4 + 1];
        }, Promise.prototype._boundValue = function() {}, Promise.prototype._migrateCallback0 = function(follower) {
            follower._bitField;
            var fulfill = follower._fulfillmentHandler0, reject = follower._rejectionHandler0, promise = follower._promise0, receiver = follower._receiverAt(0);
            void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
        }, Promise.prototype._migrateCallbackAt = function(follower, index) {
            var fulfill = follower._fulfillmentHandlerAt(index), reject = follower._rejectionHandlerAt(index), promise = follower._promiseAt(index), receiver = follower._receiverAt(index);
            void 0 === receiver && (receiver = UNDEFINED_BINDING), this._addCallbacks(fulfill, reject, promise, receiver, null);
        }, Promise.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
            var index = this._length();
            if (index >= 65531 && (index = 0, this._setLength(0)), 0 === index) this._promise0 = promise, 
            this._receiver0 = receiver, "function" == typeof fulfill && (this._fulfillmentHandler0 = null === domain ? fulfill : util.domainBind(domain, fulfill)), 
            "function" == typeof reject && (this._rejectionHandler0 = null === domain ? reject : util.domainBind(domain, reject)); else {
                var base = 4 * index - 4;
                this[base + 2] = promise, this[base + 3] = receiver, "function" == typeof fulfill && (this[base + 0] = null === domain ? fulfill : util.domainBind(domain, fulfill)), 
                "function" == typeof reject && (this[base + 1] = null === domain ? reject : util.domainBind(domain, reject));
            }
            return this._setLength(index + 1), index;
        }, Promise.prototype._proxy = function(proxyable, arg) {
            this._addCallbacks(void 0, void 0, arg, proxyable, null);
        }, Promise.prototype._resolveCallback = function(value, shouldBind) {
            if (0 == (117506048 & this._bitField)) {
                if (value === this) return this._rejectCallback(makeSelfResolutionError(), !1);
                var maybePromise = tryConvertToPromise(value, this);
                if (!(maybePromise instanceof Promise)) return this._fulfill(value);
                shouldBind && this._propagateFrom(maybePromise, 2);
                var promise = maybePromise._target();
                if (promise !== this) {
                    var bitField = promise._bitField;
                    if (0 == (50397184 & bitField)) {
                        var len = this._length();
                        len > 0 && promise._migrateCallback0(this);
                        for (var i = 1; i < len; ++i) promise._migrateCallbackAt(this, i);
                        this._setFollowing(), this._setLength(0), this._setFollowee(promise);
                    } else if (0 != (33554432 & bitField)) this._fulfill(promise._value()); else if (0 != (16777216 & bitField)) this._reject(promise._reason()); else {
                        var reason = new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason), this._reject(reason);
                    }
                } else this._reject(makeSelfResolutionError());
            }
        }, Promise.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
            var trace = util.ensureErrorObject(reason), hasStack = trace === reason;
            if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
                var message = "a promise was rejected with a non-error: " + util.classString(reason);
                this._warn(message, !0);
            }
            this._attachExtraTrace(trace, !!synchronous && hasStack), this._reject(reason);
        }, Promise.prototype._resolveFromExecutor = function(executor) {
            if (executor !== INTERNAL) {
                var promise = this;
                this._captureStackTrace(), this._pushContext();
                var synchronous = !0, r = this._execute(executor, (function(value) {
                    promise._resolveCallback(value);
                }), (function(reason) {
                    promise._rejectCallback(reason, synchronous);
                }));
                synchronous = !1, this._popContext(), void 0 !== r && promise._rejectCallback(r, !0);
            }
        }, Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
            var bitField = promise._bitField;
            if (0 == (65536 & bitField)) {
                var x;
                promise._pushContext(), receiver === APPLY ? value && "number" == typeof value.length ? x = tryCatch(handler).apply(this._boundValue(), value) : (x = errorObj).e = new TypeError("cannot .spread() a non-array: " + util.classString(value)) : x = tryCatch(handler).call(receiver, value);
                var promiseCreated = promise._popContext();
                0 == (65536 & (bitField = promise._bitField)) && (x === NEXT_FILTER ? promise._reject(value) : x === errorObj ? promise._rejectCallback(x.e, !1) : (debug.checkForgottenReturns(x, promiseCreated, "", promise, this), 
                promise._resolveCallback(x)));
            }
        }, Promise.prototype._target = function() {
            for (var ret = this; ret._isFollowing(); ) ret = ret._followee();
            return ret;
        }, Promise.prototype._followee = function() {
            return this._rejectionHandler0;
        }, Promise.prototype._setFollowee = function(promise) {
            this._rejectionHandler0 = promise;
        }, Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
            var isPromise = promise instanceof Promise, bitField = this._bitField, asyncGuaranteed = 0 != (134217728 & bitField);
            0 != (65536 & bitField) ? (isPromise && promise._invokeInternalOnCancel(), receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler() ? (receiver.cancelPromise = promise, 
            tryCatch(handler).call(receiver, value) === errorObj && promise._reject(errorObj.e)) : handler === reflectHandler ? promise._fulfill(reflectHandler.call(receiver)) : receiver instanceof Proxyable ? receiver._promiseCancelled(promise) : isPromise || promise instanceof PromiseArray ? promise._cancel() : receiver.cancel()) : "function" == typeof handler ? isPromise ? (asyncGuaranteed && promise._setAsyncGuaranteed(), 
            this._settlePromiseFromHandler(handler, receiver, value, promise)) : handler.call(receiver, value, promise) : receiver instanceof Proxyable ? receiver._isResolved() || (0 != (33554432 & bitField) ? receiver._promiseFulfilled(value, promise) : receiver._promiseRejected(value, promise)) : isPromise && (asyncGuaranteed && promise._setAsyncGuaranteed(), 
            0 != (33554432 & bitField) ? promise._fulfill(value) : promise._reject(value));
        }, Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
            var handler = ctx.handler, promise = ctx.promise, receiver = ctx.receiver, value = ctx.value;
            "function" == typeof handler ? promise instanceof Promise ? this._settlePromiseFromHandler(handler, receiver, value, promise) : handler.call(receiver, value, promise) : promise instanceof Promise && promise._reject(value);
        }, Promise.prototype._settlePromiseCtx = function(ctx) {
            this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
        }, Promise.prototype._settlePromise0 = function(handler, value, bitField) {
            var promise = this._promise0, receiver = this._receiverAt(0);
            this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(promise, handler, receiver, value);
        }, Promise.prototype._clearCallbackDataAtIndex = function(index) {
            var base = 4 * index - 4;
            this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
        }, Promise.prototype._fulfill = function(value) {
            var bitField = this._bitField;
            if (!((117506048 & bitField) >>> 16)) {
                if (value === this) {
                    var err = makeSelfResolutionError();
                    return this._attachExtraTrace(err), this._reject(err);
                }
                this._setFulfilled(), this._rejectionHandler0 = value, (65535 & bitField) > 0 && (0 != (134217728 & bitField) ? this._settlePromises() : async.settlePromises(this), 
                this._dereferenceTrace());
            }
        }, Promise.prototype._reject = function(reason) {
            var bitField = this._bitField;
            if (!((117506048 & bitField) >>> 16)) {
                if (this._setRejected(), this._fulfillmentHandler0 = reason, this._isFinal()) return async.fatalError(reason, util.isNode);
                (65535 & bitField) > 0 ? async.settlePromises(this) : this._ensurePossibleRejectionHandled();
            }
        }, Promise.prototype._fulfillPromises = function(len, value) {
            for (var i = 1; i < len; i++) {
                var handler = this._fulfillmentHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
                this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, value);
            }
        }, Promise.prototype._rejectPromises = function(len, reason) {
            for (var i = 1; i < len; i++) {
                var handler = this._rejectionHandlerAt(i), promise = this._promiseAt(i), receiver = this._receiverAt(i);
                this._clearCallbackDataAtIndex(i), this._settlePromise(promise, handler, receiver, reason);
            }
        }, Promise.prototype._settlePromises = function() {
            var bitField = this._bitField, len = 65535 & bitField;
            if (len > 0) {
                if (0 != (16842752 & bitField)) {
                    var reason = this._fulfillmentHandler0;
                    this._settlePromise0(this._rejectionHandler0, reason, bitField), this._rejectPromises(len, reason);
                } else {
                    var value = this._rejectionHandler0;
                    this._settlePromise0(this._fulfillmentHandler0, value, bitField), this._fulfillPromises(len, value);
                }
                this._setLength(0);
            }
            this._clearCancellationData();
        }, Promise.prototype._settledValue = function() {
            var bitField = this._bitField;
            return 0 != (33554432 & bitField) ? this._rejectionHandler0 : 0 != (16777216 & bitField) ? this._fulfillmentHandler0 : void 0;
        }, "undefined" != typeof Symbol && Symbol.toStringTag && es5.defineProperty(Promise.prototype, Symbol.toStringTag, {
            get: function() {
                return "Object";
            }
        }), Promise.defer = Promise.pending = function() {
            return debug.deprecated("Promise.defer", "new Promise"), {
                promise: new Promise(INTERNAL),
                resolve: deferResolve,
                reject: deferReject
            };
        }, util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError), 
        __webpack_require__(915)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug), 
        __webpack_require__(916)(Promise, INTERNAL, tryConvertToPromise, debug), __webpack_require__(917)(Promise, PromiseArray, apiRejection, debug), 
        __webpack_require__(918)(Promise), __webpack_require__(919)(Promise), __webpack_require__(920)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain), 
        Promise.Promise = Promise, Promise.version = "3.5.5", __webpack_require__(921)(Promise), 
        __webpack_require__(922)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug), 
        __webpack_require__(923)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
        __webpack_require__(924)(Promise), __webpack_require__(925)(Promise, INTERNAL), 
        __webpack_require__(926)(Promise, PromiseArray, tryConvertToPromise, apiRejection), 
        __webpack_require__(927)(Promise, INTERNAL, tryConvertToPromise, apiRejection), 
        __webpack_require__(928)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug), 
        __webpack_require__(929)(Promise, PromiseArray, debug), __webpack_require__(930)(Promise, PromiseArray, apiRejection), 
        __webpack_require__(931)(Promise, INTERNAL, debug), __webpack_require__(932)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug), 
        __webpack_require__(933)(Promise), __webpack_require__(934)(Promise, INTERNAL), 
        __webpack_require__(935)(Promise, INTERNAL), util.toFastProperties(Promise), util.toFastProperties(Promise.prototype), 
        fillTypes({
            a: 1
        }), fillTypes({
            b: 2
        }), fillTypes({
            c: 3
        }), fillTypes(1), fillTypes((function() {})), fillTypes(void 0), fillTypes(!1), 
        fillTypes(new Promise(INTERNAL)), debug.setBounds(Async.firstLineError, util.lastLineError), 
        Promise;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var firstLineError;
    try {
        throw new Error;
    } catch (e) {
        firstLineError = e;
    }
    var schedule = __webpack_require__(908), Queue = __webpack_require__(909), util = __webpack_require__(16);
    function Async() {
        this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new Queue(16), 
        this._normalQueue = new Queue(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
        var self = this;
        this.drainQueues = function() {
            self._drainQueues();
        }, this._schedule = schedule;
    }
    function AsyncInvokeLater(fn, receiver, arg) {
        this._lateQueue.push(fn, receiver, arg), this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
        this._normalQueue.push(fn, receiver, arg), this._queueTick();
    }
    function AsyncSettlePromises(promise) {
        this._normalQueue._pushOne(promise), this._queueTick();
    }
    function _drainQueue(queue) {
        for (;queue.length() > 0; ) _drainQueueStep(queue);
    }
    function _drainQueueStep(queue) {
        var fn = queue.shift();
        if ("function" != typeof fn) fn._settlePromises(); else {
            var receiver = queue.shift(), arg = queue.shift();
            fn.call(receiver, arg);
        }
    }
    Async.prototype.setScheduler = function(fn) {
        var prev = this._schedule;
        return this._schedule = fn, this._customScheduler = !0, prev;
    }, Async.prototype.hasCustomScheduler = function() {
        return this._customScheduler;
    }, Async.prototype.enableTrampoline = function() {
        this._trampolineEnabled = !0;
    }, Async.prototype.disableTrampolineIfNecessary = function() {
        util.hasDevTools && (this._trampolineEnabled = !1);
    }, Async.prototype.haveItemsQueued = function() {
        return this._isTickUsed || this._haveDrainedQueues;
    }, Async.prototype.fatalError = function(e, isNode) {
        isNode ? (process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n"), 
        process.exit(2)) : this.throwLater(e);
    }, Async.prototype.throwLater = function(fn, arg) {
        if (1 === arguments.length && (arg = fn, fn = function() {
            throw arg;
        }), "undefined" != typeof setTimeout) setTimeout((function() {
            fn(arg);
        }), 0); else try {
            this._schedule((function() {
                fn(arg);
            }));
        } catch (e) {
            throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    }, util.hasDevTools ? (Async.prototype.invokeLater = function(fn, receiver, arg) {
        this._trampolineEnabled ? AsyncInvokeLater.call(this, fn, receiver, arg) : this._schedule((function() {
            setTimeout((function() {
                fn.call(receiver, arg);
            }), 100);
        }));
    }, Async.prototype.invoke = function(fn, receiver, arg) {
        this._trampolineEnabled ? AsyncInvoke.call(this, fn, receiver, arg) : this._schedule((function() {
            fn.call(receiver, arg);
        }));
    }, Async.prototype.settlePromises = function(promise) {
        this._trampolineEnabled ? AsyncSettlePromises.call(this, promise) : this._schedule((function() {
            promise._settlePromises();
        }));
    }) : (Async.prototype.invokeLater = AsyncInvokeLater, Async.prototype.invoke = AsyncInvoke, 
    Async.prototype.settlePromises = AsyncSettlePromises), Async.prototype._drainQueues = function() {
        _drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, _drainQueue(this._lateQueue);
    }, Async.prototype._queueTick = function() {
        this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
    }, Async.prototype._reset = function() {
        this._isTickUsed = !1;
    }, module.exports = Async, module.exports.firstLineError = firstLineError;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var schedule, div, opts, toggleScheduled, div2, util = __webpack_require__(16), NativePromise = util.getNativePromise();
    if (util.isNode && "undefined" == typeof MutationObserver) {
        var GlobalSetImmediate = global.setImmediate, ProcessNextTick = process.nextTick;
        schedule = util.isRecentNode ? function(fn) {
            GlobalSetImmediate.call(global, fn);
        } : function(fn) {
            ProcessNextTick.call(process, fn);
        };
    } else if ("function" == typeof NativePromise && "function" == typeof NativePromise.resolve) {
        var nativePromise = NativePromise.resolve();
        schedule = function(fn) {
            nativePromise.then(fn);
        };
    } else schedule = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) || !("classList" in document.documentElement) ? "undefined" != typeof setImmediate ? function(fn) {
        setImmediate(fn);
    } : "undefined" != typeof setTimeout ? function(fn) {
        setTimeout(fn, 0);
    } : function() {
        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    } : (div = document.createElement("div"), opts = {
        attributes: !0
    }, toggleScheduled = !1, div2 = document.createElement("div"), new MutationObserver((function() {
        div.classList.toggle("foo"), toggleScheduled = !1;
    })).observe(div2, opts), function(fn) {
        var o = new MutationObserver((function() {
            o.disconnect(), fn();
        }));
        o.observe(div, opts), toggleScheduled || (toggleScheduled = !0, div2.classList.toggle("foo"));
    });
    module.exports = schedule;
}, function(module, exports, __webpack_require__) {
    "use strict";
    function Queue(capacity) {
        this._capacity = capacity, this._length = 0, this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
        return this._capacity < size;
    }, Queue.prototype._pushOne = function(arg) {
        var length = this.length();
        this._checkCapacity(length + 1), this[this._front + length & this._capacity - 1] = arg, 
        this._length = length + 1;
    }, Queue.prototype.push = function(fn, receiver, arg) {
        var length = this.length() + 3;
        if (this._willBeOverCapacity(length)) return this._pushOne(fn), this._pushOne(receiver), 
        void this._pushOne(arg);
        var j = this._front + length - 3;
        this._checkCapacity(length);
        var wrapMask = this._capacity - 1;
        this[j + 0 & wrapMask] = fn, this[j + 1 & wrapMask] = receiver, this[j + 2 & wrapMask] = arg, 
        this._length = length;
    }, Queue.prototype.shift = function() {
        var front = this._front, ret = this[front];
        return this[front] = void 0, this._front = front + 1 & this._capacity - 1, this._length--, 
        ret;
    }, Queue.prototype.length = function() {
        return this._length;
    }, Queue.prototype._checkCapacity = function(size) {
        this._capacity < size && this._resizeTo(this._capacity << 1);
    }, Queue.prototype._resizeTo = function(capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity, (function(src, srcIndex, dst, dstIndex, len) {
            for (var j = 0; j < len; ++j) dst[j + dstIndex] = src[j + 0], src[j + 0] = void 0;
        })(this, 0, this, oldCapacity, this._front + this._length & oldCapacity - 1);
    }, module.exports = Queue;
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL) {
        var util = __webpack_require__(16), errorObj = util.errorObj, isObject = util.isObject, hasProp = {}.hasOwnProperty;
        return function(obj, context) {
            if (isObject(obj)) {
                if (obj instanceof Promise) return obj;
                var then = (function(obj) {
                    try {
                        return (function(obj) {
                            return obj.then;
                        })(obj);
                    } catch (e) {
                        return errorObj.e = e, errorObj;
                    }
                })(obj);
                if (then === errorObj) {
                    context && context._pushContext();
                    var ret = Promise.reject(then.e);
                    return context && context._popContext(), ret;
                }
                if ("function" == typeof then) return (function(obj) {
                    try {
                        return hasProp.call(obj, "_promise0");
                    } catch (e) {
                        return !1;
                    }
                })(obj) ? (ret = new Promise(INTERNAL), obj._then(ret._fulfill, ret._reject, void 0, ret, null), 
                ret) : (function(x, then, context) {
                    var promise = new Promise(INTERNAL), ret = promise;
                    context && context._pushContext(), promise._captureStackTrace(), context && context._popContext();
                    var result = util.tryCatch(then).call(x, (function(value) {
                        promise && (promise._resolveCallback(value), promise = null);
                    }), (function(reason) {
                        promise && (promise._rejectCallback(reason, false, !0), promise = null);
                    }));
                    return !1, promise && result === errorObj && (promise._rejectCallback(result.e, !0, !0), 
                    promise = null), ret;
                })(obj, then, context);
            }
            return obj;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
        var util = __webpack_require__(16);
        function PromiseArray(values) {
            var promise = this._promise = new Promise(INTERNAL);
            values instanceof Promise && promise._propagateFrom(values, 3), promise._setOnCancel(this), 
            this._values = values, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
        }
        return util.isArray, util.inherits(PromiseArray, Proxyable), PromiseArray.prototype.length = function() {
            return this._length;
        }, PromiseArray.prototype.promise = function() {
            return this._promise;
        }, PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
            var values = tryConvertToPromise(this._values, this._promise);
            if (values instanceof Promise) {
                var bitField = (values = values._target())._bitField;
                if (this._values = values, 0 == (50397184 & bitField)) return this._promise._setAsyncGuaranteed(), 
                values._then(init, this._reject, void 0, this, resolveValueIfEmpty);
                if (0 == (33554432 & bitField)) return 0 != (16777216 & bitField) ? this._reject(values._reason()) : this._cancel();
                values = values._value();
            }
            if (null !== (values = util.asArray(values))) 0 !== values.length ? this._iterate(values) : -5 === resolveValueIfEmpty ? this._resolveEmptyArray() : this._resolve((function(val) {
                switch (val) {
                  case -2:
                    return [];

                  case -3:
                    return {};

                  case -6:
                    return new Map;
                }
            })(resolveValueIfEmpty)); else {
                var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
                this._promise._rejectCallback(err, !1);
            }
        }, PromiseArray.prototype._iterate = function(values) {
            var len = this.getActualLength(values.length);
            this._length = len, this._values = this.shouldCopyValues() ? new Array(len) : this._values;
            for (var result = this._promise, isResolved = !1, bitField = null, i = 0; i < len; ++i) {
                var maybePromise = tryConvertToPromise(values[i], result);
                bitField = maybePromise instanceof Promise ? (maybePromise = maybePromise._target())._bitField : null, 
                isResolved ? null !== bitField && maybePromise.suppressUnhandledRejections() : null !== bitField ? 0 == (50397184 & bitField) ? (maybePromise._proxy(this, i), 
                this._values[i] = maybePromise) : isResolved = 0 != (33554432 & bitField) ? this._promiseFulfilled(maybePromise._value(), i) : 0 != (16777216 & bitField) ? this._promiseRejected(maybePromise._reason(), i) : this._promiseCancelled(i) : isResolved = this._promiseFulfilled(maybePromise, i);
            }
            isResolved || result._setAsyncGuaranteed();
        }, PromiseArray.prototype._isResolved = function() {
            return null === this._values;
        }, PromiseArray.prototype._resolve = function(value) {
            this._values = null, this._promise._fulfill(value);
        }, PromiseArray.prototype._cancel = function() {
            !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
        }, PromiseArray.prototype._reject = function(reason) {
            this._values = null, this._promise._rejectCallback(reason, !1);
        }, PromiseArray.prototype._promiseFulfilled = function(value, index) {
            return this._values[index] = value, ++this._totalResolved >= this._length && (this._resolve(this._values), 
            !0);
        }, PromiseArray.prototype._promiseCancelled = function() {
            return this._cancel(), !0;
        }, PromiseArray.prototype._promiseRejected = function(reason) {
            return this._totalResolved++, this._reject(reason), !0;
        }, PromiseArray.prototype._resultCancelled = function() {
            if (!this._isResolved()) {
                var values = this._values;
                if (this._cancel(), values instanceof Promise) values.cancel(); else for (var i = 0; i < values.length; ++i) values[i] instanceof Promise && values[i].cancel();
            }
        }, PromiseArray.prototype.shouldCopyValues = function() {
            return !0;
        }, PromiseArray.prototype.getActualLength = function(len) {
            return len;
        }, PromiseArray;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise) {
        var longStackTraces = !1, contextStack = [];
        function Context() {
            this._trace = new Context.CapturedTrace(peekContext());
        }
        function peekContext() {
            var lastIndex = contextStack.length - 1;
            if (lastIndex >= 0) return contextStack[lastIndex];
        }
        return Promise.prototype._promiseCreated = function() {}, Promise.prototype._pushContext = function() {}, 
        Promise.prototype._popContext = function() {
            return null;
        }, Promise._peekContext = Promise.prototype._peekContext = function() {}, Context.prototype._pushContext = function() {
            void 0 !== this._trace && (this._trace._promiseCreated = null, contextStack.push(this._trace));
        }, Context.prototype._popContext = function() {
            if (void 0 !== this._trace) {
                var trace = contextStack.pop(), ret = trace._promiseCreated;
                return trace._promiseCreated = null, ret;
            }
            return null;
        }, Context.CapturedTrace = null, Context.create = function() {
            if (longStackTraces) return new Context;
        }, Context.deactivateLongStackTraces = function() {}, Context.activateLongStackTraces = function() {
            var Promise_pushContext = Promise.prototype._pushContext, Promise_popContext = Promise.prototype._popContext, Promise_PeekContext = Promise._peekContext, Promise_peekContext = Promise.prototype._peekContext, Promise_promiseCreated = Promise.prototype._promiseCreated;
            Context.deactivateLongStackTraces = function() {
                Promise.prototype._pushContext = Promise_pushContext, Promise.prototype._popContext = Promise_popContext, 
                Promise._peekContext = Promise_PeekContext, Promise.prototype._peekContext = Promise_peekContext, 
                Promise.prototype._promiseCreated = Promise_promiseCreated, longStackTraces = !1;
            }, longStackTraces = !0, Promise.prototype._pushContext = Context.prototype._pushContext, 
            Promise.prototype._popContext = Context.prototype._popContext, Promise._peekContext = Promise.prototype._peekContext = peekContext, 
            Promise.prototype._promiseCreated = function() {
                var ctx = this._peekContext();
                ctx && null == ctx._promiseCreated && (ctx._promiseCreated = this);
            };
        }, Context;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, Context) {
        var unhandledRejectionHandled, possiblyUnhandledRejection, printWarning, getDomain = Promise._getDomain, async = Promise._async, Warning = __webpack_require__(55).Warning, util = __webpack_require__(16), es5 = __webpack_require__(66), canAttachTrace = util.canAttachTrace, bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/, parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, stackFramePattern = null, formatStack = null, indentStackFrames = !1, debugging = !(0 == util.env("BLUEBIRD_DEBUG") || !util.env("BLUEBIRD_DEBUG") && "development" !== util.env("NODE_ENV")), warnings = !(0 == util.env("BLUEBIRD_WARNINGS") || !debugging && !util.env("BLUEBIRD_WARNINGS")), longStackTraces = !(0 == util.env("BLUEBIRD_LONG_STACK_TRACES") || !debugging && !util.env("BLUEBIRD_LONG_STACK_TRACES")), wForgottenReturn = 0 != util.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
        Promise.prototype.suppressUnhandledRejections = function() {
            var target = this._target();
            target._bitField = -1048577 & target._bitField | 524288;
        }, Promise.prototype._ensurePossibleRejectionHandled = function() {
            if (0 == (524288 & this._bitField)) {
                this._setRejectionIsUnhandled();
                var self = this;
                setTimeout((function() {
                    self._notifyUnhandledRejection();
                }), 1);
            }
        }, Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
            fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, void 0, this);
        }, Promise.prototype._setReturnedNonUndefined = function() {
            this._bitField = 268435456 | this._bitField;
        }, Promise.prototype._returnedNonUndefined = function() {
            return 0 != (268435456 & this._bitField);
        }, Promise.prototype._notifyUnhandledRejection = function() {
            if (this._isRejectionUnhandled()) {
                var reason = this._settledValue();
                this._setUnhandledRejectionIsNotified(), fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
            }
        }, Promise.prototype._setUnhandledRejectionIsNotified = function() {
            this._bitField = 262144 | this._bitField;
        }, Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
            this._bitField = -262145 & this._bitField;
        }, Promise.prototype._isUnhandledRejectionNotified = function() {
            return (262144 & this._bitField) > 0;
        }, Promise.prototype._setRejectionIsUnhandled = function() {
            this._bitField = 1048576 | this._bitField;
        }, Promise.prototype._unsetRejectionIsUnhandled = function() {
            this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), 
            this._notifyUnhandledRejectionIsHandled());
        }, Promise.prototype._isRejectionUnhandled = function() {
            return (1048576 & this._bitField) > 0;
        }, Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
            return warn(message, shouldUseOwnTrace, promise || this);
        }, Promise.onPossiblyUnhandledRejection = function(fn) {
            var domain = getDomain();
            possiblyUnhandledRejection = "function" == typeof fn ? null === domain ? fn : util.domainBind(domain, fn) : void 0;
        }, Promise.onUnhandledRejectionHandled = function(fn) {
            var domain = getDomain();
            unhandledRejectionHandled = "function" == typeof fn ? null === domain ? fn : util.domainBind(domain, fn) : void 0;
        };
        var disableLongStackTraces = function() {};
        Promise.longStackTraces = function() {
            if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            if (!config.longStackTraces && longStackTracesIsSupported()) {
                var Promise_captureStackTrace = Promise.prototype._captureStackTrace, Promise_attachExtraTrace = Promise.prototype._attachExtraTrace, Promise_dereferenceTrace = Promise.prototype._dereferenceTrace;
                config.longStackTraces = !0, disableLongStackTraces = function() {
                    if (async.haveItemsQueued() && !config.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                    Promise.prototype._captureStackTrace = Promise_captureStackTrace, Promise.prototype._attachExtraTrace = Promise_attachExtraTrace, 
                    Promise.prototype._dereferenceTrace = Promise_dereferenceTrace, Context.deactivateLongStackTraces(), 
                    async.enableTrampoline(), config.longStackTraces = !1;
                }, Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace, Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace, 
                Promise.prototype._dereferenceTrace = longStackTracesDereferenceTrace, Context.activateLongStackTraces(), 
                async.disableTrampolineIfNecessary();
            }
        }, Promise.hasLongStackTraces = function() {
            return config.longStackTraces && longStackTracesIsSupported();
        };
        var fireDomEvent = (function() {
            try {
                if ("function" == typeof CustomEvent) {
                    var event = new CustomEvent("CustomEvent");
                    return util.global.dispatchEvent(event), function(name, event) {
                        var eventData = {
                            detail: event,
                            cancelable: !0
                        };
                        es5.defineProperty(eventData, "promise", {
                            value: event.promise
                        }), es5.defineProperty(eventData, "reason", {
                            value: event.reason
                        });
                        var domEvent = new CustomEvent(name.toLowerCase(), eventData);
                        return !util.global.dispatchEvent(domEvent);
                    };
                }
                return "function" == typeof Event ? (event = new Event("CustomEvent"), util.global.dispatchEvent(event), 
                function(name, event) {
                    var domEvent = new Event(name.toLowerCase(), {
                        cancelable: !0
                    });
                    return domEvent.detail = event, es5.defineProperty(domEvent, "promise", {
                        value: event.promise
                    }), es5.defineProperty(domEvent, "reason", {
                        value: event.reason
                    }), !util.global.dispatchEvent(domEvent);
                }) : ((event = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), 
                util.global.dispatchEvent(event), function(name, event) {
                    var domEvent = document.createEvent("CustomEvent");
                    return domEvent.initCustomEvent(name.toLowerCase(), !1, !0, event), !util.global.dispatchEvent(domEvent);
                });
            } catch (e) {}
            return function() {
                return !1;
            };
        })(), fireGlobalEvent = util.isNode ? function() {
            return process.emit.apply(process, arguments);
        } : util.global ? function(name) {
            var methodName = "on" + name.toLowerCase(), method = util.global[methodName];
            return !!method && (method.apply(util.global, [].slice.call(arguments, 1)), !0);
        } : function() {
            return !1;
        };
        function generatePromiseLifecycleEventObject(name, promise) {
            return {
                promise: promise
            };
        }
        var eventToObjectGenerator = {
            promiseCreated: generatePromiseLifecycleEventObject,
            promiseFulfilled: generatePromiseLifecycleEventObject,
            promiseRejected: generatePromiseLifecycleEventObject,
            promiseResolved: generatePromiseLifecycleEventObject,
            promiseCancelled: generatePromiseLifecycleEventObject,
            promiseChained: function(name, promise, child) {
                return {
                    promise: promise,
                    child: child
                };
            },
            warning: function(name, warning) {
                return {
                    warning: warning
                };
            },
            unhandledRejection: function(name, reason, promise) {
                return {
                    reason: reason,
                    promise: promise
                };
            },
            rejectionHandled: generatePromiseLifecycleEventObject
        }, activeFireEvent = function(name) {
            var globalEventFired = !1;
            try {
                globalEventFired = fireGlobalEvent.apply(null, arguments);
            } catch (e) {
                async.throwLater(e), globalEventFired = !0;
            }
            var domEventFired = !1;
            try {
                domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
            } catch (e) {
                async.throwLater(e), domEventFired = !0;
            }
            return domEventFired || globalEventFired;
        };
        function defaultFireEvent() {
            return !1;
        }
        function cancellationExecute(executor, resolve, reject) {
            var promise = this;
            try {
                executor(resolve, reject, (function(onCancel) {
                    if ("function" != typeof onCancel) throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                    promise._attachCancellationCallback(onCancel);
                }));
            } catch (e) {
                return e;
            }
        }
        function cancellationAttachCancellationCallback(onCancel) {
            if (!this._isCancellable()) return this;
            var previousOnCancel = this._onCancel();
            void 0 !== previousOnCancel ? util.isArray(previousOnCancel) ? previousOnCancel.push(onCancel) : this._setOnCancel([ previousOnCancel, onCancel ]) : this._setOnCancel(onCancel);
        }
        function cancellationOnCancel() {
            return this._onCancelField;
        }
        function cancellationSetOnCancel(onCancel) {
            this._onCancelField = onCancel;
        }
        function cancellationClearCancellationData() {
            this._cancellationParent = void 0, this._onCancelField = void 0;
        }
        function cancellationPropagateFrom(parent, flags) {
            if (0 != (1 & flags)) {
                this._cancellationParent = parent;
                var branchesRemainingToCancel = parent._branchesRemainingToCancel;
                void 0 === branchesRemainingToCancel && (branchesRemainingToCancel = 0), parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
            }
            0 != (2 & flags) && parent._isBound() && this._setBoundTo(parent._boundTo);
        }
        Promise.config = function(opts) {
            if ("longStackTraces" in (opts = Object(opts)) && (opts.longStackTraces ? Promise.longStackTraces() : !opts.longStackTraces && Promise.hasLongStackTraces() && disableLongStackTraces()), 
            "warnings" in opts) {
                var warningsOption = opts.warnings;
                config.warnings = !!warningsOption, wForgottenReturn = config.warnings, util.isObject(warningsOption) && "wForgottenReturn" in warningsOption && (wForgottenReturn = !!warningsOption.wForgottenReturn);
            }
            if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
                if (async.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
                Promise.prototype._clearCancellationData = cancellationClearCancellationData, Promise.prototype._propagateFrom = cancellationPropagateFrom, 
                Promise.prototype._onCancel = cancellationOnCancel, Promise.prototype._setOnCancel = cancellationSetOnCancel, 
                Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback, 
                Promise.prototype._execute = cancellationExecute, propagateFromFunction = cancellationPropagateFrom, 
                config.cancellation = !0;
            }
            return "monitoring" in opts && (opts.monitoring && !config.monitoring ? (config.monitoring = !0, 
            Promise.prototype._fireEvent = activeFireEvent) : !opts.monitoring && config.monitoring && (config.monitoring = !1, 
            Promise.prototype._fireEvent = defaultFireEvent)), Promise;
        }, Promise.prototype._fireEvent = defaultFireEvent, Promise.prototype._execute = function(executor, resolve, reject) {
            try {
                executor(resolve, reject);
            } catch (e) {
                return e;
            }
        }, Promise.prototype._onCancel = function() {}, Promise.prototype._setOnCancel = function(handler) {}, 
        Promise.prototype._attachCancellationCallback = function(onCancel) {}, Promise.prototype._captureStackTrace = function() {}, 
        Promise.prototype._attachExtraTrace = function() {}, Promise.prototype._dereferenceTrace = function() {}, 
        Promise.prototype._clearCancellationData = function() {}, Promise.prototype._propagateFrom = function(parent, flags) {};
        var propagateFromFunction = function(parent, flags) {
            0 != (2 & flags) && parent._isBound() && this._setBoundTo(parent._boundTo);
        };
        function boundValueFunction() {
            var ret = this._boundTo;
            return void 0 !== ret && ret instanceof Promise ? ret.isFulfilled() ? ret.value() : void 0 : ret;
        }
        function longStackTracesCaptureStackTrace() {
            this._trace = new CapturedTrace(this._peekContext());
        }
        function longStackTracesAttachExtraTrace(error, ignoreSelf) {
            if (canAttachTrace(error)) {
                var trace = this._trace;
                if (void 0 !== trace && ignoreSelf && (trace = trace._parent), void 0 !== trace) trace.attachExtraTrace(error); else if (!error.__stackCleaned__) {
                    var parsed = parseStackAndMessage(error);
                    util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n")), 
                    util.notEnumerableProp(error, "__stackCleaned__", !0);
                }
            }
        }
        function longStackTracesDereferenceTrace() {
            this._trace = void 0;
        }
        function warn(message, shouldUseOwnTrace, promise) {
            if (config.warnings) {
                var ctx, warning = new Warning(message);
                if (shouldUseOwnTrace) promise._attachExtraTrace(warning); else if (config.longStackTraces && (ctx = Promise._peekContext())) ctx.attachExtraTrace(warning); else {
                    var parsed = parseStackAndMessage(warning);
                    warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
                }
                activeFireEvent("warning", warning) || formatAndLogError(warning, "", !0);
            }
        }
        function cleanStack(stack) {
            for (var ret = [], i = 0; i < stack.length; ++i) {
                var line = stack[i], isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line), isInternalFrame = isTraceLine && shouldIgnore(line);
                isTraceLine && !isInternalFrame && (indentStackFrames && " " !== line.charAt(0) && (line = "    " + line), 
                ret.push(line));
            }
            return ret;
        }
        function parseStackAndMessage(error) {
            var stack = error.stack, message = error.toString();
            return stack = "string" == typeof stack && stack.length > 0 ? (function(error) {
                for (var stack = error.stack.replace(/\s+$/g, "").split("\n"), i = 0; i < stack.length; ++i) {
                    var line = stack[i];
                    if ("    (No stack trace)" === line || stackFramePattern.test(line)) break;
                }
                return i > 0 && "SyntaxError" != error.name && (stack = stack.slice(i)), stack;
            })(error) : [ "    (No stack trace)" ], {
                message: message,
                stack: "SyntaxError" == error.name ? stack : cleanStack(stack)
            };
        }
        function formatAndLogError(error, title, isSoft) {
            if ("undefined" != typeof console) {
                var message;
                if (util.isObject(error)) {
                    var stack = error.stack;
                    message = title + formatStack(stack, error);
                } else message = title + String(error);
                "function" == typeof printWarning ? printWarning(message, isSoft) : "function" != typeof console.log && "object" != typeof console.log || console.log(message);
            }
        }
        function fireRejectionEvent(name, localHandler, reason, promise) {
            var localEventFired = !1;
            try {
                "function" == typeof localHandler && (localEventFired = !0, "rejectionHandled" === name ? localHandler(promise) : localHandler(reason, promise));
            } catch (e) {
                async.throwLater(e);
            }
            "unhandledRejection" === name ? activeFireEvent(name, reason, promise) || localEventFired || formatAndLogError(reason, "Unhandled rejection ") : activeFireEvent(name, promise);
        }
        function formatNonError(obj) {
            var str;
            if ("function" == typeof obj) str = "[function " + (obj.name || "anonymous") + "]"; else {
                if (str = obj && "function" == typeof obj.toString ? obj.toString() : util.toString(obj), 
                /\[object [a-zA-Z0-9$_]+\]/.test(str)) try {
                    str = JSON.stringify(obj);
                } catch (e) {}
                0 === str.length && (str = "(empty array)");
            }
            return "(<" + (function(str) {
                return str.length < 41 ? str : str.substr(0, 38) + "...";
            })(str) + ">, no stack trace)";
        }
        function longStackTracesIsSupported() {
            return "function" == typeof captureStackTrace;
        }
        var shouldIgnore = function() {
            return !1;
        }, parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
        function parseLineInfo(line) {
            var matches = line.match(parseLineInfoRegex);
            if (matches) return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
        function CapturedTrace(parent) {
            this._parent = parent, this._promisesCreated = 0;
            var length = this._length = 1 + (void 0 === parent ? 0 : parent._length);
            captureStackTrace(this, CapturedTrace), length > 32 && this.uncycle();
        }
        util.inherits(CapturedTrace, Error), Context.CapturedTrace = CapturedTrace, CapturedTrace.prototype.uncycle = function() {
            var length = this._length;
            if (!(length < 2)) {
                for (var nodes = [], stackToIndex = {}, i = 0, node = this; void 0 !== node; ++i) nodes.push(node), 
                node = node._parent;
                for (i = (length = this._length = i) - 1; i >= 0; --i) {
                    var stack = nodes[i].stack;
                    void 0 === stackToIndex[stack] && (stackToIndex[stack] = i);
                }
                for (i = 0; i < length; ++i) {
                    var index = stackToIndex[nodes[i].stack];
                    if (void 0 !== index && index !== i) {
                        index > 0 && (nodes[index - 1]._parent = void 0, nodes[index - 1]._length = 1), 
                        nodes[i]._parent = void 0, nodes[i]._length = 1;
                        var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                        index < length - 1 ? (cycleEdgeNode._parent = nodes[index + 1], cycleEdgeNode._parent.uncycle(), 
                        cycleEdgeNode._length = cycleEdgeNode._parent._length + 1) : (cycleEdgeNode._parent = void 0, 
                        cycleEdgeNode._length = 1);
                        for (var currentChildLength = cycleEdgeNode._length + 1, j = i - 2; j >= 0; --j) nodes[j]._length = currentChildLength, 
                        currentChildLength++;
                        return;
                    }
                }
            }
        }, CapturedTrace.prototype.attachExtraTrace = function(error) {
            if (!error.__stackCleaned__) {
                this.uncycle();
                for (var parsed = parseStackAndMessage(error), message = parsed.message, stacks = [ parsed.stack ], trace = this; void 0 !== trace; ) stacks.push(cleanStack(trace.stack.split("\n"))), 
                trace = trace._parent;
                !(function(stacks) {
                    for (var current = stacks[0], i = 1; i < stacks.length; ++i) {
                        for (var prev = stacks[i], currentLastIndex = current.length - 1, currentLastLine = current[currentLastIndex], commonRootMeetPoint = -1, j = prev.length - 1; j >= 0; --j) if (prev[j] === currentLastLine) {
                            commonRootMeetPoint = j;
                            break;
                        }
                        for (j = commonRootMeetPoint; j >= 0; --j) {
                            var line = prev[j];
                            if (current[currentLastIndex] !== line) break;
                            current.pop(), currentLastIndex--;
                        }
                        current = prev;
                    }
                })(stacks), (function(stacks) {
                    for (var i = 0; i < stacks.length; ++i) (0 === stacks[i].length || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) && (stacks.splice(i, 1), 
                    i--);
                })(stacks), util.notEnumerableProp(error, "stack", (function(message, stacks) {
                    for (var i = 0; i < stacks.length - 1; ++i) stacks[i].push("From previous event:"), 
                    stacks[i] = stacks[i].join("\n");
                    return i < stacks.length && (stacks[i] = stacks[i].join("\n")), message + "\n" + stacks.join("\n");
                })(message, stacks)), util.notEnumerableProp(error, "__stackCleaned__", !0);
            }
        };
        var captureStackTrace = (function() {
            var v8stackFramePattern = /^\s*at\s*/, v8stackFormatter = function(stack, error) {
                return "string" == typeof stack ? stack : void 0 !== error.name && void 0 !== error.message ? error.toString() : formatNonError(error);
            };
            if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
                Error.stackTraceLimit += 6, stackFramePattern = v8stackFramePattern, formatStack = v8stackFormatter;
                var captureStackTrace = Error.captureStackTrace;
                return shouldIgnore = function(line) {
                    return bluebirdFramePattern.test(line);
                }, function(receiver, ignoreUntil) {
                    Error.stackTraceLimit += 6, captureStackTrace(receiver, ignoreUntil), Error.stackTraceLimit -= 6;
                };
            }
            var hasStackAfterThrow, err = new Error;
            if ("string" == typeof err.stack && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) return stackFramePattern = /@/, 
            formatStack = v8stackFormatter, indentStackFrames = !0, function(o) {
                o.stack = (new Error).stack;
            };
            try {
                throw new Error;
            } catch (e) {
                hasStackAfterThrow = "stack" in e;
            }
            return !("stack" in err) && hasStackAfterThrow && "number" == typeof Error.stackTraceLimit ? (stackFramePattern = v8stackFramePattern, 
            formatStack = v8stackFormatter, function(o) {
                Error.stackTraceLimit += 6;
                try {
                    throw new Error;
                } catch (e) {
                    o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
            }) : (formatStack = function(stack, error) {
                return "string" == typeof stack ? stack : "object" != typeof error && "function" != typeof error || void 0 === error.name || void 0 === error.message ? formatNonError(error) : error.toString();
            }, null);
        })();
        "undefined" != typeof console && void 0 !== console.warn && (printWarning = function(message) {
            console.warn(message);
        }, util.isNode && process.stderr.isTTY ? printWarning = function(message, isSoft) {
            var color = isSoft ? "[33m" : "[31m";
            console.warn(color + message + "[0m\n");
        } : util.isNode || "string" != typeof (new Error).stack || (printWarning = function(message, isSoft) {
            console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
        }));
        var config = {
            warnings: warnings,
            longStackTraces: !1,
            cancellation: !1,
            monitoring: !1
        };
        return longStackTraces && Promise.longStackTraces(), {
            longStackTraces: function() {
                return config.longStackTraces;
            },
            warnings: function() {
                return config.warnings;
            },
            cancellation: function() {
                return config.cancellation;
            },
            monitoring: function() {
                return config.monitoring;
            },
            propagateFromFunction: function() {
                return propagateFromFunction;
            },
            boundValueFunction: function() {
                return boundValueFunction;
            },
            checkForgottenReturns: function(returnValue, promiseCreated, name, promise, parent) {
                if (void 0 === returnValue && null !== promiseCreated && wForgottenReturn) {
                    if (void 0 !== parent && parent._returnedNonUndefined()) return;
                    if (0 == (65535 & promise._bitField)) return;
                    name && (name += " ");
                    var handlerLine = "", creatorLine = "";
                    if (promiseCreated._trace) {
                        for (var traceLines = promiseCreated._trace.stack.split("\n"), stack = cleanStack(traceLines), i = stack.length - 1; i >= 0; --i) {
                            var line = stack[i];
                            if (!nodeFramePattern.test(line)) {
                                var lineMatches = line.match(parseLinePattern);
                                lineMatches && (handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ");
                                break;
                            }
                        }
                        if (stack.length > 0) {
                            var firstUserLine = stack[0];
                            for (i = 0; i < traceLines.length; ++i) if (traceLines[i] === firstUserLine) {
                                i > 0 && (creatorLine = "\n" + traceLines[i - 1]);
                                break;
                            }
                        }
                    }
                    var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
                    promise._warn(msg, !0, promiseCreated);
                }
            },
            setBounds: function(firstLineError, lastLineError) {
                if (longStackTracesIsSupported()) {
                    for (var firstFileName, lastFileName, firstStackLines = (firstLineError.stack || "").split("\n"), lastStackLines = (lastLineError.stack || "").split("\n"), firstIndex = -1, lastIndex = -1, i = 0; i < firstStackLines.length; ++i) if (result = parseLineInfo(firstStackLines[i])) {
                        firstFileName = result.fileName, firstIndex = result.line;
                        break;
                    }
                    for (i = 0; i < lastStackLines.length; ++i) {
                        var result;
                        if (result = parseLineInfo(lastStackLines[i])) {
                            lastFileName = result.fileName, lastIndex = result.line;
                            break;
                        }
                    }
                    firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex || (shouldIgnore = function(line) {
                        if (bluebirdFramePattern.test(line)) return !0;
                        var info = parseLineInfo(line);
                        return !!(info && info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex);
                    });
                }
            },
            warn: warn,
            deprecated: function(name, replacement) {
                var message = name + " is deprecated and will be removed in a future version.";
                return replacement && (message += " Use " + replacement + " instead."), warn(message);
            },
            CapturedTrace: CapturedTrace,
            fireDomEvent: fireDomEvent,
            fireGlobalEvent: fireGlobalEvent
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
        var util = __webpack_require__(16), CancellationError = Promise.CancellationError, errorObj = util.errorObj, catchFilter = __webpack_require__(441)(NEXT_FILTER);
        function PassThroughHandlerContext(promise, type, handler) {
            this.promise = promise, this.type = type, this.handler = handler, this.called = !1, 
            this.cancelPromise = null;
        }
        function FinallyHandlerCancelReaction(finallyHandler) {
            this.finallyHandler = finallyHandler;
        }
        function checkCancel(ctx, reason) {
            return null != ctx.cancelPromise && (arguments.length > 1 ? ctx.cancelPromise._reject(reason) : ctx.cancelPromise._cancel(), 
            ctx.cancelPromise = null, !0);
        }
        function succeed() {
            return finallyHandler.call(this, this.promise._target()._settledValue());
        }
        function fail(reason) {
            if (!checkCancel(this, reason)) return errorObj.e = reason, errorObj;
        }
        function finallyHandler(reasonOrValue) {
            var promise = this.promise, handler = this.handler;
            if (!this.called) {
                this.called = !0;
                var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
                if (ret === NEXT_FILTER) return ret;
                if (void 0 !== ret) {
                    promise._setReturnedNonUndefined();
                    var maybePromise = tryConvertToPromise(ret, promise);
                    if (maybePromise instanceof Promise) {
                        if (null != this.cancelPromise) {
                            if (maybePromise._isCancelled()) {
                                var reason = new CancellationError("late cancellation observer");
                                return promise._attachExtraTrace(reason), errorObj.e = reason, errorObj;
                            }
                            maybePromise.isPending() && maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                        }
                        return maybePromise._then(succeed, fail, void 0, this, void 0);
                    }
                }
            }
            return promise.isRejected() ? (checkCancel(this), errorObj.e = reasonOrValue, errorObj) : (checkCancel(this), 
            reasonOrValue);
        }
        return PassThroughHandlerContext.prototype.isFinallyHandler = function() {
            return 0 === this.type;
        }, FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
            checkCancel(this.finallyHandler);
        }, Promise.prototype._passThrough = function(handler, type, success, fail) {
            return "function" != typeof handler ? this.then() : this._then(success, fail, void 0, new PassThroughHandlerContext(this, type, handler), void 0);
        }, Promise.prototype.lastly = Promise.prototype.finally = function(handler) {
            return this._passThrough(handler, 0, finallyHandler, finallyHandler);
        }, Promise.prototype.tap = function(handler) {
            return this._passThrough(handler, 1, finallyHandler);
        }, Promise.prototype.tapCatch = function(handlerOrPredicate) {
            var len = arguments.length;
            if (1 === len) return this._passThrough(handlerOrPredicate, 1, void 0, finallyHandler);
            var i, catchInstances = new Array(len - 1), j = 0;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (!util.isObject(item)) return Promise.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util.classString(item)));
                catchInstances[j++] = item;
            }
            catchInstances.length = j;
            var handler = arguments[i];
            return this._passThrough(catchFilter(catchInstances, handler, this), 1, void 0, finallyHandler);
        }, PassThroughHandlerContext;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
        var util = __webpack_require__(16), tryCatch = util.tryCatch;
        Promise.method = function(fn) {
            if ("function" != typeof fn) throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
            return function() {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace(), ret._pushContext();
                var value = tryCatch(fn).apply(this, arguments), promiseCreated = ret._popContext();
                return debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret), 
                ret._resolveFromSyncValue(value), ret;
            };
        }, Promise.attempt = Promise.try = function(fn) {
            if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
            var value, ret = new Promise(INTERNAL);
            if (ret._captureStackTrace(), ret._pushContext(), arguments.length > 1) {
                debug.deprecated("calling Promise.try with more than 1 argument");
                var arg = arguments[1], ctx = arguments[2];
                value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
            } else value = tryCatch(fn)();
            var promiseCreated = ret._popContext();
            return debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret), ret._resolveFromSyncValue(value), 
            ret;
        }, Promise.prototype._resolveFromSyncValue = function(value) {
            value === util.errorObj ? this._rejectCallback(value.e, !1) : this._resolveCallback(value, !0);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
        var calledBind = !1, rejectThis = function(_, e) {
            this._reject(e);
        }, targetRejected = function(e, context) {
            context.promiseRejectionQueued = !0, context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
        }, bindingResolved = function(thisArg, context) {
            0 == (50397184 & this._bitField) && this._resolveCallback(context.target);
        }, bindingRejected = function(e, context) {
            context.promiseRejectionQueued || this._reject(e);
        };
        Promise.prototype.bind = function(thisArg) {
            calledBind || (calledBind = !0, Promise.prototype._propagateFrom = debug.propagateFromFunction(), 
            Promise.prototype._boundValue = debug.boundValueFunction());
            var maybePromise = tryConvertToPromise(thisArg), ret = new Promise(INTERNAL);
            ret._propagateFrom(this, 1);
            var target = this._target();
            if (ret._setBoundTo(maybePromise), maybePromise instanceof Promise) {
                var context = {
                    promiseRejectionQueued: !1,
                    promise: ret,
                    target: target,
                    bindingPromise: maybePromise
                };
                target._then(INTERNAL, targetRejected, void 0, ret, context), maybePromise._then(bindingResolved, bindingRejected, void 0, ret, context), 
                ret._setOnCancel(maybePromise);
            } else ret._resolveCallback(target);
            return ret;
        }, Promise.prototype._setBoundTo = function(obj) {
            void 0 !== obj ? (this._bitField = 2097152 | this._bitField, this._boundTo = obj) : this._bitField = -2097153 & this._bitField;
        }, Promise.prototype._isBound = function() {
            return 2097152 == (2097152 & this._bitField);
        }, Promise.bind = function(thisArg, value) {
            return Promise.resolve(value).bind(thisArg);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, apiRejection, debug) {
        var util = __webpack_require__(16), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
        Promise.prototype.break = Promise.prototype.cancel = function() {
            if (!debug.cancellation()) return this._warn("cancellation is disabled");
            for (var promise = this, child = promise; promise._isCancellable(); ) {
                if (!promise._cancelBy(child)) {
                    child._isFollowing() ? child._followee().cancel() : child._cancelBranched();
                    break;
                }
                var parent = promise._cancellationParent;
                if (null == parent || !parent._isCancellable()) {
                    promise._isFollowing() ? promise._followee().cancel() : promise._cancelBranched();
                    break;
                }
                promise._isFollowing() && promise._followee().cancel(), promise._setWillBeCancelled(), 
                child = promise, promise = parent;
            }
        }, Promise.prototype._branchHasCancelled = function() {
            this._branchesRemainingToCancel--;
        }, Promise.prototype._enoughBranchesHaveCancelled = function() {
            return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0;
        }, Promise.prototype._cancelBy = function(canceller) {
            return canceller === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), 
            !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), 
            !0));
        }, Promise.prototype._cancelBranched = function() {
            this._enoughBranchesHaveCancelled() && this._cancel();
        }, Promise.prototype._cancel = function() {
            this._isCancellable() && (this._setCancelled(), async.invoke(this._cancelPromises, this, void 0));
        }, Promise.prototype._cancelPromises = function() {
            this._length() > 0 && this._settlePromises();
        }, Promise.prototype._unsetOnCancel = function() {
            this._onCancelField = void 0;
        }, Promise.prototype._isCancellable = function() {
            return this.isPending() && !this._isCancelled();
        }, Promise.prototype.isCancellable = function() {
            return this.isPending() && !this.isCancelled();
        }, Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
            if (util.isArray(onCancelCallback)) for (var i = 0; i < onCancelCallback.length; ++i) this._doInvokeOnCancel(onCancelCallback[i], internalOnly); else if (void 0 !== onCancelCallback) if ("function" == typeof onCancelCallback) {
                if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    e === errorObj && (this._attachExtraTrace(e.e), async.throwLater(e.e));
                }
            } else onCancelCallback._resultCancelled(this);
        }, Promise.prototype._invokeOnCancel = function() {
            var onCancelCallback = this._onCancel();
            this._unsetOnCancel(), async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
        }, Promise.prototype._invokeInternalOnCancel = function() {
            this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
        }, Promise.prototype._resultCancelled = function() {
            this.cancel();
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise) {
        function returner() {
            return this.value;
        }
        function thrower() {
            throw this.reason;
        }
        Promise.prototype.return = Promise.prototype.thenReturn = function(value) {
            return value instanceof Promise && value.suppressUnhandledRejections(), this._then(returner, void 0, void 0, {
                value: value
            }, void 0);
        }, Promise.prototype.throw = Promise.prototype.thenThrow = function(reason) {
            return this._then(thrower, void 0, void 0, {
                reason: reason
            }, void 0);
        }, Promise.prototype.catchThrow = function(reason) {
            if (arguments.length <= 1) return this._then(void 0, thrower, void 0, {
                reason: reason
            }, void 0);
            var _reason = arguments[1], handler = function() {
                throw _reason;
            };
            return this.caught(reason, handler);
        }, Promise.prototype.catchReturn = function(value) {
            if (arguments.length <= 1) return value instanceof Promise && value.suppressUnhandledRejections(), 
            this._then(void 0, returner, void 0, {
                value: value
            }, void 0);
            var _value = arguments[1];
            _value instanceof Promise && _value.suppressUnhandledRejections();
            var handler = function() {
                return _value;
            };
            return this.caught(value, handler);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise) {
        function PromiseInspection(promise) {
            void 0 !== promise ? (promise = promise._target(), this._bitField = promise._bitField, 
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0) : (this._bitField = 0, 
            this._settledValueField = void 0);
        }
        PromiseInspection.prototype._settledValue = function() {
            return this._settledValueField;
        };
        var value = PromiseInspection.prototype.value = function() {
            if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
            return this._settledValue();
        }, reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
            if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
            return this._settledValue();
        }, isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
            return 0 != (33554432 & this._bitField);
        }, isRejected = PromiseInspection.prototype.isRejected = function() {
            return 0 != (16777216 & this._bitField);
        }, isPending = PromiseInspection.prototype.isPending = function() {
            return 0 == (50397184 & this._bitField);
        }, isResolved = PromiseInspection.prototype.isResolved = function() {
            return 0 != (50331648 & this._bitField);
        };
        PromiseInspection.prototype.isCancelled = function() {
            return 0 != (8454144 & this._bitField);
        }, Promise.prototype.__isCancelled = function() {
            return 65536 == (65536 & this._bitField);
        }, Promise.prototype._isCancelled = function() {
            return this._target().__isCancelled();
        }, Promise.prototype.isCancelled = function() {
            return 0 != (8454144 & this._target()._bitField);
        }, Promise.prototype.isPending = function() {
            return isPending.call(this._target());
        }, Promise.prototype.isRejected = function() {
            return isRejected.call(this._target());
        }, Promise.prototype.isFulfilled = function() {
            return isFulfilled.call(this._target());
        }, Promise.prototype.isResolved = function() {
            return isResolved.call(this._target());
        }, Promise.prototype.value = function() {
            return value.call(this._target());
        }, Promise.prototype.reason = function() {
            var target = this._target();
            return target._unsetRejectionIsUnhandled(), reason.call(target);
        }, Promise.prototype._value = function() {
            return this._settledValue();
        }, Promise.prototype._reason = function() {
            return this._unsetRejectionIsUnhandled(), this._settledValue();
        }, Promise.PromiseInspection = PromiseInspection;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
        var reject, util = __webpack_require__(16), canEvaluate = util.canEvaluate, tryCatch = util.tryCatch, errorObj = util.errorObj;
        if (canEvaluate) {
            for (var thenCallback = function(i) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i));
            }, promiseSetter = function(i) {
                return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i));
            }, generateHolderClass = function(total) {
                for (var props = new Array(total), i = 0; i < props.length; ++i) props[i] = "this.p" + (i + 1);
                var assignment = props.join(" = ") + " = null;", cancellationCode = "var promise;\n" + props.map((function(prop) {
                    return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
                })).join("\n"), passedArguments = props.join(", "), name = "Holder$" + total, code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
                return code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode), 
                new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
            }, holderClasses = [], thenCallbacks = [], promiseSetters = [], i = 0; i < 8; ++i) holderClasses.push(generateHolderClass(i + 1)), 
            thenCallbacks.push(thenCallback(i + 1)), promiseSetters.push(promiseSetter(i + 1));
            reject = function(reason) {
                this._reject(reason);
            };
        }
        Promise.join = function() {
            var fn, last = arguments.length - 1;
            if (last > 0 && "function" == typeof arguments[last] && (fn = arguments[last], last <= 8 && canEvaluate)) {
                (ret = new Promise(INTERNAL))._captureStackTrace();
                for (var HolderClass = holderClasses[last - 1], holder = new HolderClass(fn), callbacks = thenCallbacks, i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        var bitField = (maybePromise = maybePromise._target())._bitField;
                        0 == (50397184 & bitField) ? (maybePromise._then(callbacks[i], reject, void 0, ret, holder), 
                        promiseSetters[i](maybePromise, holder), holder.asyncNeeded = !1) : 0 != (33554432 & bitField) ? callbacks[i].call(ret, maybePromise._value(), holder) : 0 != (16777216 & bitField) ? ret._reject(maybePromise._reason()) : ret._cancel();
                    } else callbacks[i].call(ret, maybePromise, holder);
                }
                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        null !== domain && (holder.fn = util.domainBind(domain, holder.fn));
                    }
                    ret._setAsyncGuaranteed(), ret._setOnCancel(holder);
                }
                return ret;
            }
            for (var $_len = arguments.length, args = new Array($_len), $_i = 0; $_i < $_len; ++$_i) args[$_i] = arguments[$_i];
            fn && args.pop();
            var ret = new PromiseArray(args).promise();
            return void 0 !== fn ? ret.spread(fn) : ret;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var cr = Object.create;
    if (cr) {
        var callerCache = cr(null), getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
    }
    module.exports = function(Promise) {
        var getMethodCaller, getGetter, util = __webpack_require__(16), canEvaluate = util.canEvaluate, isIdentifier = util.isIdentifier, makeMethodCaller = function(methodName) {
            return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        }, makeGetter = function(propertyName) {
            return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        }, getCompiled = function(name, compiler, cache) {
            var ret = cache[name];
            if ("function" != typeof ret) {
                if (!isIdentifier(name)) return null;
                if (ret = compiler(name), cache[name] = ret, cache[" size"]++, cache[" size"] > 512) {
                    for (var keys = Object.keys(cache), i = 0; i < 256; ++i) delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                }
            }
            return ret;
        };
        function ensureMethod(obj, methodName) {
            var fn;
            if (null != obj && (fn = obj[methodName]), "function" != typeof fn) {
                var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
                throw new Promise.TypeError(message);
            }
            return fn;
        }
        function caller(obj) {
            return ensureMethod(obj, this.pop()).apply(obj, this);
        }
        function namedGetter(obj) {
            return obj[this];
        }
        function indexedGetter(obj) {
            var index = +this;
            return index < 0 && (index = Math.max(0, index + obj.length)), obj[index];
        }
        getMethodCaller = function(name) {
            return getCompiled(name, makeMethodCaller, callerCache);
        }, getGetter = function(name) {
            return getCompiled(name, makeGetter, getterCache);
        }, Promise.prototype.call = function(methodName) {
            for (var $_len = arguments.length, args = new Array(Math.max($_len - 1, 0)), $_i = 1; $_i < $_len; ++$_i) args[$_i - 1] = arguments[$_i];
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (null !== maybeCaller) return this._then(maybeCaller, void 0, void 0, args, void 0);
            }
            return args.push(methodName), this._then(caller, void 0, void 0, args, void 0);
        }, Promise.prototype.get = function(propertyName) {
            var getter;
            if ("number" == typeof propertyName) getter = indexedGetter; else if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = null !== maybeGetter ? maybeGetter : namedGetter;
            } else getter = namedGetter;
            return this._then(getter, void 0, void 0, propertyName, void 0);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
        var TypeError = __webpack_require__(55).TypeError, util = __webpack_require__(16), errorObj = util.errorObj, tryCatch = util.tryCatch, yieldHandlers = [];
        function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
            if (debug.cancellation()) {
                var internal = new Promise(INTERNAL), _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
                this._promise = internal.lastly((function() {
                    return _finallyPromise;
                })), internal._captureStackTrace(), internal._setOnCancel(this);
            } else (this._promise = new Promise(INTERNAL))._captureStackTrace();
            this._stack = stack, this._generatorFunction = generatorFunction, this._receiver = receiver, 
            this._generator = void 0, this._yieldHandlers = "function" == typeof yieldHandler ? [ yieldHandler ].concat(yieldHandlers) : yieldHandlers, 
            this._yieldedPromise = null, this._cancellationPhase = !1;
        }
        util.inherits(PromiseSpawn, Proxyable), PromiseSpawn.prototype._isResolved = function() {
            return null === this._promise;
        }, PromiseSpawn.prototype._cleanup = function() {
            this._promise = this._generator = null, debug.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), 
            this._finallyPromise = null);
        }, PromiseSpawn.prototype._promiseCancelled = function() {
            if (!this._isResolved()) {
                var result;
                if (void 0 !== this._generator.return) this._promise._pushContext(), result = tryCatch(this._generator.return).call(this._generator, void 0), 
                this._promise._popContext(); else {
                    var reason = new Promise.CancellationError("generator .return() sentinel");
                    Promise.coroutine.returnSentinel = reason, this._promise._attachExtraTrace(reason), 
                    this._promise._pushContext(), result = tryCatch(this._generator.throw).call(this._generator, reason), 
                    this._promise._popContext();
                }
                this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(result);
            }
        }, PromiseSpawn.prototype._promiseFulfilled = function(value) {
            this._yieldedPromise = null, this._promise._pushContext();
            var result = tryCatch(this._generator.next).call(this._generator, value);
            this._promise._popContext(), this._continue(result);
        }, PromiseSpawn.prototype._promiseRejected = function(reason) {
            this._yieldedPromise = null, this._promise._attachExtraTrace(reason), this._promise._pushContext();
            var result = tryCatch(this._generator.throw).call(this._generator, reason);
            this._promise._popContext(), this._continue(result);
        }, PromiseSpawn.prototype._resultCancelled = function() {
            if (this._yieldedPromise instanceof Promise) {
                var promise = this._yieldedPromise;
                this._yieldedPromise = null, promise.cancel();
            }
        }, PromiseSpawn.prototype.promise = function() {
            return this._promise;
        }, PromiseSpawn.prototype._run = function() {
            this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, 
            this._promiseFulfilled(void 0);
        }, PromiseSpawn.prototype._continue = function(result) {
            var promise = this._promise;
            if (result === errorObj) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._rejectCallback(result.e, !1);
            var value = result.value;
            if (!0 === result.done) return this._cleanup(), this._cancellationPhase ? promise.cancel() : promise._resolveCallback(value);
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (maybePromise instanceof Promise || (maybePromise = (function(value, yieldHandlers, traceParent) {
                for (var i = 0; i < yieldHandlers.length; ++i) {
                    traceParent._pushContext();
                    var result = tryCatch(yieldHandlers[i])(value);
                    if (traceParent._popContext(), result === errorObj) {
                        traceParent._pushContext();
                        var ret = Promise.reject(errorObj.e);
                        return traceParent._popContext(), ret;
                    }
                    var maybePromise = tryConvertToPromise(result, traceParent);
                    if (maybePromise instanceof Promise) return maybePromise;
                }
                return null;
            })(maybePromise, this._yieldHandlers, this._promise), null !== maybePromise)) {
                var bitField = (maybePromise = maybePromise._target())._bitField;
                0 == (50397184 & bitField) ? (this._yieldedPromise = maybePromise, maybePromise._proxy(this, null)) : 0 != (33554432 & bitField) ? Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value()) : 0 != (16777216 & bitField) ? Promise._async.invoke(this._promiseRejected, this, maybePromise._reason()) : this._promiseCancelled();
            } else this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
        }, Promise.coroutine = function(generatorFunction, options) {
            if ("function" != typeof generatorFunction) throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            var yieldHandler = Object(options).yieldHandler, PromiseSpawn$ = PromiseSpawn, stack = (new Error).stack;
            return function() {
                var generator = generatorFunction.apply(this, arguments), spawn = new PromiseSpawn$(void 0, void 0, yieldHandler, stack), ret = spawn.promise();
                return spawn._generator = generator, spawn._promiseFulfilled(void 0), ret;
            };
        }, Promise.coroutine.addYieldHandler = function(fn) {
            if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
            yieldHandlers.push(fn);
        }, Promise.spawn = function(generatorFunction) {
            if (debug.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof generatorFunction) return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
            var spawn = new PromiseSpawn(generatorFunction, this), ret = spawn.promise();
            return spawn._run(Promise.spawn), ret;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
        var getDomain = Promise._getDomain, util = __webpack_require__(16), tryCatch = util.tryCatch, errorObj = util.errorObj, async = Promise._async;
        function MappingPromiseArray(promises, fn, limit, _filter) {
            this.constructor$(promises), this._promise._captureStackTrace();
            var domain = getDomain();
            this._callback = null === domain ? fn : util.domainBind(domain, fn), this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null, 
            this._limit = limit, this._inFlight = 0, this._queue = [], async.invoke(this._asyncInit, this, void 0);
        }
        function map(promises, fn, options, _filter) {
            if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
            var limit = 0;
            if (void 0 !== options) {
                if ("object" != typeof options || null === options) return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
                if ("number" != typeof options.concurrency) return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                limit = options.concurrency;
            }
            return new MappingPromiseArray(promises, fn, limit = "number" == typeof limit && isFinite(limit) && limit >= 1 ? limit : 0, _filter).promise();
        }
        util.inherits(MappingPromiseArray, PromiseArray), MappingPromiseArray.prototype._asyncInit = function() {
            this._init$(void 0, -2);
        }, MappingPromiseArray.prototype._init = function() {}, MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var values = this._values, length = this.length(), preservedValues = this._preservedValues, limit = this._limit;
            if (index < 0) {
                if (values[index = -1 * index - 1] = value, limit >= 1 && (this._inFlight--, this._drainQueue(), 
                this._isResolved())) return !0;
            } else {
                if (limit >= 1 && this._inFlight >= limit) return values[index] = value, this._queue.push(index), 
                !1;
                null !== preservedValues && (preservedValues[index] = value);
                var promise = this._promise, callback = this._callback, receiver = promise._boundValue();
                promise._pushContext();
                var ret = tryCatch(callback).call(receiver, value, index, length), promiseCreated = promise._popContext();
                if (debug.checkForgottenReturns(ret, promiseCreated, null !== preservedValues ? "Promise.filter" : "Promise.map", promise), 
                ret === errorObj) return this._reject(ret.e), !0;
                var maybePromise = tryConvertToPromise(ret, this._promise);
                if (maybePromise instanceof Promise) {
                    var bitField = (maybePromise = maybePromise._target())._bitField;
                    if (0 == (50397184 & bitField)) return limit >= 1 && this._inFlight++, values[index] = maybePromise, 
                    maybePromise._proxy(this, -1 * (index + 1)), !1;
                    if (0 == (33554432 & bitField)) return 0 != (16777216 & bitField) ? (this._reject(maybePromise._reason()), 
                    !0) : (this._cancel(), !0);
                    ret = maybePromise._value();
                }
                values[index] = ret;
            }
            return ++this._totalResolved >= length && (null !== preservedValues ? this._filter(values, preservedValues) : this._resolve(values), 
            !0);
        }, MappingPromiseArray.prototype._drainQueue = function() {
            for (var queue = this._queue, limit = this._limit, values = this._values; queue.length > 0 && this._inFlight < limit; ) {
                if (this._isResolved()) return;
                var index = queue.pop();
                this._promiseFulfilled(values[index], index);
            }
        }, MappingPromiseArray.prototype._filter = function(booleans, values) {
            for (var len = values.length, ret = new Array(len), j = 0, i = 0; i < len; ++i) booleans[i] && (ret[j++] = values[i]);
            ret.length = j, this._resolve(ret);
        }, MappingPromiseArray.prototype.preservedValues = function() {
            return this._preservedValues;
        }, Promise.prototype.map = function(fn, options) {
            return map(this, fn, options, null);
        }, Promise.map = function(promises, fn, options, _filter) {
            return map(promises, fn, options, _filter);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise) {
        var util = __webpack_require__(16), async = Promise._async, tryCatch = util.tryCatch, errorObj = util.errorObj;
        function spreadAdapter(val, nodeback) {
            if (!util.isArray(val)) return successAdapter.call(this, val, nodeback);
            var ret = tryCatch(nodeback).apply(this._boundValue(), [ null ].concat(val));
            ret === errorObj && async.throwLater(ret.e);
        }
        function successAdapter(val, nodeback) {
            var receiver = this._boundValue(), ret = void 0 === val ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
            ret === errorObj && async.throwLater(ret.e);
        }
        function errorAdapter(reason, nodeback) {
            if (!reason) {
                var newReason = new Error(reason + "");
                newReason.cause = reason, reason = newReason;
            }
            var ret = tryCatch(nodeback).call(this._boundValue(), reason);
            ret === errorObj && async.throwLater(ret.e);
        }
        Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
            if ("function" == typeof nodeback) {
                var adapter = successAdapter;
                void 0 !== options && Object(options).spread && (adapter = spreadAdapter), this._then(adapter, errorAdapter, void 0, this, nodeback);
            }
            return this;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL) {
        var THIS = {}, util = __webpack_require__(16), nodebackForPromise = __webpack_require__(442), withAppended = util.withAppended, maybeWrapAsError = util.maybeWrapAsError, canEvaluate = util.canEvaluate, TypeError = __webpack_require__(55).TypeError, defaultPromisified = {
            __isPromisified__: !0
        }, noCopyPropsPattern = new RegExp("^(?:" + [ "arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__" ].join("|") + ")$"), defaultFilter = function(name) {
            return util.isIdentifier(name) && "_" !== name.charAt(0) && "constructor" !== name;
        };
        function propsFilter(key) {
            return !noCopyPropsPattern.test(key);
        }
        function isPromisified(fn) {
            try {
                return !0 === fn.__isPromisified__;
            } catch (e) {
                return !1;
            }
        }
        function hasPromisified(obj, key, suffix) {
            var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
            return !!val && isPromisified(val);
        }
        var makeNodePromisified = canEvaluate ? function(callback, receiver, originalName, fn, _, multiArgs) {
            var newParameterCount = Math.max(0, (function(fn) {
                return "number" == typeof fn.length ? Math.max(Math.min(fn.length, 1024), 0) : 0;
            })(fn) - 1), argumentOrder = (function(likelyArgumentCount) {
                for (var ret = [ likelyArgumentCount ], min = Math.max(0, likelyArgumentCount - 1 - 3), i = likelyArgumentCount - 1; i >= min; --i) ret.push(i);
                for (i = likelyArgumentCount + 1; i <= 3; ++i) ret.push(i);
                return ret;
            })(newParameterCount), shouldProxyThis = "string" == typeof callback || receiver === THIS;
            var parameterCount, getFunctionCode = "string" == typeof callback ? "this != null ? this['" + callback + "'] : fn" : "fn", body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", (function() {
                for (var ret = "", i = 0; i < argumentOrder.length; ++i) ret += "case " + argumentOrder[i] + ":" + (count = argumentOrder[i], 
                argumentCount = void 0, args = void 0, comma = void 0, args = (argumentCount = count, 
                util.filledRange(argumentCount, "_arg", "")).join(", "), comma = count > 0 ? ", " : "", 
                (shouldProxyThis ? "ret = callback.call(this, {{args}}, nodeback); break;\n" : void 0 === receiver ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n").replace("{{args}}", args).replace(", ", comma));
                var count, argumentCount, args, comma;
                return ret + "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            })()).replace("[GetFunctionCode]", getFunctionCode);
            return body = body.replace("Parameters", (parameterCount = newParameterCount, util.filledRange(Math.max(parameterCount, 3), "_arg", ""))), 
            new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        } : function(callback, receiver, _, fn, __, multiArgs) {
            var defaultThis = (function() {
                return this;
            })(), method = callback;
            function promisified() {
                var _receiver = receiver;
                receiver === THIS && (_receiver = this);
                var promise = new Promise(INTERNAL);
                promise._captureStackTrace();
                var cb = "string" == typeof method && this !== defaultThis ? this[method] : callback, fn = nodebackForPromise(promise, multiArgs);
                try {
                    cb.apply(_receiver, withAppended(arguments, fn));
                } catch (e) {
                    promise._rejectCallback(maybeWrapAsError(e), !0, !0);
                }
                return promise._isFateSealed() || promise._setAsyncGuaranteed(), promise;
            }
            return "string" == typeof method && (callback = fn), util.notEnumerableProp(promisified, "__isPromisified__", !0), 
            promisified;
        };
        function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
            for (var suffixRegexp = new RegExp(suffix.replace(/([$])/, "\\$") + "$"), methods = (function(obj, suffix, suffixRegexp, filter) {
                for (var keys = util.inheritedDataKeys(obj), ret = [], i = 0; i < keys.length; ++i) {
                    var key = keys[i], value = obj[key], passesDefaultFilter = filter === defaultFilter || defaultFilter(key);
                    "function" != typeof value || isPromisified(value) || hasPromisified(obj, key, suffix) || !filter(key, value, obj, passesDefaultFilter) || ret.push(key, value);
                }
                return (function(ret, suffix, suffixRegexp) {
                    for (var i = 0; i < ret.length; i += 2) {
                        var key = ret[i];
                        if (suffixRegexp.test(key)) for (var keyWithoutAsyncSuffix = key.replace(suffixRegexp, ""), j = 0; j < ret.length; j += 2) if (ret[j] === keyWithoutAsyncSuffix) throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                    }
                })(ret, suffix, suffixRegexp), ret;
            })(obj, suffix, suffixRegexp, filter), i = 0, len = methods.length; i < len; i += 2) {
                var key = methods[i], fn = methods[i + 1], promisifiedKey = key + suffix;
                if (promisifier === makeNodePromisified) obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs); else {
                    var promisified = promisifier(fn, (function() {
                        return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                    }));
                    util.notEnumerableProp(promisified, "__isPromisified__", !0), obj[promisifiedKey] = promisified;
                }
            }
            return util.toFastProperties(obj), obj;
        }
        Promise.promisify = function(fn, options) {
            if ("function" != typeof fn) throw new TypeError("expecting a function but got " + util.classString(fn));
            if (isPromisified(fn)) return fn;
            var callback, receiver, multiArgs, ret = (callback = fn, receiver = void 0 === (options = Object(options)).context ? THIS : options.context, 
            multiArgs = !!options.multiArgs, makeNodePromisified(callback, receiver, void 0, callback, null, multiArgs));
            return util.copyDescriptors(fn, ret, propsFilter), ret;
        }, Promise.promisifyAll = function(target, options) {
            if ("function" != typeof target && "object" != typeof target) throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
            var multiArgs = !!(options = Object(options)).multiArgs, suffix = options.suffix;
            "string" != typeof suffix && (suffix = "Async");
            var filter = options.filter;
            "function" != typeof filter && (filter = defaultFilter);
            var promisifier = options.promisifier;
            if ("function" != typeof promisifier && (promisifier = makeNodePromisified), !util.isIdentifier(suffix)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
            for (var keys = util.inheritedDataKeys(target), i = 0; i < keys.length; ++i) {
                var value = target[keys[i]];
                "constructor" !== keys[i] && util.isClass(value) && (promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs), 
                promisifyAll(value, suffix, filter, promisifier, multiArgs));
            }
            return promisifyAll(target, suffix, filter, promisifier, multiArgs);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
        var Es6Map, util = __webpack_require__(16), isObject = util.isObject, es5 = __webpack_require__(66);
        "function" == typeof Map && (Es6Map = Map);
        var mapToEntries = (function() {
            var index = 0, size = 0;
            function extractEntry(value, key) {
                this[index] = value, this[index + size] = key, index++;
            }
            return function(map) {
                size = map.size, index = 0;
                var ret = new Array(2 * map.size);
                return map.forEach(extractEntry, ret), ret;
            };
        })();
        function PropertiesPromiseArray(obj) {
            var entries, isMap = !1;
            if (void 0 !== Es6Map && obj instanceof Es6Map) entries = mapToEntries(obj), isMap = !0; else {
                var keys = es5.keys(obj), len = keys.length;
                entries = new Array(2 * len);
                for (var i = 0; i < len; ++i) {
                    var key = keys[i];
                    entries[i] = obj[key], entries[i + len] = key;
                }
            }
            this.constructor$(entries), this._isMap = isMap, this._init$(void 0, isMap ? -6 : -3);
        }
        function props(promises) {
            var ret, castValue = tryConvertToPromise(promises);
            return isObject(castValue) ? (ret = castValue instanceof Promise ? castValue._then(Promise.props, void 0, void 0, void 0, void 0) : new PropertiesPromiseArray(castValue).promise(), 
            castValue instanceof Promise && ret._propagateFrom(castValue, 2), ret) : apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        }
        util.inherits(PropertiesPromiseArray, PromiseArray), PropertiesPromiseArray.prototype._init = function() {}, 
        PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
            if (this._values[index] = value, ++this._totalResolved >= this._length) {
                var val;
                if (this._isMap) val = (function(entries) {
                    for (var ret = new Es6Map, length = entries.length / 2 | 0, i = 0; i < length; ++i) {
                        var key = entries[length + i], value = entries[i];
                        ret.set(key, value);
                    }
                    return ret;
                })(this._values); else {
                    val = {};
                    for (var keyOffset = this.length(), i = 0, len = this.length(); i < len; ++i) val[this._values[i + keyOffset]] = this._values[i];
                }
                return this._resolve(val), !0;
            }
            return !1;
        }, PropertiesPromiseArray.prototype.shouldCopyValues = function() {
            return !1;
        }, PropertiesPromiseArray.prototype.getActualLength = function(len) {
            return len >> 1;
        }, Promise.prototype.props = function() {
            return props(this);
        }, Promise.props = function(promises) {
            return props(promises);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
        var util = __webpack_require__(16);
        function race(promises, parent) {
            var promise, maybePromise = tryConvertToPromise(promises);
            if (maybePromise instanceof Promise) return (promise = maybePromise).then((function(array) {
                return race(array, promise);
            }));
            if (null === (promises = util.asArray(promises))) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
            var ret = new Promise(INTERNAL);
            void 0 !== parent && ret._propagateFrom(parent, 3);
            for (var fulfill = ret._fulfill, reject = ret._reject, i = 0, len = promises.length; i < len; ++i) {
                var val = promises[i];
                (void 0 !== val || i in promises) && Promise.cast(val)._then(fulfill, reject, void 0, ret, null);
            }
            return ret;
        }
        Promise.race = function(promises) {
            return race(promises, void 0);
        }, Promise.prototype.race = function() {
            return race(this, void 0);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
        var getDomain = Promise._getDomain, util = __webpack_require__(16), tryCatch = util.tryCatch;
        function ReductionPromiseArray(promises, fn, initialValue, _each) {
            this.constructor$(promises);
            var domain = getDomain();
            this._fn = null === domain ? fn : util.domainBind(domain, fn), void 0 !== initialValue && (initialValue = Promise.resolve(initialValue))._attachCancellationCallback(this), 
            this._initialValue = initialValue, this._currentCancellable = null, this._eachValues = _each === INTERNAL ? Array(this._length) : 0 === _each ? null : void 0, 
            this._promise._captureStackTrace(), this._init$(void 0, -5);
        }
        function completed(valueOrReason, array) {
            this.isFulfilled() ? array._resolve(valueOrReason) : array._reject(valueOrReason);
        }
        function reduce(promises, fn, initialValue, _each) {
            return "function" != typeof fn ? apiRejection("expecting a function but got " + util.classString(fn)) : new ReductionPromiseArray(promises, fn, initialValue, _each).promise();
        }
        function gotAccum(accum) {
            this.accum = accum, this.array._gotAccum(accum);
            var value = tryConvertToPromise(this.value, this.array._promise);
            return value instanceof Promise ? (this.array._currentCancellable = value, value._then(gotValue, void 0, void 0, this, void 0)) : gotValue.call(this, value);
        }
        function gotValue(value) {
            var ret, array = this.array, promise = array._promise, fn = tryCatch(array._fn);
            promise._pushContext(), (ret = void 0 !== array._eachValues ? fn.call(promise._boundValue(), value, this.index, this.length) : fn.call(promise._boundValue(), this.accum, value, this.index, this.length)) instanceof Promise && (array._currentCancellable = ret);
            var promiseCreated = promise._popContext();
            return debug.checkForgottenReturns(ret, promiseCreated, void 0 !== array._eachValues ? "Promise.each" : "Promise.reduce", promise), 
            ret;
        }
        util.inherits(ReductionPromiseArray, PromiseArray), ReductionPromiseArray.prototype._gotAccum = function(accum) {
            void 0 !== this._eachValues && null !== this._eachValues && accum !== INTERNAL && this._eachValues.push(accum);
        }, ReductionPromiseArray.prototype._eachComplete = function(value) {
            return null !== this._eachValues && this._eachValues.push(value), this._eachValues;
        }, ReductionPromiseArray.prototype._init = function() {}, ReductionPromiseArray.prototype._resolveEmptyArray = function() {
            this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue);
        }, ReductionPromiseArray.prototype.shouldCopyValues = function() {
            return !1;
        }, ReductionPromiseArray.prototype._resolve = function(value) {
            this._promise._resolveCallback(value), this._values = null;
        }, ReductionPromiseArray.prototype._resultCancelled = function(sender) {
            if (sender === this._initialValue) return this._cancel();
            this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof Promise && this._currentCancellable.cancel(), 
            this._initialValue instanceof Promise && this._initialValue.cancel());
        }, ReductionPromiseArray.prototype._iterate = function(values) {
            var value, i;
            this._values = values;
            var length = values.length;
            if (void 0 !== this._initialValue ? (value = this._initialValue, i = 0) : (value = Promise.resolve(values[0]), 
            i = 1), this._currentCancellable = value, !value.isRejected()) for (;i < length; ++i) {
                var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                };
                value = value._then(gotAccum, void 0, void 0, ctx, void 0);
            }
            void 0 !== this._eachValues && (value = value._then(this._eachComplete, void 0, void 0, this, void 0)), 
            value._then(completed, completed, void 0, value, this);
        }, Promise.prototype.reduce = function(fn, initialValue) {
            return reduce(this, fn, initialValue, null);
        }, Promise.reduce = function(promises, fn, initialValue, _each) {
            return reduce(promises, fn, initialValue, _each);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, debug) {
        var PromiseInspection = Promise.PromiseInspection;
        function SettledPromiseArray(values) {
            this.constructor$(values);
        }
        __webpack_require__(16).inherits(SettledPromiseArray, PromiseArray), SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
            return this._values[index] = inspection, ++this._totalResolved >= this._length && (this._resolve(this._values), 
            !0);
        }, SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
            var ret = new PromiseInspection;
            return ret._bitField = 33554432, ret._settledValueField = value, this._promiseResolved(index, ret);
        }, SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
            var ret = new PromiseInspection;
            return ret._bitField = 16777216, ret._settledValueField = reason, this._promiseResolved(index, ret);
        }, Promise.settle = function(promises) {
            return debug.deprecated(".settle()", ".reflect()"), new SettledPromiseArray(promises).promise();
        }, Promise.prototype.settle = function() {
            return Promise.settle(this);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, PromiseArray, apiRejection) {
        var util = __webpack_require__(16), RangeError = __webpack_require__(55).RangeError, AggregateError = __webpack_require__(55).AggregateError, isArray = util.isArray, CANCELLATION = {};
        function SomePromiseArray(values) {
            this.constructor$(values), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
        }
        function some(promises, howMany) {
            if ((0 | howMany) !== howMany || howMany < 0) return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
            var ret = new SomePromiseArray(promises), promise = ret.promise();
            return ret.setHowMany(howMany), ret.init(), promise;
        }
        util.inherits(SomePromiseArray, PromiseArray), SomePromiseArray.prototype._init = function() {
            if (this._initialized) if (0 !== this._howMany) {
                this._init$(void 0, -5);
                var isArrayResolved = isArray(this._values);
                !this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
            } else this._resolve([]);
        }, SomePromiseArray.prototype.init = function() {
            this._initialized = !0, this._init();
        }, SomePromiseArray.prototype.setUnwrap = function() {
            this._unwrap = !0;
        }, SomePromiseArray.prototype.howMany = function() {
            return this._howMany;
        }, SomePromiseArray.prototype.setHowMany = function(count) {
            this._howMany = count;
        }, SomePromiseArray.prototype._promiseFulfilled = function(value) {
            return this._addFulfilled(value), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), 
            1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), 
            !0);
        }, SomePromiseArray.prototype._promiseRejected = function(reason) {
            return this._addRejected(reason), this._checkOutcome();
        }, SomePromiseArray.prototype._promiseCancelled = function() {
            return this._values instanceof Promise || null == this._values ? this._cancel() : (this._addRejected(CANCELLATION), 
            this._checkOutcome());
        }, SomePromiseArray.prototype._checkOutcome = function() {
            if (this.howMany() > this._canPossiblyFulfill()) {
                for (var e = new AggregateError, i = this.length(); i < this._values.length; ++i) this._values[i] !== CANCELLATION && e.push(this._values[i]);
                return e.length > 0 ? this._reject(e) : this._cancel(), !0;
            }
            return !1;
        }, SomePromiseArray.prototype._fulfilled = function() {
            return this._totalResolved;
        }, SomePromiseArray.prototype._rejected = function() {
            return this._values.length - this.length();
        }, SomePromiseArray.prototype._addRejected = function(reason) {
            this._values.push(reason);
        }, SomePromiseArray.prototype._addFulfilled = function(value) {
            this._values[this._totalResolved++] = value;
        }, SomePromiseArray.prototype._canPossiblyFulfill = function() {
            return this.length() - this._rejected();
        }, SomePromiseArray.prototype._getRangeError = function(count) {
            var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
            return new RangeError(message);
        }, SomePromiseArray.prototype._resolveEmptyArray = function() {
            this._reject(this._getRangeError(0));
        }, Promise.some = function(promises, howMany) {
            return some(promises, howMany);
        }, Promise.prototype.some = function(howMany) {
            return some(this, howMany);
        }, Promise._SomePromiseArray = SomePromiseArray;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL, debug) {
        var util = __webpack_require__(16), TimeoutError = Promise.TimeoutError;
        function HandleWrapper(handle) {
            this.handle = handle;
        }
        HandleWrapper.prototype._resultCancelled = function() {
            clearTimeout(this.handle);
        };
        var afterValue = function(value) {
            return delay(+this).thenReturn(value);
        }, delay = Promise.delay = function(ms, value) {
            var ret, handle;
            return void 0 !== value ? (ret = Promise.resolve(value)._then(afterValue, null, null, ms, void 0), 
            debug.cancellation() && value instanceof Promise && ret._setOnCancel(value)) : (ret = new Promise(INTERNAL), 
            handle = setTimeout((function() {
                ret._fulfill();
            }), +ms), debug.cancellation() && ret._setOnCancel(new HandleWrapper(handle)), ret._captureStackTrace()), 
            ret._setAsyncGuaranteed(), ret;
        };
        function successClear(value) {
            return clearTimeout(this.handle), value;
        }
        function failureClear(reason) {
            throw clearTimeout(this.handle), reason;
        }
        Promise.prototype.delay = function(ms) {
            return delay(ms, this);
        }, Promise.prototype.timeout = function(ms, message) {
            var ret, parent;
            ms = +ms;
            var handleWrapper = new HandleWrapper(setTimeout((function() {
                ret.isPending() && (function(promise, message, parent) {
                    var err;
                    err = "string" != typeof message ? message instanceof Error ? message : new TimeoutError("operation timed out") : new TimeoutError(message), 
                    util.markAsOriginatingFromRejection(err), promise._attachExtraTrace(err), promise._reject(err), 
                    null != parent && parent.cancel();
                })(ret, message, parent);
            }), ms));
            return debug.cancellation() ? (parent = this.then(), (ret = parent._then(successClear, failureClear, void 0, handleWrapper, void 0))._setOnCancel(handleWrapper)) : ret = this._then(successClear, failureClear, void 0, handleWrapper, void 0), 
            ret;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
        var util = __webpack_require__(16), TypeError = __webpack_require__(55).TypeError, inherits = __webpack_require__(16).inherits, errorObj = util.errorObj, tryCatch = util.tryCatch, NULL = {};
        function thrower(e) {
            setTimeout((function() {
                throw e;
            }), 0);
        }
        function dispose(resources, inspection) {
            var i = 0, len = resources.length, ret = new Promise(INTERNAL);
            return (function iterator() {
                if (i >= len) return ret._fulfill();
                var maybePromise = (function(thenable) {
                    var maybePromise = tryConvertToPromise(thenable);
                    return maybePromise !== thenable && "function" == typeof thenable._isDisposable && "function" == typeof thenable._getDisposer && thenable._isDisposable() && maybePromise._setDisposable(thenable._getDisposer()), 
                    maybePromise;
                })(resources[i++]);
                if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                    try {
                        maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                    } catch (e) {
                        return thrower(e);
                    }
                    if (maybePromise instanceof Promise) return maybePromise._then(iterator, thrower, null, null, null);
                }
                iterator();
            })(), ret;
        }
        function Disposer(data, promise, context) {
            this._data = data, this._promise = promise, this._context = context;
        }
        function FunctionDisposer(fn, promise, context) {
            this.constructor$(fn, promise, context);
        }
        function maybeUnwrapDisposer(value) {
            return Disposer.isDisposer(value) ? (this.resources[this.index]._setDisposable(value), 
            value.promise()) : value;
        }
        function ResourceList(length) {
            this.length = length, this.promise = null, this[length - 1] = null;
        }
        Disposer.prototype.data = function() {
            return this._data;
        }, Disposer.prototype.promise = function() {
            return this._promise;
        }, Disposer.prototype.resource = function() {
            return this.promise().isFulfilled() ? this.promise().value() : NULL;
        }, Disposer.prototype.tryDispose = function(inspection) {
            var resource = this.resource(), context = this._context;
            void 0 !== context && context._pushContext();
            var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
            return void 0 !== context && context._popContext(), this._promise._unsetDisposable(), 
            this._data = null, ret;
        }, Disposer.isDisposer = function(d) {
            return null != d && "function" == typeof d.resource && "function" == typeof d.tryDispose;
        }, inherits(FunctionDisposer, Disposer), FunctionDisposer.prototype.doDispose = function(resource, inspection) {
            return this.data().call(resource, resource, inspection);
        }, ResourceList.prototype._resultCancelled = function() {
            for (var len = this.length, i = 0; i < len; ++i) {
                var item = this[i];
                item instanceof Promise && item.cancel();
            }
        }, Promise.using = function() {
            var len = arguments.length;
            if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
            var input, fn = arguments[len - 1];
            if ("function" != typeof fn) return apiRejection("expecting a function but got " + util.classString(fn));
            var spreadArgs = !0;
            2 === len && Array.isArray(arguments[0]) ? (len = (input = arguments[0]).length, 
            spreadArgs = !1) : (input = arguments, len--);
            for (var resources = new ResourceList(len), i = 0; i < len; ++i) {
                var resource = input[i];
                if (Disposer.isDisposer(resource)) {
                    var disposer = resource;
                    (resource = resource.promise())._setDisposable(disposer);
                } else {
                    var maybePromise = tryConvertToPromise(resource);
                    maybePromise instanceof Promise && (resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                        resources: resources,
                        index: i
                    }, void 0));
                }
                resources[i] = resource;
            }
            var reflectedResources = new Array(resources.length);
            for (i = 0; i < reflectedResources.length; ++i) reflectedResources[i] = Promise.resolve(resources[i]).reflect();
            var resultPromise = Promise.all(reflectedResources).then((function(inspections) {
                for (var i = 0; i < inspections.length; ++i) {
                    var inspection = inspections[i];
                    if (inspection.isRejected()) return errorObj.e = inspection.error(), errorObj;
                    if (!inspection.isFulfilled()) return void resultPromise.cancel();
                    inspections[i] = inspection.value();
                }
                promise._pushContext(), fn = tryCatch(fn);
                var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections), promiseCreated = promise._popContext();
                return debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise), 
                ret;
            })), promise = resultPromise.lastly((function() {
                var inspection = new Promise.PromiseInspection(resultPromise);
                return dispose(resources, inspection);
            }));
            return resources.promise = promise, promise._setOnCancel(resources), promise;
        }, Promise.prototype._setDisposable = function(disposer) {
            this._bitField = 131072 | this._bitField, this._disposer = disposer;
        }, Promise.prototype._isDisposable = function() {
            return (131072 & this._bitField) > 0;
        }, Promise.prototype._getDisposer = function() {
            return this._disposer;
        }, Promise.prototype._unsetDisposable = function() {
            this._bitField = -131073 & this._bitField, this._disposer = void 0;
        }, Promise.prototype.disposer = function(fn) {
            if ("function" == typeof fn) return new FunctionDisposer(fn, this, createContext());
            throw new TypeError;
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise) {
        var SomePromiseArray = Promise._SomePromiseArray;
        function any(promises) {
            var ret = new SomePromiseArray(promises), promise = ret.promise();
            return ret.setHowMany(1), ret.setUnwrap(), ret.init(), promise;
        }
        Promise.any = function(promises) {
            return any(promises);
        }, Promise.prototype.any = function() {
            return any(this);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL) {
        var PromiseReduce = Promise.reduce, PromiseAll = Promise.all;
        function promiseAllThis() {
            return PromiseAll(this);
        }
        Promise.prototype.each = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
        }, Promise.prototype.mapSeries = function(fn) {
            return PromiseReduce(this, fn, INTERNAL, INTERNAL);
        }, Promise.each = function(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
        }, Promise.mapSeries = function(promises, fn) {
            return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(Promise, INTERNAL) {
        var PromiseMap = Promise.map;
        Promise.prototype.filter = function(fn, options) {
            return PromiseMap(this, fn, options, INTERNAL);
        }, Promise.filter = function(promises, fn, options) {
            return PromiseMap(promises, fn, options, INTERNAL);
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = {
        Server: __webpack_require__(937),
        Client: __webpack_require__(940),
        Core: __webpack_require__(221)
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    !(function() {
        var inherits = __webpack_require__(0).inherits, EventEmitter = __webpack_require__(5).EventEmitter, constants = __webpack_require__(220), extend = __webpack_require__(147), SSDP = __webpack_require__(221), uuidV4 = __webpack_require__(148), self = function(opts) {
            opts = opts || {}, this.advertisementInterval = opts.advertisementInterval || 1e4, 
            this.description = opts.description || "upnp/desc.php", this.packetTtl = opts.packetTtl || 1800, 
            this.suppressRootDeviceAdvertisement = opts.suppressRootDeviceAdvertisement || !1, 
            this.extraHeaders = opts.headers || {}, this.passive = opts.passiveResponder || !1, 
            this.queryAuthenticator = "function" == typeof opts.queryAuthenticator && opts.queryAuthenticator, 
            this.usns = [], this.location = opts.location || "http://127.0.0.1/upnp/desc.html", 
            this.udn = opts.udn || "uuid:" + uuidV4(), this.suppressRootDeviceAdvertisement || (this.usns[this.udn] = this.udn), 
            opts.bindPort = 1900, this.ssdp = new SSDP(opts), this.timer = !1;
        };
        inherits(self, EventEmitter), self.prototype.start = function() {
            var that = this;
            this.ssdp.on("start", (function() {
                that.emit("start", !0), that.timer = setInterval((function() {
                    that.advertise();
                }), that.advertisementInterval), that.advertise();
            })), this.ssdp.on("delay", (function(obj) {
                that.emit("delay", obj);
            })), this.ssdp.on("error", (function(err) {
                that.emit("error", {
                    type: "ssdp",
                    error: err
                });
            })), this.ssdp.on("msearch", (function(headers, statusCode, rinfo) {
                that.emit("msearch", headers, statusCode, rinfo), that.respondToSearch(headers.ST, rinfo);
            })), this.ssdp.on("send", (function(msg, ip, port) {
                that.emit("send", msg, ip, port);
            })), this.ssdp.start();
        }, self.prototype.stop = function() {
            this.timer && clearInterval(this.timer), this.ssdp.stop();
        }, self.prototype.advertise = function(service) {
            if (!this.timer) {
                var that = this;
                this.on("start", (function() {
                    that.advertise(service);
                })), this.start();
            }
            if (service && this.addUSN(service), !this.passive) for (var usn in this.usns) {
                var udn = this.usns[usn], nts = constants.alive, headers = {
                    HOST: this.ssdp.host,
                    NT: usn,
                    NTS: nts,
                    USN: udn,
                    LOCATION: this.location,
                    "CACHE-CONTROL": "max-age=" + this.packetTtl,
                    SERVER: this.ssdp.sig
                };
                extend(headers, this.extraHeaders);
                var message = this.ssdp.getSSDPHeader(constants.notify, headers);
                this.ssdp.send(new Buffer(message)), this.emit("advertise", message);
            }
        }, self.prototype.addUSN = function(device) {
            this.usns[device] = this.udn + "::" + device;
        }, self.prototype.respondToSearch = function(serviceType, rinfo) {
            var acceptor, stRegex, peer = {
                address: rinfo.address,
                port: rinfo.port
            };
            if (!this.queryAuthenticator || this.queryAuthenticator(serviceType, rinfo)) for (var usn in '"' === serviceType[0] && '"' === serviceType[serviceType.length - 1] && (serviceType = serviceType.slice(1, -1)), 
            this.allowWildcards ? (stRegex = new RegExp(serviceType.replace(/\*/g, ".*") + "$"), 
            acceptor = function(usn, serviceType) {
                return serviceType === constants.all || stRegex.test(usn);
            }) : acceptor = function(usn, serviceType) {
                return serviceType === constants.all || usn === serviceType;
            }, this.usns) {
                var udn = this.usns[usn];
                if (this.allowWildcards && (udn = udn.replace(stRegex, serviceType)), acceptor(usn, serviceType)) {
                    var pkt = this.ssdp.getSSDPHeader("200 OK", extend({
                        ST: serviceType === constants.all ? usn : serviceType,
                        USN: udn,
                        LOCATION: this.location,
                        "CACHE-CONTROL": "max-age=" + this.packetTtl,
                        DATE: (new Date).toUTCString(),
                        SERVER: this.sig,
                        EXT: ""
                    }, this.extraHeaders), !0);
                    this.emit("respondToSearch", peer.addr, peer.port);
                    var message = new Buffer(pkt);
                    this.ssdp.send(message, peer.address, peer.port);
                }
            }
        }, module.exports = self;
    })();
}, function(module, exports, __webpack_require__) {
    var crypto = __webpack_require__(9);
    module.exports = function() {
        return crypto.randomBytes(16);
    };
}, function(module, exports) {
    for (var byteToHex = [], i = 0; i < 256; ++i) byteToHex[i] = (i + 256).toString(16).substr(1);
    module.exports = function(buf, offset) {
        var i = offset || 0, bth = byteToHex;
        return [ bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]] ].join("");
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    !(function() {
        var inherits = __webpack_require__(0).inherits, EventEmitter = __webpack_require__(5).EventEmitter, constants = __webpack_require__(220), SSDP = __webpack_require__(221), self = function(opts) {
            opts = opts || {}, this.searchInterval = opts.searchInterval || 1e4, this.ssdp = new SSDP(opts), 
            this.timer = !1;
        };
        inherits(self, EventEmitter), self.prototype.start = function() {
            var that = this;
            this.ssdp.on("start", (function() {
                that.emit("start", !0);
            })), this.ssdp.on("delay", (function(obj) {
                that.emit("delay", obj);
            })), this.ssdp.on("error", (function(err) {
                that.emit("error", {
                    type: "ssdp",
                    error: err
                });
            })), this.ssdp.on("bind", (function(socket) {
                that.emit("bind", socket);
            })), this.ssdp.on("response", (function(headers, statusCode, rinfo) {
                that.processResponse(headers, statusCode, rinfo);
            })), this.ssdp.on("send", (function(msg, ip, port) {
                that.emit("send", msg, ip, port);
            })), this.ssdp.start();
        }, self.prototype.stop = function() {
            this.timer && clearInterval(this.timer), this.ssdp.stop();
        }, self.prototype.browse = function(serviceType) {
            var that = this;
            if (!this.ssdp.running) return this.on("start", (function() {
                that.browse(serviceType);
            })), this.start();
            var pkt = this.ssdp.getSSDPHeader(constants.msearch, {
                HOST: this.ssdp.host,
                ST: serviceType,
                MAN: '"ssdp:discover"',
                MX: 3
            }), message = new Buffer(pkt), search = function() {
                that.emit("msearch", message), that.ssdp.send(message);
            };
            search(), this.timer = setInterval((function() {
                search();
            }), this.searchInterval);
        }, self.prototype.processResponse = function(headers, statusCode, rInfo) {
            this.emit("response", {
                headers: headers,
                statusCode: statusCode,
                referrer: rInfo
            });
        }, module.exports = self;
    })();
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(444);
    var castingUtils = __webpack_require__(218), querystring = __webpack_require__(28), Promise = __webpack_require__(219), Client = __webpack_require__(942).Client, util = __webpack_require__(0), Player = __webpack_require__(447);
    function ChromecastClient(device, executables) {
        Player.call(this, device), this.audio = {
            tracks: [],
            currentTrack: null
        }, this.seekTime = 0, this.stateFlags = 1, this.msgId = 0, this.sessionHeartbeat = null, 
        this.sessionStatus = null, this.mediaSender = null, this.mediaReceiver = null, this.mediaSessionStatus = {}, 
        this.executables = executables, this.device = device, this._conformStatus = this._conformStatus.bind(this), 
        this.client = new Client, this.client.on("error", (function(err) {
            console.log("ChromeCast client error", err);
        }));
    }
    util.inherits(ChromecastClient, Player), ChromecastClient.APP_ID = "74B9F456", ChromecastClient.MESSAGE_TIMEOUT = 5e3, 
    ChromecastClient.PLAYBACK_DELAY = 4e3, ChromecastClient.DEFAULT_SENDER = "sender-0", 
    ChromecastClient.DEFAULT_RECEIVER = "receiver-0", ChromecastClient.channelsNS = {
        connection: "urn:x-cast:com.google.cast.tp.connection",
        heartbeat: "urn:x-cast:com.google.cast.tp.heartbeat",
        receiver: "urn:x-cast:com.google.cast.receiver",
        media: "urn:x-cast:com.google.cast.media"
    }, ChromecastClient.mapState = function(statusText) {
        return {
            "Ready To Cast": 6,
            BUFFERING: 2,
            PLAYING: 3,
            PAUSED: 4,
            STOPPED: 5,
            NO_MEDIA_PRESENT: 6,
            ERROR_OCCURRED: 7
        }[statusText];
    }, ChromecastClient.prototype.request = function(ns, msg, sender, receiver) {
        sender = sender || ChromecastClient.DEFAULT_SENDER, receiver = receiver || ChromecastClient.DEFAULT_RECEIVER, 
        this.client.send(sender, receiver, ns, JSON.stringify(msg));
    }, ChromecastClient.prototype.requestResponse = function(ns, msg, sender, receiver) {
        var self = this;
        return sender = sender || ChromecastClient.DEFAULT_SENDER, receiver = receiver || ChromecastClient.DEFAULT_RECEIVER, 
        new Promise((function(resolve, reject) {
            var messageTimeout = setTimeout((function() {
                self.client.removeListener("message", getMessage), reject("Response timeout for " + ns + " with session ID: " + receiver);
            }), ChromecastClient.MESSAGE_TIMEOUT);
            if ("PING" !== msg.type) {
                var requestId = ++self.msgId;
                msg.requestId = requestId;
            }
            function getMessage(sourceId, destinationId, namespace, data) {
                if (sourceId == receiver && (destinationId === sender || "*" === destinationId) && namespace === ns) {
                    var response = JSON.parse(data);
                    if ("PONG" === response.type || response.requestId === requestId) return self.client.removeListener("message", getMessage), 
                    clearTimeout(messageTimeout), "INVALID_REQUEST" === response.type ? reject("Invalid request: " + response.reason) : resolve(response);
                }
            }
            self.client.on("message", getMessage), self.request(ns, msg, sender, receiver);
        }));
    }, ChromecastClient.prototype._disconnect = function() {
        this.client.socket && (this.request(ChromecastClient.channelsNS.connection, {
            type: "CLOSE"
        }), this.client.close());
    }, ChromecastClient.prototype._connect = function() {
        var self = this;
        return this.client.ps ? self.requestResponse(ChromecastClient.channelsNS.receiver, {
            type: "GET_STATUS"
        }) : (this._disconnect(), new Promise((function(resolve, reject) {
            self.client.connect(self.device.host, (function() {
                self.request(ChromecastClient.channelsNS.connection, {
                    type: "CONNECT"
                }), heartbeat(), self.requestResponse(ChromecastClient.channelsNS.receiver, {
                    type: "GET_STATUS"
                }).then(resolve);
            }));
        })));
        function heartbeat() {
            self.client.ps ? self.requestResponse(ChromecastClient.channelsNS.heartbeat, {
                type: "PING"
            }).then((function(pong) {
                setTimeout(heartbeat, 5e3);
            })).catch((function(err) {
                console.log("heartbeat error", err);
            })) : console.log("Heart stops.");
        }
    }, ChromecastClient.prototype._connectMedia = function() {
        var self = this;
        return this.mediaSender = "client-" + Math.floor(1e6 * Math.random()), this.mediaReceiver = this.sessionStatus.applications[0].sessionId, 
        this.request(ChromecastClient.channelsNS.connection, {
            type: "CONNECT"
        }, this.mediaSender, this.mediaReceiver), this.requestResponse(ChromecastClient.channelsNS.media, {
            type: "GET_STATUS"
        }, this.mediaSender, this.mediaReceiver).catch((function(err) {
            return console.log("!MediaSessionEerror", err), {
                status: [ {
                    error: err
                } ]
            };
        })).then((function(res) {
            res.status && res.status[0] && (self.mediaSessionStatus = res.status[0] || {});
        }));
    }, ChromecastClient.prototype.init = function() {
        var self = this;
        return this.mediaSessionStatus = {}, this._connect().then((function(res) {
            return res.status && res.status.applications && res.status.applications[0].appId === ChromecastClient.APP_ID ? res : self.requestResponse(ChromecastClient.channelsNS.receiver, {
                type: "LAUNCH",
                appId: ChromecastClient.APP_ID
            });
        })).then((function(res) {
            self.sessionStatus = res.status;
        }));
    }, ChromecastClient.prototype._conformStatus = function(status) {
        (status = status || {}).status && (status = status.status);
        var conformedStatus = this.mediaStatus;
        if (status.volume && !conformedStatus.volume && (conformedStatus.volume = status.volume.level), 
        status.applications && status.applications[0]) {
            var app = status.applications[0];
            conformedStatus.state = ChromecastClient.mapState(app.statusText);
        }
        return status.playerState && (conformedStatus.state = ChromecastClient.mapState(status.playerState)), 
        6 == conformedStatus.state && this.stateFlags && (conformedStatus.state = 5), conformedStatus.paused = 4 == conformedStatus.state, 
        status.currentTime && (conformedStatus.time = 1e3 * status.currentTime), conformedStatus;
    }, ChromecastClient.prototype._subsPrepare = function(subsURL, offset, style) {
        return {
            trackId: 1,
            trackContentId: subsURL = subsURL ? this.endpoint + "/subtitles.srt?from=" + encodeURIComponent(subsURL) : "",
            trackContentType: "text/vtt",
            type: "TEXT",
            subtype: "SUBTITLES",
            offset: parseFloat(offset, 10) || 0,
            style: style || null
        };
    }, ChromecastClient.prototype.middleware = function(req, res, next) {
        return this.setEndpoint(req), this.transcodeURL = this.endpoint + req.baseUrl + "/transcode", 
        Player.prototype.middleware.call(this, req, res, next);
    }, ChromecastClient.prototype.status = function() {
        var self = this;
        return this._connectMedia().then((function() {
            return self.mediaStatus.volume = 0, self.mediaStatus.audio = self.audio.tracks, 
            self.mediaStatus.audioTrack = self.audio.currentTrack, self._conformStatus(self.sessionStatus), 
            self._conformStatus(self.mediaSessionStatus), self.mediaStatus;
        }));
    }, ChromecastClient.prototype._mediaRequest = function(data) {
        var self = this;
        return this._connectMedia().then((function() {
            return self.mediaSessionStatus.mediaSessionId && (data.mediaSessionId = self.mediaSessionStatus.mediaSessionId), 
            self.requestResponse(ChromecastClient.channelsNS.media, data, self.mediaSender, self.mediaReceiver);
        })).then(this._conformStatus);
    }, ChromecastClient.prototype.playFromStatus = function() {
        if (clearTimeout(this.deferedPlay), !this.mediaStatus.source) return Promise.reject("No source!");
        this.mediaStatus.time = parseInt(this.mediaStatus.time, 10);
        var media = {
            contentId: this.transcodeURL + "?" + querystring.stringify({
                video: this.mediaStatus.source,
                audioTrack: this.audio.currentTrack,
                time: this.seekTime
            }),
            streamType: "BUFFERED",
            contentType: "video/x-matroska",
            metadata: {
                seekTime: this.seekTime,
                duration: this.mediaStatus.length,
                type: 1,
                metadataType: 1
            },
            tracks: []
        };
        return this.mediaStatus.subtitlesSrc && media.tracks.push(this._subsPrepare(this.mediaStatus.subtitlesSrc, this.mediaStatus.subtitlesDelay, {
            fontSize: parseInt(this.mediaStatus.subtitlesSize, 10) + 1 + "vw"
        })), this._mediaRequest({
            type: "LOAD",
            media: media,
            autoplay: !0,
            currentTime: 0,
            activeTrackIds: [],
            repeatMode: "REPEAT_OFF"
        });
    }, ChromecastClient.prototype.play = function(srcURL) {
        this.seekTime = 0, this.mediaStatus.source = srcURL, this.mediaStatus.time = 0, 
        this.mediaStatus.subtitlesSrc = null, this.mediaStatus.subtitlesDelay = 0;
        var self = this;
        return castingUtils.getVideoInfo(this.executables.ffmpeg, srcURL).then((function(info) {
            return self.audio.tracks = info.streams.filter((function(stream) {
                return "Audio" === stream.type;
            })), self.audio.currentTrack = (self.audio[0] || {}).id, self.mediaStatus.length = 1e3 * info.duration, 
            self.stateFlags = 0, self.status().then((function(status) {
                return status.state = 3, self.deferedPlay = setTimeout((function() {
                    self.playFromStatus();
                }), ChromecastClient.PLAYBACK_DELAY), status;
            }));
        }));
    }, ChromecastClient.prototype.audioTrack = function(audioTrack, offset) {
        return offset && console.log("Audio track offset is not implemented yet"), 3 != this.mediaStatus.state ? Promise.resolve() : (this.audio.currentTrack = audioTrack, 
        this.playFromStatus());
    }, ChromecastClient.prototype.subtitles = function(subsURL, offset, style) {
        this.mediaStatus.subtitlesSrc = subsURL, this.mediaStatus.subtitlesDelay = offset;
        var subs = this._subsPrepare(subsURL, offset, style);
        return this._mediaRequest(subs);
    }, ChromecastClient.prototype.resume = function() {
        return this._mediaRequest({
            type: "PLAY"
        });
    }, ChromecastClient.prototype.pause = function() {
        return this._mediaRequest({
            type: "PAUSE"
        });
    }, ChromecastClient.prototype.stop = function() {
        return this.close();
    }, ChromecastClient.prototype.seek = function(time) {
        return 3 != this.mediaStatus.state ? Promise.resolve() : (this.seekTime = parseInt(time, 10) / 1e3 || 0, 
        this.playFromStatus());
    }, ChromecastClient.prototype.volume = function(vol) {
        return this.requestResponse(ChromecastClient.channelsNS.receiver, {
            type: "SET_VOLUME",
            volume: {
                level: parseFloat(vol, 10)
            }
        }).then(this._conformStatus);
    }, ChromecastClient.prototype.close = function() {
        var self = this;
        return this.stateFlags = 1, this.requestResponse(ChromecastClient.channelsNS.receiver, {
            type: "STOP",
            sessionId: this.sessionStatus.applications[0].sessionId
        }).then((function() {
            self._disconnect();
        }));
    }, module.exports = ChromecastClient;
}, function(module, exports, __webpack_require__) {
    var Client = __webpack_require__(943), Server = __webpack_require__(950), DeviceAuthMessage = __webpack_require__(222).DeviceAuthMessage;
    module.exports.Client = Client, module.exports.Server = Server, module.exports.DeviceAuthMessage = DeviceAuthMessage;
}, function(module, exports, __webpack_require__) {
    var EventEmitter = __webpack_require__(5).EventEmitter, util = __webpack_require__(0), tls = __webpack_require__(92), debug = __webpack_require__(8)("castv2"), protocol = __webpack_require__(222), PacketStreamWrapper = __webpack_require__(446), Channel = __webpack_require__(949), CastMessage = protocol.CastMessage;
    function Client() {
        EventEmitter.call(this), this.socket = null, this.ps = null;
    }
    util.inherits(Client, EventEmitter), Client.prototype.connect = function(options, callback) {
        var self = this;
        function onerror(err) {
            debug("error: %s %j", err.message, err), self.emit("error", err);
        }
        function onpacket(buf) {
            var message = CastMessage.parse(buf);
            if (debug("recv message: protocolVersion=%s sourceId=%s destinationId=%s namespace=%s data=%s", message.protocol_version, message.source_id, message.destination_id, message.namespace, 1 === message.payload_type ? util.inspect(message.payload_binary) : message.payload_utf8), 
            0 !== message.protocol_version) return self.emit("error", new Error("Unsupported protocol version: " + message.protocol_version)), 
            void self.close();
            self.emit("message", message.source_id, message.destination_id, message.namespace, 1 === message.payload_type ? message.payload_binary : message.payload_utf8);
        }
        "string" == typeof options && (options = {
            host: options
        }), options.port = options.port || 8009, options.rejectUnauthorized = !1, callback && this.once("connect", callback), 
        debug("connecting to %s:%d ...", options.host, options.port), this.socket = tls.connect(options, (function() {
            self.ps = new PacketStreamWrapper(self.socket), self.ps.on("packet", onpacket), 
            debug("connected"), self.emit("connect");
        })), this.socket.on("error", onerror), this.socket.once("close", (function() {
            debug("connection closed"), self.socket.removeListener("error", onerror), self.socket = null, 
            self.ps && (self.ps.removeListener("packet", onpacket), self.ps = null), self.emit("close");
        }));
    }, Client.prototype.close = function() {
        debug("closing connection ..."), this.socket.destroy();
    }, Client.prototype.send = function(sourceId, destinationId, namespace, data) {
        var message = {
            protocol_version: 0,
            source_id: sourceId,
            destination_id: destinationId,
            namespace: namespace
        };
        Buffer.isBuffer(data) ? (message.payload_type = 1, message.payload_binary = data) : (message.payload_type = 0, 
        message.payload_utf8 = data), debug("send message: protocolVersion=%s sourceId=%s destinationId=%s namespace=%s data=%s", message.protocol_version, message.source_id, message.destination_id, message.namespace, 1 === message.payload_type ? util.inspect(message.payload_binary) : message.payload_utf8);
        var buf = CastMessage.serialize(message);
        this.ps.send(buf);
    }, Client.prototype.createChannel = function(sourceId, destinationId, namespace, encoding) {
        return new Channel(this, sourceId, destinationId, namespace, encoding);
    }, module.exports = Client;
}, function(module, exports, __webpack_require__) {
    var ProtoBuf = __webpack_require__(945);
    module.exports = ProtoBuf;
}, function(module, exports, __webpack_require__) {
    (function(module) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        !(function(global) {
            "use strict";
            function init(ByteBuffer) {
                var ProtoBuf = {
                    VERSION: "3.8.2",
                    WIRE_TYPES: {}
                };
                return ProtoBuf.WIRE_TYPES.VARINT = 0, ProtoBuf.WIRE_TYPES.BITS64 = 1, ProtoBuf.WIRE_TYPES.LDELIM = 2, 
                ProtoBuf.WIRE_TYPES.STARTGROUP = 3, ProtoBuf.WIRE_TYPES.ENDGROUP = 4, ProtoBuf.WIRE_TYPES.BITS32 = 5, 
                ProtoBuf.PACKABLE_WIRE_TYPES = [ ProtoBuf.WIRE_TYPES.VARINT, ProtoBuf.WIRE_TYPES.BITS64, ProtoBuf.WIRE_TYPES.BITS32 ], 
                ProtoBuf.TYPES = {
                    int32: {
                        name: "int32",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    uint32: {
                        name: "uint32",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    sint32: {
                        name: "sint32",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    int64: {
                        name: "int64",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    uint64: {
                        name: "uint64",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    sint64: {
                        name: "sint64",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    bool: {
                        name: "bool",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    double: {
                        name: "double",
                        wireType: ProtoBuf.WIRE_TYPES.BITS64
                    },
                    string: {
                        name: "string",
                        wireType: ProtoBuf.WIRE_TYPES.LDELIM
                    },
                    bytes: {
                        name: "bytes",
                        wireType: ProtoBuf.WIRE_TYPES.LDELIM
                    },
                    fixed32: {
                        name: "fixed32",
                        wireType: ProtoBuf.WIRE_TYPES.BITS32
                    },
                    sfixed32: {
                        name: "sfixed32",
                        wireType: ProtoBuf.WIRE_TYPES.BITS32
                    },
                    fixed64: {
                        name: "fixed64",
                        wireType: ProtoBuf.WIRE_TYPES.BITS64
                    },
                    sfixed64: {
                        name: "sfixed64",
                        wireType: ProtoBuf.WIRE_TYPES.BITS64
                    },
                    float: {
                        name: "float",
                        wireType: ProtoBuf.WIRE_TYPES.BITS32
                    },
                    enum: {
                        name: "enum",
                        wireType: ProtoBuf.WIRE_TYPES.VARINT
                    },
                    message: {
                        name: "message",
                        wireType: ProtoBuf.WIRE_TYPES.LDELIM
                    },
                    group: {
                        name: "group",
                        wireType: ProtoBuf.WIRE_TYPES.STARTGROUP
                    }
                }, ProtoBuf.ID_MIN = 1, ProtoBuf.ID_MAX = 536870911, ProtoBuf.ByteBuffer = ByteBuffer, 
                ProtoBuf.Long = ByteBuffer.Long || null, ProtoBuf.convertFieldsToCamelCase = !1, 
                ProtoBuf.populateAccessors = !0, ProtoBuf.Util = (function() {
                    Object.create || (Object.create = function(o) {
                        if (arguments.length > 1) throw Error("Object.create polyfill only accepts the first parameter.");
                        function F() {}
                        return F.prototype = o, new F;
                    });
                    var Util = {
                        IS_NODE: !1
                    };
                    try {
                        Util.IS_NODE = "function" == typeof __webpack_require__(2).readFileSync && "function" == typeof __webpack_require__(4).resolve;
                    } catch (e) {}
                    return Util.XHR = function() {
                        for (var XMLHttpFactories = [ function() {
                            return new XMLHttpRequest;
                        }, function() {
                            return new ActiveXObject("Msxml2.XMLHTTP");
                        }, function() {
                            return new ActiveXObject("Msxml3.XMLHTTP");
                        }, function() {
                            return new ActiveXObject("Microsoft.XMLHTTP");
                        } ], xhr = null, i = 0; i < XMLHttpFactories.length; i++) {
                            try {
                                xhr = XMLHttpFactories[i]();
                            } catch (e) {
                                continue;
                            }
                            break;
                        }
                        if (!xhr) throw Error("XMLHttpRequest is not supported");
                        return xhr;
                    }, Util.fetch = function(path, callback) {
                        if (callback && "function" != typeof callback && (callback = null), Util.IS_NODE) if (callback) __webpack_require__(2).readFile(path, (function(err, data) {
                            callback(err ? null : "" + data);
                        })); else try {
                            return __webpack_require__(2).readFileSync(path);
                        } catch (e) {
                            return null;
                        } else {
                            var xhr = Util.XHR();
                            if (xhr.open("GET", path, !!callback), xhr.setRequestHeader("Accept", "text/plain"), 
                            "function" == typeof xhr.overrideMimeType && xhr.overrideMimeType("text/plain"), 
                            !callback) return xhr.send(null), 200 == xhr.status || 0 == xhr.status && "string" == typeof xhr.responseText ? xhr.responseText : null;
                            if (xhr.onreadystatechange = function() {
                                4 == xhr.readyState && (200 == xhr.status || 0 == xhr.status && "string" == typeof xhr.responseText ? callback(xhr.responseText) : callback(null));
                            }, 4 == xhr.readyState) return;
                            xhr.send(null);
                        }
                    }, Util.isArray = Array.isArray || function(obj) {
                        return "[object Array]" === Object.prototype.toString.call(obj);
                    }, Util;
                })(), ProtoBuf.Lang = {
                    OPEN: "{",
                    CLOSE: "}",
                    OPTOPEN: "[",
                    OPTCLOSE: "]",
                    OPTEND: ",",
                    EQUAL: "=",
                    END: ";",
                    STRINGOPEN: '"',
                    STRINGCLOSE: '"',
                    STRINGOPEN_SQ: "'",
                    STRINGCLOSE_SQ: "'",
                    COPTOPEN: "(",
                    COPTCLOSE: ")",
                    DELIM: /[\s\{\}=;\[\],'"\(\)]/g,
                    RULE: /^(?:required|optional|repeated)$/,
                    TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
                    NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
                    TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
                    TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
                    FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
                    NUMBER: /^-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+|([0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?))$/,
                    NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
                    NUMBER_HEX: /^0x[0-9a-fA-F]+$/,
                    NUMBER_OCT: /^0[0-7]+$/,
                    NUMBER_FLT: /^[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?$/,
                    ID: /^(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
                    NEGID: /^\-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/,
                    WHITESPACE: /\s/,
                    STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
                    BOOL: /^(?:true|false)$/i
                }, ProtoBuf.DotProto = (function(ProtoBuf, Lang) {
                    var DotProto = {}, Tokenizer = function(proto) {
                        this.source = "" + proto, this.index = 0, this.line = 1, this.stack = [], this.readingString = !1, 
                        this.stringEndsWith = Lang.STRINGCLOSE;
                    }, TokenizerPrototype = Tokenizer.prototype;
                    TokenizerPrototype._readString = function() {
                        var match;
                        if (Lang.STRING.lastIndex = this.index - 1, null !== (match = Lang.STRING.exec(this.source))) {
                            var s = void 0 !== match[1] ? match[1] : match[2];
                            return this.index = Lang.STRING.lastIndex, this.stack.push(this.stringEndsWith), 
                            s;
                        }
                        throw Error("Unterminated string at line " + this.line + ", index " + this.index);
                    }, TokenizerPrototype.next = function() {
                        if (this.stack.length > 0) return this.stack.shift();
                        if (this.index >= this.source.length) return null;
                        if (this.readingString) return this.readingString = !1, this._readString();
                        var repeat, last;
                        do {
                            for (repeat = !1; Lang.WHITESPACE.test(last = this.source.charAt(this.index)); ) if (this.index++, 
                            "\n" === last && this.line++, this.index === this.source.length) return null;
                            if ("/" === this.source.charAt(this.index)) if ("/" === this.source.charAt(++this.index)) {
                                for (;"\n" !== this.source.charAt(this.index); ) if (this.index++, this.index == this.source.length) return null;
                                this.index++, this.line++, repeat = !0;
                            } else {
                                if ("*" !== this.source.charAt(this.index)) throw Error("Unterminated comment at line " + this.line + ": /" + this.source.charAt(this.index));
                                for (last = ""; last + (last = this.source.charAt(this.index)) !== "*/"; ) if (this.index++, 
                                "\n" === last && this.line++, this.index === this.source.length) return null;
                                this.index++, repeat = !0;
                            }
                        } while (repeat);
                        if (this.index === this.source.length) return null;
                        var end = this.index;
                        if (Lang.DELIM.lastIndex = 0, Lang.DELIM.test(this.source.charAt(end))) ++end; else for (++end; end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)); ) end++;
                        var token = this.source.substring(this.index, this.index = end);
                        return token === Lang.STRINGOPEN ? (this.readingString = !0, this.stringEndsWith = Lang.STRINGCLOSE) : token === Lang.STRINGOPEN_SQ && (this.readingString = !0, 
                        this.stringEndsWith = Lang.STRINGCLOSE_SQ), token;
                    }, TokenizerPrototype.peek = function() {
                        if (0 === this.stack.length) {
                            var token = this.next();
                            if (null === token) return null;
                            this.stack.push(token);
                        }
                        return this.stack[0];
                    }, TokenizerPrototype.toString = function() {
                        return "Tokenizer(" + this.index + "/" + this.source.length + " at line " + this.line + ")";
                    }, DotProto.Tokenizer = Tokenizer;
                    var Parser = function(proto) {
                        this.tn = new Tokenizer(proto);
                    }, ParserPrototype = Parser.prototype;
                    return ParserPrototype.parse = function() {
                        for (var token, topLevel = {
                            name: "[ROOT]",
                            package: null,
                            messages: [],
                            enums: [],
                            imports: [],
                            options: {},
                            services: []
                        }, head = !0; token = this.tn.next(); ) switch (token) {
                          case "package":
                            if (!head || null !== topLevel.package) throw Error("Unexpected package at line " + this.tn.line);
                            topLevel.package = this._parsePackage(token);
                            break;

                          case "import":
                            if (!head) throw Error("Unexpected import at line " + this.tn.line);
                            topLevel.imports.push(this._parseImport(token));
                            break;

                          case "message":
                            this._parseMessage(topLevel, null, token), head = !1;
                            break;

                          case "enum":
                            this._parseEnum(topLevel, token), head = !1;
                            break;

                          case "option":
                            if (!head) throw Error("Unexpected option at line " + this.tn.line);
                            this._parseOption(topLevel, token);
                            break;

                          case "service":
                            this._parseService(topLevel, token);
                            break;

                          case "extend":
                            this._parseExtend(topLevel, token);
                            break;

                          case "syntax":
                            this._parseIgnoredStatement(topLevel, token);
                            break;

                          default:
                            throw Error("Unexpected token at line " + this.tn.line + ": " + token);
                        }
                        return delete topLevel.name, topLevel;
                    }, ParserPrototype._parseNumber = function(val) {
                        var sign = 1;
                        if ("-" == val.charAt(0) && (sign = -1, val = val.substring(1)), Lang.NUMBER_DEC.test(val)) return sign * parseInt(val, 10);
                        if (Lang.NUMBER_HEX.test(val)) return sign * parseInt(val.substring(2), 16);
                        if (Lang.NUMBER_OCT.test(val)) return sign * parseInt(val.substring(1), 8);
                        if (Lang.NUMBER_FLT.test(val)) return sign * parseFloat(val);
                        throw Error("Illegal number at line " + this.tn.line + ": " + (sign < 0 ? "-" : "") + val);
                    }, ParserPrototype._parseString = function() {
                        var token, value = "";
                        do {
                            if (token = this.tn.next(), value += this.tn.next(), (token = this.tn.next()) !== this.tn.stringEndsWith) throw Error("Illegal end of string at line " + this.tn.line + ": " + token);
                            token = this.tn.peek();
                        } while (token === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ);
                        return value;
                    }, ParserPrototype._parseId = function(val, neg) {
                        var id = -1, sign = 1;
                        if ("-" == val.charAt(0) && (sign = -1, val = val.substring(1)), Lang.NUMBER_DEC.test(val)) id = parseInt(val); else if (Lang.NUMBER_HEX.test(val)) id = parseInt(val.substring(2), 16); else {
                            if (!Lang.NUMBER_OCT.test(val)) throw Error("Illegal id at line " + this.tn.line + ": " + (sign < 0 ? "-" : "") + val);
                            id = parseInt(val.substring(1), 8);
                        }
                        if (id = sign * id | 0, !neg && id < 0) throw Error("Illegal id at line " + this.tn.line + ": " + (sign < 0 ? "-" : "") + val);
                        return id;
                    }, ParserPrototype._parsePackage = function(token) {
                        if (token = this.tn.next(), !Lang.TYPEREF.test(token)) throw Error("Illegal package name at line " + this.tn.line + ": " + token);
                        var pkg = token;
                        if ((token = this.tn.next()) != Lang.END) throw Error("Illegal end of package at line " + this.tn.line + ": " + token);
                        return pkg;
                    }, ParserPrototype._parseImport = function(token) {
                        if ("public" === (token = this.tn.peek()) && (this.tn.next(), token = this.tn.peek()), 
                        token !== Lang.STRINGOPEN && token !== Lang.STRINGOPEN_SQ) throw Error("Illegal start of import at line " + this.tn.line + ": " + token);
                        var imported = this._parseString();
                        if ((token = this.tn.next()) !== Lang.END) throw Error("Illegal end of import at line " + this.tn.line + ": " + token);
                        return imported;
                    }, ParserPrototype._parseOption = function(parent, token) {
                        var custom = !1;
                        if ((token = this.tn.next()) == Lang.COPTOPEN && (custom = !0, token = this.tn.next()), 
                        !Lang.TYPEREF.test(token) && !/google\.protobuf\./.test(token)) throw Error("Illegal option name in message " + parent.name + " at line " + this.tn.line + ": " + token);
                        var value, name = token;
                        if (token = this.tn.next(), custom) {
                            if (token !== Lang.COPTCLOSE) throw Error("Illegal end in message " + parent.name + ", option " + name + " at line " + this.tn.line + ": " + token);
                            name = "(" + name + ")", token = this.tn.next(), Lang.FQTYPEREF.test(token) && (name += token, 
                            token = this.tn.next());
                        }
                        if (token !== Lang.EQUAL) throw Error("Illegal operator in message " + parent.name + ", option " + name + " at line " + this.tn.line + ": " + token);
                        if ((token = this.tn.peek()) === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) value = this._parseString(); else if (this.tn.next(), 
                        Lang.NUMBER.test(token)) value = this._parseNumber(token, !0); else if (Lang.BOOL.test(token)) value = "true" === token; else {
                            if (!Lang.TYPEREF.test(token)) throw Error("Illegal option value in message " + parent.name + ", option " + name + " at line " + this.tn.line + ": " + token);
                            value = token;
                        }
                        if ((token = this.tn.next()) !== Lang.END) throw Error("Illegal end of option in message " + parent.name + ", option " + name + " at line " + this.tn.line + ": " + token);
                        parent.options[name] = value;
                    }, ParserPrototype._parseIgnoredStatement = function(parent, keyword) {
                        for (var token; ;) {
                            if (null === (token = this.tn.next())) throw Error("Unexpected EOF in " + parent.name + ", " + keyword + " at line " + this.tn.line);
                            if (token === Lang.END) break;
                        }
                    }, ParserPrototype._parseService = function(parent, token) {
                        if (token = this.tn.next(), !Lang.NAME.test(token)) throw Error("Illegal service name at line " + this.tn.line + ": " + token);
                        var name = token, svc = {
                            name: name,
                            rpc: {},
                            options: {}
                        };
                        if ((token = this.tn.next()) !== Lang.OPEN) throw Error("Illegal start of service " + name + " at line " + this.tn.line + ": " + token);
                        do {
                            if ("option" === (token = this.tn.next())) this._parseOption(svc, token); else if ("rpc" === token) this._parseServiceRPC(svc, token); else if (token !== Lang.CLOSE) throw Error("Illegal type of service " + name + " at line " + this.tn.line + ": " + token);
                        } while (token !== Lang.CLOSE);
                        parent.services.push(svc);
                    }, ParserPrototype._parseServiceRPC = function(svc, token) {
                        var type = token;
                        if (token = this.tn.next(), !Lang.NAME.test(token)) throw Error("Illegal method name in service " + svc.name + " at line " + this.tn.line + ": " + token);
                        var name = token, method = {
                            request: null,
                            response: null,
                            options: {}
                        };
                        if ((token = this.tn.next()) !== Lang.COPTOPEN) throw Error("Illegal start of request type in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        if (token = this.tn.next(), !Lang.TYPEREF.test(token)) throw Error("Illegal request type in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        if (method.request = token, (token = this.tn.next()) != Lang.COPTCLOSE) throw Error("Illegal end of request type in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        if ("returns" !== (token = this.tn.next()).toLowerCase()) throw Error("Illegal delimiter in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        if ((token = this.tn.next()) != Lang.COPTOPEN) throw Error("Illegal start of response type in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        if (token = this.tn.next(), method.response = token, (token = this.tn.next()) !== Lang.COPTCLOSE) throw Error("Illegal end of response type in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        if ((token = this.tn.next()) === Lang.OPEN) {
                            do {
                                if ("option" === (token = this.tn.next())) this._parseOption(method, token); else if (token !== Lang.CLOSE) throw Error("Illegal start of option inservice " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                            } while (token !== Lang.CLOSE);
                            this.tn.peek() === Lang.END && this.tn.next();
                        } else if (token !== Lang.END) throw Error("Illegal delimiter in service " + svc.name + "#" + name + " at line " + this.tn.line + ": " + token);
                        void 0 === svc[type] && (svc[type] = {}), svc[type][name] = method;
                    }, ParserPrototype._parseMessage = function(parent, fld, token) {
                        var msg = {}, isGroup = "group" === token;
                        if (token = this.tn.next(), !Lang.NAME.test(token)) throw Error("Illegal " + (isGroup ? "group" : "message") + " name" + (parent ? " in message " + parent.name : "") + " at line " + this.tn.line + ": " + token);
                        if (msg.name = token, isGroup) {
                            if ((token = this.tn.next()) !== Lang.EQUAL) throw Error("Illegal id assignment after group " + msg.name + " at line " + this.tn.line + ": " + token);
                            token = this.tn.next();
                            try {
                                fld.id = this._parseId(token);
                            } catch (e) {
                                throw Error("Illegal field id value for group " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                            }
                            msg.isGroup = !0;
                        }
                        if (msg.fields = [], msg.enums = [], msg.messages = [], msg.options = {}, msg.oneofs = {}, 
                        (token = this.tn.next()) === Lang.OPTOPEN && fld && (this._parseFieldOptions(msg, fld, token), 
                        token = this.tn.next()), token !== Lang.OPEN) throw Error("Illegal start of " + (isGroup ? "group" : "message") + " " + msg.name + " at line " + this.tn.line + ": " + token);
                        for (;;) {
                            if ((token = this.tn.next()) === Lang.CLOSE) {
                                (token = this.tn.peek()) === Lang.END && this.tn.next();
                                break;
                            }
                            if (Lang.RULE.test(token)) this._parseMessageField(msg, token); else if ("oneof" === token) this._parseMessageOneOf(msg, token); else if ("enum" === token) this._parseEnum(msg, token); else if ("message" === token) this._parseMessage(msg, null, token); else if ("option" === token) this._parseOption(msg, token); else if ("extensions" === token) msg.extensions = this._parseExtensions(msg, token); else {
                                if ("extend" !== token) throw Error("Illegal token in message " + msg.name + " at line " + this.tn.line + ": " + token);
                                this._parseExtend(msg, token);
                            }
                        }
                        return parent.messages.push(msg), msg;
                    }, ParserPrototype._parseMessageField = function(msg, token) {
                        var fld = {}, grp = null;
                        if (fld.rule = token, fld.options = {}, "group" === (token = this.tn.next())) {
                            if (grp = this._parseMessage(msg, fld, token), !/^[A-Z]/.test(grp.name)) throw Error("Group names must start with a capital letter");
                            fld.type = grp.name, fld.name = grp.name.toLowerCase(), (token = this.tn.peek()) === Lang.END && this.tn.next();
                        } else {
                            if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("Illegal field type in message " + msg.name + " at line " + this.tn.line + ": " + token);
                            if (fld.type = token, token = this.tn.next(), !Lang.NAME.test(token)) throw Error("Illegal field name in message " + msg.name + " at line " + this.tn.line + ": " + token);
                            if (fld.name = token, (token = this.tn.next()) !== Lang.EQUAL) throw Error("Illegal token in field " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                            token = this.tn.next();
                            try {
                                fld.id = this._parseId(token);
                            } catch (e) {
                                throw Error("Illegal field id in message " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                            }
                            if ((token = this.tn.next()) === Lang.OPTOPEN && (this._parseFieldOptions(msg, fld, token), 
                            token = this.tn.next()), token !== Lang.END) throw Error("Illegal delimiter in message " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                        }
                        return msg.fields.push(fld), fld;
                    }, ParserPrototype._parseMessageOneOf = function(msg, token) {
                        if (token = this.tn.next(), !Lang.NAME.test(token)) throw Error("Illegal oneof name in message " + msg.name + " at line " + this.tn.line + ": " + token);
                        var fld, name = token, fields = [];
                        if ((token = this.tn.next()) !== Lang.OPEN) throw Error("Illegal start of oneof " + name + " at line " + this.tn.line + ": " + token);
                        for (;this.tn.peek() !== Lang.CLOSE; ) (fld = this._parseMessageField(msg, "optional")).oneof = name, 
                        fields.push(fld.id);
                        this.tn.next(), msg.oneofs[name] = fields;
                    }, ParserPrototype._parseFieldOptions = function(msg, fld, token) {
                        for (var first = !0; (token = this.tn.next()) !== Lang.OPTCLOSE; ) {
                            if (token === Lang.OPTEND) {
                                if (first) throw Error("Illegal start of options in message " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                                token = this.tn.next();
                            }
                            this._parseFieldOption(msg, fld, token), first = !1;
                        }
                    }, ParserPrototype._parseFieldOption = function(msg, fld, token) {
                        var custom = !1;
                        if (token === Lang.COPTOPEN && (token = this.tn.next(), custom = !0), !Lang.TYPEREF.test(token)) throw Error("Illegal field option in " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                        var value, name = token;
                        if (token = this.tn.next(), custom) {
                            if (token !== Lang.COPTCLOSE) throw Error("Illegal delimiter in " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                            name = "(" + name + ")", token = this.tn.next(), Lang.FQTYPEREF.test(token) && (name += token, 
                            token = this.tn.next());
                        }
                        if (token !== Lang.EQUAL) throw Error("Illegal token in " + msg.name + "#" + fld.name + " at line " + this.tn.line + ": " + token);
                        if ((token = this.tn.peek()) === Lang.STRINGOPEN || token === Lang.STRINGOPEN_SQ) value = this._parseString(); else if (Lang.NUMBER.test(token, !0)) value = this._parseNumber(this.tn.next(), !0); else if (Lang.BOOL.test(token)) value = "true" === this.tn.next().toLowerCase(); else {
                            if (!Lang.TYPEREF.test(token)) throw Error("Illegal value in message " + msg.name + "#" + fld.name + ", option " + name + " at line " + this.tn.line + ": " + token);
                            value = this.tn.next();
                        }
                        fld.options[name] = value;
                    }, ParserPrototype._parseEnum = function(msg, token) {
                        var enm = {};
                        if (token = this.tn.next(), !Lang.NAME.test(token)) throw Error("Illegal enum name in message " + msg.name + " at line " + this.tn.line + ": " + token);
                        if (enm.name = token, (token = this.tn.next()) !== Lang.OPEN) throw Error("Illegal start of enum " + enm.name + " at line " + this.tn.line + ": " + token);
                        for (enm.values = [], enm.options = {}; ;) {
                            if ((token = this.tn.next()) === Lang.CLOSE) {
                                (token = this.tn.peek()) === Lang.END && this.tn.next();
                                break;
                            }
                            if ("option" == token) this._parseOption(enm, token); else {
                                if (!Lang.NAME.test(token)) throw Error("Illegal name in enum " + enm.name + " at line " + this.tn.line + ": " + token);
                                this._parseEnumValue(enm, token);
                            }
                        }
                        msg.enums.push(enm);
                    }, ParserPrototype._parseEnumValue = function(enm, token) {
                        var val = {};
                        if (val.name = token, (token = this.tn.next()) !== Lang.EQUAL) throw Error("Illegal token in enum " + enm.name + " at line " + this.tn.line + ": " + token);
                        token = this.tn.next();
                        try {
                            val.id = this._parseId(token, !0);
                        } catch (e) {
                            throw Error("Illegal id in enum " + enm.name + " at line " + this.tn.line + ": " + token);
                        }
                        if (enm.values.push(val), (token = this.tn.next()) === Lang.OPTOPEN && (this._parseFieldOptions(enm, {
                            options: {}
                        }, token), token = this.tn.next()), token !== Lang.END) throw Error("Illegal delimiter in enum " + enm.name + " at line " + this.tn.line + ": " + token);
                    }, ParserPrototype._parseExtensions = function(msg, token) {
                        var range = [];
                        if ("min" === (token = this.tn.next()) ? range.push(ProtoBuf.ID_MIN) : "max" === token ? range.push(ProtoBuf.ID_MAX) : range.push(this._parseNumber(token)), 
                        "to" !== (token = this.tn.next())) throw Error("Illegal extensions delimiter in message " + msg.name + " at line " + this.tn.line + ": " + token);
                        if ("min" === (token = this.tn.next()) ? range.push(ProtoBuf.ID_MIN) : "max" === token ? range.push(ProtoBuf.ID_MAX) : range.push(this._parseNumber(token)), 
                        (token = this.tn.next()) !== Lang.END) throw Error("Illegal extensions delimiter in message " + msg.name + " at line " + this.tn.line + ": " + token);
                        return range;
                    }, ParserPrototype._parseExtend = function(parent, token) {
                        if (token = this.tn.next(), !Lang.TYPEREF.test(token)) throw Error("Illegal message name at line " + this.tn.line + ": " + token);
                        var ext = {};
                        if (ext.ref = token, ext.fields = [], (token = this.tn.next()) !== Lang.OPEN) throw Error("Illegal start of extend " + ext.name + " at line " + this.tn.line + ": " + token);
                        for (;;) {
                            if ((token = this.tn.next()) === Lang.CLOSE) {
                                (token = this.tn.peek()) == Lang.END && this.tn.next();
                                break;
                            }
                            if (!Lang.RULE.test(token)) throw Error("Illegal token in extend " + ext.name + " at line " + this.tn.line + ": " + token);
                            this._parseMessageField(ext, token);
                        }
                        return parent.messages.push(ext), ext;
                    }, ParserPrototype.toString = function() {
                        return "Parser";
                    }, DotProto.Parser = Parser, DotProto;
                })(ProtoBuf, ProtoBuf.Lang), ProtoBuf.Reflect = (function(ProtoBuf) {
                    var Reflect = {}, T = function(builder, parent, name) {
                        this.builder = builder, this.parent = parent, this.name = name, this.className;
                    }, TPrototype = T.prototype;
                    TPrototype.fqn = function() {
                        for (var name = this.name, ptr = this; null != (ptr = ptr.parent); ) name = ptr.name + "." + name;
                        return name;
                    }, TPrototype.toString = function(includeClass) {
                        return (includeClass ? this.className + " " : "") + this.fqn();
                    }, TPrototype.build = function() {
                        throw Error(this.toString(!0) + " cannot be built directly");
                    }, Reflect.T = T;
                    var Namespace = function(builder, parent, name, options) {
                        T.call(this, builder, parent, name), this.className = "Namespace", this.children = [], 
                        this.options = options || {};
                    }, NamespacePrototype = Namespace.prototype = Object.create(T.prototype);
                    NamespacePrototype.getChildren = function(type) {
                        if (null == (type = type || null)) return this.children.slice();
                        for (var children = [], i = 0, k = this.children.length; i < k; ++i) this.children[i] instanceof type && children.push(this.children[i]);
                        return children;
                    }, NamespacePrototype.addChild = function(child) {
                        var other;
                        if (other = this.getChild(child.name)) if (other instanceof Message.Field && other.name !== other.originalName && null === this.getChild(other.originalName)) other.name = other.originalName; else {
                            if (!(child instanceof Message.Field && child.name !== child.originalName && null === this.getChild(child.originalName))) throw Error("Duplicate name in namespace " + this.toString(!0) + ": " + child.name);
                            child.name = child.originalName;
                        }
                        this.children.push(child);
                    }, NamespacePrototype.getChild = function(nameOrId) {
                        for (var key = "number" == typeof nameOrId ? "id" : "name", i = 0, k = this.children.length; i < k; ++i) if (this.children[i][key] === nameOrId) return this.children[i];
                        return null;
                    }, NamespacePrototype.resolve = function(qn, excludeFields) {
                        var child, part = qn.split("."), ptr = this, i = 0;
                        if ("" === part[i]) {
                            for (;null !== ptr.parent; ) ptr = ptr.parent;
                            i++;
                        }
                        do {
                            do {
                                if (!(child = ptr.getChild(part[i])) || !(child instanceof Reflect.T) || excludeFields && child instanceof Reflect.Message.Field) {
                                    ptr = null;
                                    break;
                                }
                                ptr = child, i++;
                            } while (i < part.length);
                            if (null != ptr) break;
                            if (null !== this.parent) return this.parent.resolve(qn, excludeFields);
                        } while (null != ptr);
                        return ptr;
                    }, NamespacePrototype.build = function() {
                        for (var child, ns = {}, children = this.children, i = 0, k = children.length; i < k; ++i) (child = children[i]) instanceof Namespace && (ns[child.name] = child.build());
                        return Object.defineProperty && Object.defineProperty(ns, "$options", {
                            value: this.buildOpt()
                        }), ns;
                    }, NamespacePrototype.buildOpt = function() {
                        for (var opt = {}, keys = Object.keys(this.options), i = 0, k = keys.length; i < k; ++i) {
                            var key = keys[i], val = this.options[keys[i]];
                            opt[key] = val;
                        }
                        return opt;
                    }, NamespacePrototype.getOption = function(name) {
                        return void 0 === name ? this.options : void 0 !== this.options[name] ? this.options[name] : null;
                    }, Reflect.Namespace = Namespace;
                    var Message = function(builder, parent, name, options, isGroup) {
                        Namespace.call(this, builder, parent, name, options), this.className = "Message", 
                        this.extensions = [ ProtoBuf.ID_MIN, ProtoBuf.ID_MAX ], this.clazz = null, this.isGroup = !!isGroup, 
                        this._fields = null, this._fieldsById = null, this._fieldsByName = null;
                    }, MessagePrototype = Message.prototype = Object.create(Namespace.prototype);
                    function skipTillGroupEnd(expectedId, buf) {
                        var tag = buf.readVarint32(), wireType = 7 & tag, id = tag >> 3;
                        switch (wireType) {
                          case ProtoBuf.WIRE_TYPES.VARINT:
                            do {
                                tag = buf.readUint8();
                            } while (128 == (128 & tag));
                            break;

                          case ProtoBuf.WIRE_TYPES.BITS64:
                            buf.offset += 8;
                            break;

                          case ProtoBuf.WIRE_TYPES.LDELIM:
                            tag = buf.readVarint32(), buf.offset += tag;
                            break;

                          case ProtoBuf.WIRE_TYPES.STARTGROUP:
                            skipTillGroupEnd(id, buf);
                            break;

                          case ProtoBuf.WIRE_TYPES.ENDGROUP:
                            if (id === expectedId) return !1;
                            throw Error("Illegal GROUPEND after unknown group: " + id + " (" + expectedId + " expected)");

                          case ProtoBuf.WIRE_TYPES.BITS32:
                            buf.offset += 4;
                            break;

                          default:
                            throw Error("Illegal wire type in unknown group " + expectedId + ": " + wireType);
                        }
                        return !0;
                    }
                    MessagePrototype.build = function(rebuild) {
                        if (this.clazz && !rebuild) return this.clazz;
                        var clazz = (function(ProtoBuf, T) {
                            var fields = T.getChildren(ProtoBuf.Reflect.Message.Field), oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf), Message = function(values, var_args) {
                                ProtoBuf.Builder.Message.call(this);
                                for (var i = 0, k = oneofs.length; i < k; ++i) this[oneofs[i].name] = null;
                                for (i = 0, k = fields.length; i < k; ++i) {
                                    var field = fields[i];
                                    this[field.name] = field.repeated ? [] : null, field.required && null !== field.defaultValue && (this[field.name] = field.defaultValue);
                                }
                                if (arguments.length > 0) if (1 !== arguments.length || "object" != typeof values || "function" == typeof values.encode || ProtoBuf.Util.isArray(values) || values instanceof ByteBuffer || values instanceof ArrayBuffer || ProtoBuf.Long && values instanceof ProtoBuf.Long) for (i = 0, 
                                k = arguments.length; i < k; ++i) this.$set(fields[i].name, arguments[i]); else {
                                    var keys = Object.keys(values);
                                    for (i = 0, k = keys.length; i < k; ++i) this.$set(keys[i], values[keys[i]]);
                                }
                            }, MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);
                            MessagePrototype.add = function(key, value, noAssert) {
                                var field = T._fieldsByName[key];
                                if (!noAssert) {
                                    if (!field) throw Error(this + "#" + key + " is undefined");
                                    if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(!0));
                                    if (!field.repeated) throw Error(this + "#" + key + " is not a repeated field");
                                }
                                null === this[field.name] && (this[field.name] = []), this[field.name].push(noAssert ? value : field.verifyValue(value, !0));
                            }, MessagePrototype.$add = MessagePrototype.add, MessagePrototype.set = function(key, value, noAssert) {
                                if (key && "object" == typeof key) {
                                    for (var i in key) key.hasOwnProperty(i) && this.$set(i, key[i], noAssert);
                                    return this;
                                }
                                var field = T._fieldsByName[key];
                                if (noAssert) this[field.name] = value; else {
                                    if (!field) throw Error(this + "#" + key + " is not a field: undefined");
                                    if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(!0));
                                    this[field.name] = value = field.verifyValue(value);
                                }
                                return field.oneof && (null !== value ? (null !== this[field.oneof.name] && (this[this[field.oneof.name]] = null), 
                                this[field.oneof.name] = field.name) : field.oneof.name === key && (this[field.oneof.name] = null)), 
                                this;
                            }, MessagePrototype.$set = MessagePrototype.set, MessagePrototype.get = function(key, noAssert) {
                                if (noAssert) return this[key];
                                var field = T._fieldsByName[key];
                                if (!(field && field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: undefined");
                                if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(!0));
                                return this[field.name];
                            }, MessagePrototype.$get = MessagePrototype.get;
                            for (var i = 0; i < fields.length; i++) {
                                var field = fields[i];
                                field instanceof ProtoBuf.Reflect.Message.ExtensionField || T.builder.options.populateAccessors && (function(field) {
                                    var Name = field.originalName.replace(/(_[a-zA-Z])/g, (function(match) {
                                        return match.toUpperCase().replace("_", "");
                                    }));
                                    Name = Name.substring(0, 1).toUpperCase() + Name.substring(1);
                                    var name = field.originalName.replace(/([A-Z])/g, (function(match) {
                                        return "_" + match;
                                    })), setter = function(value, noAssert) {
                                        return this[field.name] = noAssert ? value : field.verifyValue(value), this;
                                    }, getter = function() {
                                        return this[field.name];
                                    };
                                    null === T.getChild("set" + Name) && (MessagePrototype["set" + Name] = setter), 
                                    null === T.getChild("set_" + name) && (MessagePrototype["set_" + name] = setter), 
                                    null === T.getChild("get" + Name) && (MessagePrototype["get" + Name] = getter), 
                                    null === T.getChild("get_" + name) && (MessagePrototype["get_" + name] = getter);
                                })(field);
                            }
                            function cloneRaw(obj, includeBinaryAsBase64) {
                                var clone = {};
                                for (var i in obj) obj.hasOwnProperty(i) && (null === obj[i] || "object" != typeof obj[i] ? clone[i] = obj[i] : obj[i] instanceof ByteBuffer ? includeBinaryAsBase64 && (clone[i] = obj[i].toBase64()) : clone[i] = cloneRaw(obj[i], includeBinaryAsBase64));
                                return clone;
                            }
                            return MessagePrototype.encode = function(buffer, noVerify) {
                                "boolean" == typeof buffer && (noVerify = buffer, buffer = void 0);
                                var isNew = !1;
                                buffer || (buffer = new ByteBuffer, isNew = !0);
                                var le = buffer.littleEndian;
                                try {
                                    return T.encode(this, buffer.LE(), noVerify), (isNew ? buffer.flip() : buffer).LE(le);
                                } catch (e) {
                                    throw buffer.LE(le), e;
                                }
                            }, MessagePrototype.calculate = function() {
                                return T.calculate(this);
                            }, MessagePrototype.encodeDelimited = function(buffer) {
                                var isNew = !1;
                                buffer || (buffer = new ByteBuffer, isNew = !0);
                                var enc = (new ByteBuffer).LE();
                                return T.encode(this, enc).flip(), buffer.writeVarint32(enc.remaining()), buffer.append(enc), 
                                isNew ? buffer.flip() : buffer;
                            }, MessagePrototype.encodeAB = function() {
                                try {
                                    return this.encode().toArrayBuffer();
                                } catch (e) {
                                    throw e.encoded && (e.encoded = e.encoded.toArrayBuffer()), e;
                                }
                            }, MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB, MessagePrototype.encodeNB = function() {
                                try {
                                    return this.encode().toBuffer();
                                } catch (e) {
                                    throw e.encoded && (e.encoded = e.encoded.toBuffer()), e;
                                }
                            }, MessagePrototype.toBuffer = MessagePrototype.encodeNB, MessagePrototype.encode64 = function() {
                                try {
                                    return this.encode().toBase64();
                                } catch (e) {
                                    throw e.encoded && (e.encoded = e.encoded.toBase64()), e;
                                }
                            }, MessagePrototype.toBase64 = MessagePrototype.encode64, MessagePrototype.encodeHex = function() {
                                try {
                                    return this.encode().toHex();
                                } catch (e) {
                                    throw e.encoded && (e.encoded = e.encoded.toHex()), e;
                                }
                            }, MessagePrototype.toHex = MessagePrototype.encodeHex, MessagePrototype.toRaw = function(includeBinaryAsBase64) {
                                return cloneRaw(this, !!includeBinaryAsBase64);
                            }, Message.decode = function(buffer, enc) {
                                "string" == typeof buffer && (buffer = ByteBuffer.wrap(buffer, enc || "base64"));
                                var le = (buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer)).littleEndian;
                                try {
                                    var msg = T.decode(buffer.LE());
                                    return buffer.LE(le), msg;
                                } catch (e) {
                                    throw buffer.LE(le), e;
                                }
                            }, Message.decodeDelimited = function(buffer, enc) {
                                if ("string" == typeof buffer && (buffer = ByteBuffer.wrap(buffer, enc || "base64")), 
                                (buffer = buffer instanceof ByteBuffer ? buffer : ByteBuffer.wrap(buffer)).remaining() < 1) return null;
                                var off = buffer.offset, len = buffer.readVarint32();
                                if (buffer.remaining() < len) return buffer.offset = off, null;
                                try {
                                    var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
                                    return buffer.offset += len, msg;
                                } catch (err) {
                                    throw buffer.offset += len, err;
                                }
                            }, Message.decode64 = function(str) {
                                return Message.decode(str, "base64");
                            }, Message.decodeHex = function(str) {
                                return Message.decode(str, "hex");
                            }, MessagePrototype.toString = function() {
                                return T.toString();
                            }, Object.defineProperty && (Object.defineProperty(Message, "$options", {
                                value: T.buildOpt()
                            }), Object.defineProperty(MessagePrototype, "$type", {
                                get: function() {
                                    return T;
                                }
                            })), Message;
                        })(ProtoBuf, this);
                        this._fields = [], this._fieldsById = {}, this._fieldsByName = {};
                        for (var child, i = 0, k = this.children.length; i < k; i++) if ((child = this.children[i]) instanceof Enum) clazz[child.name] = child.build(); else if (child instanceof Message) clazz[child.name] = child.build(); else if (child instanceof Message.Field) child.build(), 
                        this._fields.push(child), this._fieldsById[child.id] = child, this._fieldsByName[child.name] = child; else if (!(child instanceof Message.OneOf || child instanceof Extension)) throw Error("Illegal reflect child of " + this.toString(!0) + ": " + children[i].toString(!0));
                        return this.clazz = clazz;
                    }, MessagePrototype.encode = function(message, buffer, noVerify) {
                        for (var field, val, fieldMissing = null, i = 0, k = this._fields.length; i < k; ++i) val = message[(field = this._fields[i]).name], 
                        field.required && null === val ? null === fieldMissing && (fieldMissing = field) : field.encode(noVerify ? val : field.verifyValue(val), buffer);
                        if (null !== fieldMissing) {
                            var err = Error("Missing at least one required field for " + this.toString(!0) + ": " + fieldMissing);
                            throw err.encoded = buffer, err;
                        }
                        return buffer;
                    }, MessagePrototype.calculate = function(message) {
                        for (var field, val, n = 0, i = 0, k = this._fields.length; i < k; ++i) {
                            if (val = message[(field = this._fields[i]).name], field.required && null === val) throw Error("Missing at least one required field for " + this.toString(!0) + ": " + field);
                            n += field.calculate(val);
                        }
                        return n;
                    }, MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {
                        length = "number" == typeof length ? length : -1;
                        for (var tag, wireType, id, field, start = buffer.offset, msg = new this.clazz; buffer.offset < start + length || -1 === length && buffer.remaining() > 0; ) {
                            if (id = (tag = buffer.readVarint32()) >> 3, (wireType = 7 & tag) === ProtoBuf.WIRE_TYPES.ENDGROUP) {
                                if (id !== expectedGroupEndId) throw Error("Illegal group end indicator for " + this.toString(!0) + ": " + id + " (" + (expectedGroupEndId ? expectedGroupEndId + " expected" : "not a group") + ")");
                                break;
                            }
                            if (field = this._fieldsById[id]) field.repeated && !field.options.packed ? msg[field.name].push(field.decode(wireType, buffer)) : (msg[field.name] = field.decode(wireType, buffer), 
                            field.oneof && (null !== this[field.oneof.name] && (this[this[field.oneof.name]] = null), 
                            msg[field.oneof.name] = field.name)); else switch (wireType) {
                              case ProtoBuf.WIRE_TYPES.VARINT:
                                buffer.readVarint32();
                                break;

                              case ProtoBuf.WIRE_TYPES.BITS32:
                                buffer.offset += 4;
                                break;

                              case ProtoBuf.WIRE_TYPES.BITS64:
                                buffer.offset += 8;
                                break;

                              case ProtoBuf.WIRE_TYPES.LDELIM:
                                var len = buffer.readVarint32();
                                buffer.offset += len;
                                break;

                              case ProtoBuf.WIRE_TYPES.STARTGROUP:
                                for (;skipTillGroupEnd(id, buffer); ) ;
                                break;

                              default:
                                throw Error("Illegal wire type for unknown field " + id + " in " + this.toString(!0) + "#decode: " + wireType);
                            }
                        }
                        for (var i = 0, k = this._fields.length; i < k; ++i) if (null === msg[(field = this._fields[i]).name]) {
                            if (field.required) {
                                var err = Error("Missing at least one required field for " + this.toString(!0) + ": " + field.name);
                                throw err.decoded = msg, err;
                            }
                            null !== field.defaultValue && (msg[field.name] = field.defaultValue);
                        }
                        return msg;
                    }, Reflect.Message = Message;
                    var Field = function(builder, message, rule, type, name, id, options, oneof) {
                        T.call(this, builder, message, name), this.className = "Message.Field", this.required = "required" === rule, 
                        this.repeated = "repeated" === rule, this.type = type, this.resolvedType = null, 
                        this.id = id, this.options = options || {}, this.defaultValue = null, this.oneof = oneof || null, 
                        this.originalName = this.name, !this.builder.options.convertFieldsToCamelCase || this instanceof Message.ExtensionField || (this.name = Field._toCamelCase(this.name));
                    };
                    Field._toCamelCase = function(name) {
                        return name.replace(/_([a-zA-Z])/g, (function($0, $1) {
                            return $1.toUpperCase();
                        }));
                    };
                    var FieldPrototype = Field.prototype = Object.create(T.prototype);
                    function mkLong(value, unsigned) {
                        if (value && "number" == typeof value.low && "number" == typeof value.high && "boolean" == typeof value.unsigned && value.low == value.low && value.high == value.high) return new ProtoBuf.Long(value.low, value.high, void 0 === unsigned ? value.unsigned : unsigned);
                        if ("string" == typeof value) return ProtoBuf.Long.fromString(value, unsigned || !1, 10);
                        if ("number" == typeof value) return ProtoBuf.Long.fromNumber(value, unsigned || !1);
                        throw Error("not convertible to Long");
                    }
                    FieldPrototype.build = function() {
                        this.defaultValue = void 0 !== this.options.default ? this.verifyValue(this.options.default) : null;
                    }, FieldPrototype.verifyValue = function(value, skipRepeated) {
                        skipRepeated = skipRepeated || !1;
                        var fail = function(val, msg) {
                            throw Error("Illegal value for " + this.toString(!0) + " of type " + this.type.name + ": " + val + " (" + msg + ")");
                        }.bind(this);
                        if (null === value) return this.required && fail(typeof value, "required"), null;
                        if (this.repeated && !skipRepeated) {
                            ProtoBuf.Util.isArray(value) || (value = [ value ]);
                            var res = [];
                            for (i = 0; i < value.length; i++) res.push(this.verifyValue(value[i], !0));
                            return res;
                        }
                        switch (!this.repeated && ProtoBuf.Util.isArray(value) && fail(typeof value, "no array expected"), 
                        this.type) {
                          case ProtoBuf.TYPES.int32:
                          case ProtoBuf.TYPES.sint32:
                          case ProtoBuf.TYPES.sfixed32:
                            return ("number" != typeof value || value == value && value % 1 != 0) && fail(typeof value, "not an integer"), 
                            value > 4294967295 ? 0 | value : value;

                          case ProtoBuf.TYPES.uint32:
                          case ProtoBuf.TYPES.fixed32:
                            return ("number" != typeof value || value == value && value % 1 != 0) && fail(typeof value, "not an integer"), 
                            value < 0 ? value >>> 0 : value;

                          case ProtoBuf.TYPES.int64:
                          case ProtoBuf.TYPES.sint64:
                          case ProtoBuf.TYPES.sfixed64:
                            if (ProtoBuf.Long) try {
                                return mkLong(value, !1);
                            } catch (e) {
                                fail(typeof value, e.message);
                            } else fail(typeof value, "requires Long.js");

                          case ProtoBuf.TYPES.uint64:
                          case ProtoBuf.TYPES.fixed64:
                            if (ProtoBuf.Long) try {
                                return mkLong(value, !0);
                            } catch (e) {
                                fail(typeof value, e.message);
                            } else fail(typeof value, "requires Long.js");

                          case ProtoBuf.TYPES.bool:
                            return "boolean" != typeof value && fail(typeof value, "not a boolean"), value;

                          case ProtoBuf.TYPES.float:
                          case ProtoBuf.TYPES.double:
                            return "number" != typeof value && fail(typeof value, "not a number"), value;

                          case ProtoBuf.TYPES.string:
                            return "string" == typeof value || value && value instanceof String || fail(typeof value, "not a string"), 
                            "" + value;

                          case ProtoBuf.TYPES.bytes:
                            return ByteBuffer.isByteBuffer(value) ? value : ByteBuffer.wrap(value, "base64");

                          case ProtoBuf.TYPES.enum:
                            var values = this.resolvedType.getChildren(Enum.Value);
                            for (i = 0; i < values.length; i++) {
                                if (values[i].name == value) return values[i].id;
                                if (values[i].id == value) return values[i].id;
                            }
                            fail(value, "not a valid enum value");

                          case ProtoBuf.TYPES.group:
                          case ProtoBuf.TYPES.message:
                            if (value && "object" == typeof value || fail(typeof value, "object expected"), 
                            value instanceof this.resolvedType.clazz) return value;
                            if (value instanceof ProtoBuf.Builder.Message) {
                                var obj = {};
                                for (var i in value) value.hasOwnProperty(i) && (obj[i] = value[i]);
                                value = obj;
                            }
                            return new this.resolvedType.clazz(value);
                        }
                        throw Error("[INTERNAL] Illegal value for " + this.toString(!0) + ": " + value + " (undefined type " + this.type + ")");
                    }, FieldPrototype.encode = function(value, buffer) {
                        if (null === this.type || "object" != typeof this.type) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
                        if (null === value || this.repeated && 0 == value.length) return buffer;
                        try {
                            var i;
                            if (this.repeated) if (this.options.packed && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                                buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM), buffer.ensureCapacity(buffer.offset += 1);
                                var start = buffer.offset;
                                for (i = 0; i < value.length; i++) this.encodeValue(value[i], buffer);
                                var len = buffer.offset - start, varintLen = ByteBuffer.calculateVarint32(len);
                                if (varintLen > 1) {
                                    var contents = buffer.slice(start, buffer.offset);
                                    start += varintLen - 1, buffer.offset = start, buffer.append(contents);
                                }
                                buffer.writeVarint32(len, start - varintLen);
                            } else for (i = 0; i < value.length; i++) buffer.writeVarint32(this.id << 3 | this.type.wireType), 
                            this.encodeValue(value[i], buffer); else buffer.writeVarint32(this.id << 3 | this.type.wireType), 
                            this.encodeValue(value, buffer);
                        } catch (e) {
                            throw Error("Illegal value for " + this.toString(!0) + ": " + value + " (" + e + ")");
                        }
                        return buffer;
                    }, FieldPrototype.encodeValue = function(value, buffer) {
                        if (null === value) return buffer;
                        switch (this.type) {
                          case ProtoBuf.TYPES.int32:
                            value < 0 ? buffer.writeVarint64(value) : buffer.writeVarint32(value);
                            break;

                          case ProtoBuf.TYPES.uint32:
                            buffer.writeVarint32(value);
                            break;

                          case ProtoBuf.TYPES.sint32:
                            buffer.writeVarint32ZigZag(value);
                            break;

                          case ProtoBuf.TYPES.fixed32:
                            buffer.writeUint32(value);
                            break;

                          case ProtoBuf.TYPES.sfixed32:
                            buffer.writeInt32(value);
                            break;

                          case ProtoBuf.TYPES.int64:
                          case ProtoBuf.TYPES.uint64:
                            buffer.writeVarint64(value);
                            break;

                          case ProtoBuf.TYPES.sint64:
                            buffer.writeVarint64ZigZag(value);
                            break;

                          case ProtoBuf.TYPES.fixed64:
                            buffer.writeUint64(value);
                            break;

                          case ProtoBuf.TYPES.sfixed64:
                            buffer.writeInt64(value);
                            break;

                          case ProtoBuf.TYPES.bool:
                            "string" == typeof value ? buffer.writeVarint32("false" === value.toLowerCase() ? 0 : !!value) : buffer.writeVarint32(value ? 1 : 0);
                            break;

                          case ProtoBuf.TYPES.enum:
                            buffer.writeVarint32(value);
                            break;

                          case ProtoBuf.TYPES.float:
                            buffer.writeFloat32(value);
                            break;

                          case ProtoBuf.TYPES.double:
                            buffer.writeFloat64(value);
                            break;

                          case ProtoBuf.TYPES.string:
                            buffer.writeVString(value);
                            break;

                          case ProtoBuf.TYPES.bytes:
                            if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(!0) + ": " + value.remaining() + " bytes remaining");
                            var prevOffset = value.offset;
                            buffer.writeVarint32(value.remaining()), buffer.append(value), value.offset = prevOffset;
                            break;

                          case ProtoBuf.TYPES.message:
                            var bb = (new ByteBuffer).LE();
                            this.resolvedType.encode(value, bb), buffer.writeVarint32(bb.offset), buffer.append(bb.flip());
                            break;

                          case ProtoBuf.TYPES.group:
                            this.resolvedType.encode(value, buffer), buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
                            break;

                          default:
                            throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + value + " (unknown type)");
                        }
                        return buffer;
                    }, FieldPrototype.calculate = function(value) {
                        if (value = this.verifyValue(value), null === this.type || "object" != typeof this.type) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type);
                        if (null === value || this.repeated && 0 == value.length) return 0;
                        var n = 0;
                        try {
                            var i, ni;
                            if (this.repeated) if (this.options.packed && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                                for (n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM), 
                                ni = 0, i = 0; i < value.length; i++) ni += this.calculateValue(value[i]);
                                n += ByteBuffer.calculateVarint32(ni), n += ni;
                            } else for (i = 0; i < value.length; i++) n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType), 
                            n += this.calculateValue(value[i]); else n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType), 
                            n += this.calculateValue(value);
                        } catch (e) {
                            throw Error("Illegal value for " + this.toString(!0) + ": " + value + " (" + e + ")");
                        }
                        return n;
                    }, FieldPrototype.calculateValue = function(value) {
                        if (null === value) return 0;
                        var n;
                        switch (this.type) {
                          case ProtoBuf.TYPES.int32:
                            return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);

                          case ProtoBuf.TYPES.uint32:
                            return ByteBuffer.calculateVarint32(value);

                          case ProtoBuf.TYPES.sint32:
                            return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));

                          case ProtoBuf.TYPES.fixed32:
                          case ProtoBuf.TYPES.sfixed32:
                          case ProtoBuf.TYPES.float:
                            return 4;

                          case ProtoBuf.TYPES.int64:
                          case ProtoBuf.TYPES.uint64:
                            return ByteBuffer.calculateVarint64(value);

                          case ProtoBuf.TYPES.sint64:
                            return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));

                          case ProtoBuf.TYPES.fixed64:
                          case ProtoBuf.TYPES.sfixed64:
                            return 8;

                          case ProtoBuf.TYPES.bool:
                            return 1;

                          case ProtoBuf.TYPES.enum:
                            return ByteBuffer.calculateVarint32(value);

                          case ProtoBuf.TYPES.double:
                            return 8;

                          case ProtoBuf.TYPES.string:
                            return n = ByteBuffer.calculateUTF8Bytes(value), ByteBuffer.calculateVarint32(n) + n;

                          case ProtoBuf.TYPES.bytes:
                            if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(!0) + ": " + value.remaining() + " bytes remaining");
                            return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();

                          case ProtoBuf.TYPES.message:
                            return n = this.resolvedType.calculate(value), ByteBuffer.calculateVarint32(n) + n;

                          case ProtoBuf.TYPES.group:
                            return (n = this.resolvedType.calculate(value)) + ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
                        }
                        throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + value + " (unknown type)");
                    }, FieldPrototype.decode = function(wireType, buffer, skipRepeated) {
                        var value, nBytes;
                        if (wireType != this.type.wireType && (skipRepeated || wireType != ProtoBuf.WIRE_TYPES.LDELIM || !this.repeated)) throw Error("Illegal wire type for field " + this.toString(!0) + ": " + wireType + " (" + this.type.wireType + " expected)");
                        if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options.packed && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0 && !skipRepeated) {
                            nBytes = buffer.readVarint32(), nBytes = buffer.offset + nBytes;
                            for (var values = []; buffer.offset < nBytes; ) values.push(this.decode(this.type.wireType, buffer, !0));
                            return values;
                        }
                        switch (this.type) {
                          case ProtoBuf.TYPES.int32:
                            return 0 | buffer.readVarint32();

                          case ProtoBuf.TYPES.uint32:
                            return buffer.readVarint32() >>> 0;

                          case ProtoBuf.TYPES.sint32:
                            return 0 | buffer.readVarint32ZigZag();

                          case ProtoBuf.TYPES.fixed32:
                            return buffer.readUint32() >>> 0;

                          case ProtoBuf.TYPES.sfixed32:
                            return 0 | buffer.readInt32();

                          case ProtoBuf.TYPES.int64:
                            return buffer.readVarint64();

                          case ProtoBuf.TYPES.uint64:
                            return buffer.readVarint64().toUnsigned();

                          case ProtoBuf.TYPES.sint64:
                            return buffer.readVarint64ZigZag();

                          case ProtoBuf.TYPES.fixed64:
                            return buffer.readUint64();

                          case ProtoBuf.TYPES.sfixed64:
                            return buffer.readInt64();

                          case ProtoBuf.TYPES.bool:
                            return !!buffer.readVarint32();

                          case ProtoBuf.TYPES.enum:
                            return buffer.readVarint32();

                          case ProtoBuf.TYPES.float:
                            return buffer.readFloat();

                          case ProtoBuf.TYPES.double:
                            return buffer.readDouble();

                          case ProtoBuf.TYPES.string:
                            return buffer.readVString();

                          case ProtoBuf.TYPES.bytes:
                            if (nBytes = buffer.readVarint32(), buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + nBytes + " required but got only " + buffer.remaining());
                            return (value = buffer.clone()).limit = value.offset + nBytes, buffer.offset += nBytes, 
                            value;

                          case ProtoBuf.TYPES.message:
                            return nBytes = buffer.readVarint32(), this.resolvedType.decode(buffer, nBytes);

                          case ProtoBuf.TYPES.group:
                            return this.resolvedType.decode(buffer, -1, this.id);
                        }
                        throw Error("[INTERNAL] Illegal wire type for " + this.toString(!0) + ": " + wireType);
                    }, Reflect.Message.Field = Field;
                    var ExtensionField = function(builder, message, rule, type, name, id, options) {
                        Field.call(this, builder, message, rule, type, name, id, options), this.extension;
                    };
                    ExtensionField.prototype = Object.create(Field.prototype), Reflect.Message.ExtensionField = ExtensionField, 
                    Reflect.Message.OneOf = function(builder, message, name) {
                        T.call(this, builder, message, name), this.fields = [];
                    };
                    var Enum = function(builder, parent, name, options) {
                        Namespace.call(this, builder, parent, name, options), this.className = "Enum", this.object = null;
                    };
                    (Enum.prototype = Object.create(Namespace.prototype)).build = function() {
                        for (var enm = {}, values = this.getChildren(Enum.Value), i = 0, k = values.length; i < k; ++i) enm[values[i].name] = values[i].id;
                        return Object.defineProperty && Object.defineProperty(enm, "$options", {
                            value: this.buildOpt()
                        }), this.object = enm;
                    }, Reflect.Enum = Enum;
                    var Value = function(builder, enm, name, id) {
                        T.call(this, builder, enm, name), this.className = "Enum.Value", this.id = id;
                    };
                    Value.prototype = Object.create(T.prototype), Reflect.Enum.Value = Value;
                    var Extension = function(builder, parent, name, field) {
                        T.call(this, builder, parent, name), this.field = field;
                    };
                    Extension.prototype = Object.create(T.prototype), Reflect.Extension = Extension;
                    var Service = function(builder, root, name, options) {
                        Namespace.call(this, builder, root, name, options), this.className = "Service", 
                        this.clazz = null;
                    };
                    (Service.prototype = Object.create(Namespace.prototype)).build = function(rebuild) {
                        return this.clazz && !rebuild ? this.clazz : this.clazz = (function(ProtoBuf, T) {
                            var Service = function(rpcImpl) {
                                ProtoBuf.Builder.Service.call(this), this.rpcImpl = rpcImpl || function(name, msg, callback) {
                                    setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0);
                                };
                            }, ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);
                            Object.defineProperty && (Object.defineProperty(Service, "$options", {
                                value: T.buildOpt()
                            }), Object.defineProperty(ServicePrototype, "$options", {
                                value: Service.$options
                            }));
                            for (var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod), i = 0; i < rpc.length; i++) !(function(method) {
                                ServicePrototype[method.name] = function(req, callback) {
                                    try {
                                        if (!(req && req instanceof method.resolvedRequestType.clazz)) return void setTimeout(callback.bind(this, Error("Illegal request type provided to service method " + T.name + "#" + method.name)), 0);
                                        this.rpcImpl(method.fqn(), req, (function(err, res) {
                                            if (err) callback(err); else {
                                                try {
                                                    res = method.resolvedResponseType.clazz.decode(res);
                                                } catch (notABuffer) {}
                                                res && res instanceof method.resolvedResponseType.clazz ? callback(null, res) : callback(Error("Illegal response type received in service method " + T.name + "#" + method.name));
                                            }
                                        }));
                                    } catch (err) {
                                        setTimeout(callback.bind(this, err), 0);
                                    }
                                }, Service[method.name] = function(rpcImpl, req, callback) {
                                    new Service(rpcImpl)[method.name](req, callback);
                                }, Object.defineProperty && (Object.defineProperty(Service[method.name], "$options", {
                                    value: method.buildOpt()
                                }), Object.defineProperty(ServicePrototype[method.name], "$options", {
                                    value: Service[method.name].$options
                                }));
                            })(rpc[i]);
                            return Service;
                        })(ProtoBuf, this);
                    }, Reflect.Service = Service;
                    var Method = function(builder, svc, name, options) {
                        T.call(this, builder, svc, name), this.className = "Service.Method", this.options = options || {};
                    };
                    (Method.prototype = Object.create(T.prototype)).buildOpt = NamespacePrototype.buildOpt, 
                    Reflect.Service.Method = Method;
                    var RPCMethod = function(builder, svc, name, request, response, options) {
                        Method.call(this, builder, svc, name, options), this.className = "Service.RPCMethod", 
                        this.requestName = request, this.responseName = response, this.resolvedRequestType = null, 
                        this.resolvedResponseType = null;
                    };
                    return RPCMethod.prototype = Object.create(Method.prototype), Reflect.Service.RPCMethod = RPCMethod, 
                    Reflect;
                })(ProtoBuf), ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {
                    var Builder = function(options) {
                        this.ns = new Reflect.Namespace(this, null, ""), this.ptr = this.ns, this.resolved = !1, 
                        this.result = null, this.files = {}, this.importRoot = null, this.options = options || {};
                    }, BuilderPrototype = Builder.prototype;
                    return BuilderPrototype.reset = function() {
                        this.ptr = this.ns;
                    }, BuilderPrototype.define = function(pkg, options) {
                        if ("string" != typeof pkg || !Lang.TYPEREF.test(pkg)) throw Error("Illegal package: " + pkg);
                        var i, part = pkg.split(".");
                        for (i = 0; i < part.length; i++) if (!Lang.NAME.test(part[i])) throw Error("Illegal package: " + part[i]);
                        for (i = 0; i < part.length; i++) null === this.ptr.getChild(part[i]) && this.ptr.addChild(new Reflect.Namespace(this, this.ptr, part[i], options)), 
                        this.ptr = this.ptr.getChild(part[i]);
                        return this;
                    }, Builder.isValidMessage = function(def) {
                        if ("string" != typeof def.name || !Lang.NAME.test(def.name)) return !1;
                        if (void 0 !== def.values || void 0 !== def.rpc) return !1;
                        var i;
                        if (void 0 !== def.fields) {
                            if (!ProtoBuf.Util.isArray(def.fields)) return !1;
                            var id, ids = [];
                            for (i = 0; i < def.fields.length; i++) {
                                if (!Builder.isValidMessageField(def.fields[i])) return !1;
                                if (id = parseInt(def.fields[i].id, 10), ids.indexOf(id) >= 0) return !1;
                                ids.push(id);
                            }
                            ids = null;
                        }
                        if (void 0 !== def.enums) {
                            if (!ProtoBuf.Util.isArray(def.enums)) return !1;
                            for (i = 0; i < def.enums.length; i++) if (!Builder.isValidEnum(def.enums[i])) return !1;
                        }
                        if (void 0 !== def.messages) {
                            if (!ProtoBuf.Util.isArray(def.messages)) return !1;
                            for (i = 0; i < def.messages.length; i++) if (!Builder.isValidMessage(def.messages[i]) && !Builder.isValidExtend(def.messages[i])) return !1;
                        }
                        return !!(void 0 === def.extensions || ProtoBuf.Util.isArray(def.extensions) && 2 === def.extensions.length && "number" == typeof def.extensions[0] && "number" == typeof def.extensions[1]);
                    }, Builder.isValidMessageField = function(def) {
                        if ("string" != typeof def.rule || "string" != typeof def.name || "string" != typeof def.type || void 0 === def.id) return !1;
                        if (!(Lang.RULE.test(def.rule) && Lang.NAME.test(def.name) && Lang.TYPEREF.test(def.type) && Lang.ID.test("" + def.id))) return !1;
                        if (void 0 !== def.options) {
                            if ("object" != typeof def.options) return !1;
                            for (var key, keys = Object.keys(def.options), i = 0; i < keys.length; i++) if ("string" != typeof (key = keys[i]) || "string" != typeof def.options[key] && "number" != typeof def.options[key] && "boolean" != typeof def.options[key]) return !1;
                        }
                        return !0;
                    }, Builder.isValidEnum = function(def) {
                        if ("string" != typeof def.name || !Lang.NAME.test(def.name)) return !1;
                        if (void 0 === def.values || !ProtoBuf.Util.isArray(def.values) || 0 == def.values.length) return !1;
                        for (var i = 0; i < def.values.length; i++) {
                            if ("object" != typeof def.values[i]) return !1;
                            if ("string" != typeof def.values[i].name || void 0 === def.values[i].id) return !1;
                            if (!Lang.NAME.test(def.values[i].name) || !Lang.NEGID.test("" + def.values[i].id)) return !1;
                        }
                        return !0;
                    }, BuilderPrototype.create = function(defs) {
                        if (!defs) return this;
                        if (ProtoBuf.Util.isArray(defs) || (defs = [ defs ]), 0 == defs.length) return this;
                        var stack = [];
                        for (stack.push(defs); stack.length > 0; ) {
                            if (defs = stack.pop(), !ProtoBuf.Util.isArray(defs)) throw Error("Not a valid namespace: " + JSON.stringify(defs));
                            for (;defs.length > 0; ) {
                                var def = defs.shift();
                                if (Builder.isValidMessage(def)) {
                                    var obj = new Reflect.Message(this, this.ptr, def.name, def.options, def.isGroup), oneofs = {};
                                    if (def.oneofs) for (var keys = Object.keys(def.oneofs), i = 0, k = keys.length; i < k; ++i) obj.addChild(oneofs[keys[i]] = new Reflect.Message.OneOf(this, obj, keys[i]));
                                    if (def.fields && def.fields.length > 0) for (i = 0, k = def.fields.length; i < k; ++i) {
                                        var fld = def.fields[i];
                                        if (null !== obj.getChild(fld.id)) throw Error("Duplicate field id in message " + obj.name + ": " + fld.id);
                                        if (fld.options) for (var opts = Object.keys(fld.options), j = 0, l = opts.length; j < l; ++j) {
                                            if ("string" != typeof opts[j]) throw Error("Illegal field option name in message " + obj.name + "#" + fld.name + ": " + opts[j]);
                                            if ("string" != typeof fld.options[opts[j]] && "number" != typeof fld.options[opts[j]] && "boolean" != typeof fld.options[opts[j]]) throw Error("Illegal field option value in message " + obj.name + "#" + fld.name + "#" + opts[j] + ": " + fld.options[opts[j]]);
                                        }
                                        var oneof = null;
                                        if ("string" == typeof fld.oneof && void 0 === (oneof = oneofs[fld.oneof])) throw Error("Illegal oneof in message " + obj.name + "#" + fld.name + ": " + fld.oneof);
                                        fld = new Reflect.Message.Field(this, obj, fld.rule, fld.type, fld.name, fld.id, fld.options, oneof), 
                                        oneof && oneof.fields.push(fld), obj.addChild(fld);
                                    }
                                    var subObj = [];
                                    if (void 0 !== def.enums && def.enums.length > 0) for (i = 0; i < def.enums.length; i++) subObj.push(def.enums[i]);
                                    if (def.messages && def.messages.length > 0) for (i = 0; i < def.messages.length; i++) subObj.push(def.messages[i]);
                                    if (def.extensions && (obj.extensions = def.extensions, obj.extensions[0] < ProtoBuf.ID_MIN && (obj.extensions[0] = ProtoBuf.ID_MIN), 
                                    obj.extensions[1] > ProtoBuf.ID_MAX && (obj.extensions[1] = ProtoBuf.ID_MAX)), this.ptr.addChild(obj), 
                                    subObj.length > 0) {
                                        stack.push(defs), defs = subObj, subObj = null, this.ptr = obj, obj = null;
                                        continue;
                                    }
                                    subObj = null, obj = null;
                                } else if (Builder.isValidEnum(def)) {
                                    for (obj = new Reflect.Enum(this, this.ptr, def.name, def.options), i = 0; i < def.values.length; i++) obj.addChild(new Reflect.Enum.Value(this, obj, def.values[i].name, def.values[i].id));
                                    this.ptr.addChild(obj), obj = null;
                                } else if (Builder.isValidService(def)) {
                                    for (i in obj = new Reflect.Service(this, this.ptr, def.name, def.options), def.rpc) def.rpc.hasOwnProperty(i) && obj.addChild(new Reflect.Service.RPCMethod(this, obj, i, def.rpc[i].request, def.rpc[i].response, def.rpc[i].options));
                                    this.ptr.addChild(obj), obj = null;
                                } else {
                                    if (!Builder.isValidExtend(def)) throw Error("Not a valid definition: " + JSON.stringify(def));
                                    if (obj = this.ptr.resolve(def.ref)) for (i = 0; i < def.fields.length; i++) {
                                        if (null !== obj.getChild(def.fields[i].id)) throw Error("Duplicate extended field id in message " + obj.name + ": " + def.fields[i].id);
                                        if (def.fields[i].id < obj.extensions[0] || def.fields[i].id > obj.extensions[1]) throw Error("Illegal extended field id in message " + obj.name + ": " + def.fields[i].id + " (" + obj.extensions.join(" to ") + " expected)");
                                        var name = def.fields[i].name;
                                        this.options.convertFieldsToCamelCase && (name = Reflect.Message.Field._toCamelCase(def.fields[i].name)), 
                                        fld = new Reflect.Message.ExtensionField(this, obj, def.fields[i].rule, def.fields[i].type, this.ptr.fqn() + "." + name, def.fields[i].id, def.fields[i].options);
                                        var ext = new Reflect.Extension(this, this.ptr, def.fields[i].name, fld);
                                        fld.extension = ext, this.ptr.addChild(ext), obj.addChild(fld);
                                    } else if (!/\.?google\.protobuf\./.test(def.ref)) throw Error("Extended message " + def.ref + " is not defined");
                                }
                                def = null;
                            }
                            defs = null, this.ptr = this.ptr.parent;
                        }
                        return this.resolved = !1, this.result = null, this;
                    }, BuilderPrototype.import = function(json, filename) {
                        if ("string" == typeof filename) {
                            if (ProtoBuf.Util.IS_NODE && (filename = __webpack_require__(4).resolve(filename)), 
                            !0 === this.files[filename]) return this.reset(), this;
                            this.files[filename] = !0;
                        }
                        if (json.imports && json.imports.length > 0) {
                            var importRoot, delim = "/", resetRoot = !1;
                            "object" == typeof filename ? (this.importRoot = filename.root, resetRoot = !0, 
                            importRoot = this.importRoot, filename = filename.file, (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) && (delim = "\\")) : "string" == typeof filename ? this.importRoot ? importRoot = this.importRoot : filename.indexOf("/") >= 0 ? "" === (importRoot = filename.replace(/\/[^\/]*$/, "")) && (importRoot = "/") : filename.indexOf("\\") >= 0 ? (importRoot = filename.replace(/\\[^\\]*$/, ""), 
                            delim = "\\") : importRoot = "." : importRoot = null;
                            for (var i = 0; i < json.imports.length; i++) if ("string" == typeof json.imports[i]) {
                                if (!importRoot) throw Error("Cannot determine import root: File name is unknown");
                                var importFilename = json.imports[i];
                                if (/^google\/protobuf\//.test(importFilename)) continue;
                                if (importFilename = importRoot + delim + importFilename, !0 === this.files[importFilename]) continue;
                                /\.proto$/i.test(importFilename) && !ProtoBuf.DotProto && (importFilename = importFilename.replace(/\.proto$/, ".json"));
                                var contents = ProtoBuf.Util.fetch(importFilename);
                                if (null === contents) throw Error("Failed to import '" + importFilename + "' in '" + filename + "': File not found");
                                /\.json$/i.test(importFilename) ? this.import(JSON.parse(contents + ""), importFilename) : this.import(new ProtoBuf.DotProto.Parser(contents + "").parse(), importFilename);
                            } else filename ? /\.(\w+)$/.test(filename) ? this.import(json.imports[i], filename.replace(/^(.+)\.(\w+)$/, (function($0, $1, $2) {
                                return $1 + "_import" + i + "." + $2;
                            }))) : this.import(json.imports[i], filename + "_import" + i) : this.import(json.imports[i]);
                            resetRoot && (this.importRoot = null);
                        }
                        return json.messages && (json.package && this.define(json.package, json.options), 
                        this.create(json.messages), this.reset()), json.enums && (json.package && this.define(json.package, json.options), 
                        this.create(json.enums), this.reset()), json.services && (json.package && this.define(json.package, json.options), 
                        this.create(json.services), this.reset()), json.extends && (json.package && this.define(json.package, json.options), 
                        this.create(json.extends), this.reset()), this;
                    }, Builder.isValidService = function(def) {
                        return !("string" != typeof def.name || !Lang.NAME.test(def.name) || "object" != typeof def.rpc);
                    }, Builder.isValidExtend = function(def) {
                        if ("string" != typeof def.ref || !Lang.TYPEREF.test(def.ref)) return !1;
                        var i;
                        if (void 0 !== def.fields) {
                            if (!ProtoBuf.Util.isArray(def.fields)) return !1;
                            var id, ids = [];
                            for (i = 0; i < def.fields.length; i++) {
                                if (!Builder.isValidMessageField(def.fields[i])) return !1;
                                if (id = parseInt(def.id, 10), ids.indexOf(id) >= 0) return !1;
                                ids.push(id);
                            }
                            ids = null;
                        }
                        return !0;
                    }, BuilderPrototype.resolveAll = function() {
                        var res;
                        if (null != this.ptr && "object" != typeof this.ptr.type) {
                            if (this.ptr instanceof Reflect.Namespace) for (var children = this.ptr.children, i = 0, k = children.length; i < k; ++i) this.ptr = children[i], 
                            this.resolveAll(); else if (this.ptr instanceof Reflect.Message.Field) if (Lang.TYPE.test(this.ptr.type)) this.ptr.type = ProtoBuf.TYPES[this.ptr.type]; else {
                                if (!Lang.TYPEREF.test(this.ptr.type)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                                if (!(res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, !0))) throw Error("Unresolvable type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                                if (this.ptr.resolvedType = res, res instanceof Reflect.Enum) this.ptr.type = ProtoBuf.TYPES.enum; else {
                                    if (!(res instanceof Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                                    this.ptr.type = res.isGroup ? ProtoBuf.TYPES.group : ProtoBuf.TYPES.message;
                                }
                            } else if (this.ptr instanceof ProtoBuf.Reflect.Enum.Value) ; else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
                                if (!(this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod)) throw Error("Illegal service type in " + this.ptr.toString(!0));
                                if (!((res = this.ptr.parent.resolve(this.ptr.requestName)) && res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.requestName);
                                if (this.ptr.resolvedRequestType = res, !((res = this.ptr.parent.resolve(this.ptr.responseName)) && res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.responseName);
                                this.ptr.resolvedResponseType = res;
                            } else if (!(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf || this.ptr instanceof ProtoBuf.Reflect.Extension)) throw Error("Illegal object in namespace: " + typeof this.ptr + ":" + this.ptr);
                            this.reset();
                        }
                    }, BuilderPrototype.build = function(path) {
                        if (this.reset(), this.resolved || (this.resolveAll(), this.resolved = !0, this.result = null), 
                        null == this.result && (this.result = this.ns.build()), path) {
                            for (var part = path.split("."), ptr = this.result, i = 0; i < part.length; i++) {
                                if (!ptr[part[i]]) {
                                    ptr = null;
                                    break;
                                }
                                ptr = ptr[part[i]];
                            }
                            return ptr;
                        }
                        return this.result;
                    }, BuilderPrototype.lookup = function(path) {
                        return path ? this.ns.resolve(path) : this.ns;
                    }, BuilderPrototype.toString = function() {
                        return "Builder";
                    }, Builder.Message = function() {}, Builder.Service = function() {}, Builder;
                })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect), ProtoBuf.loadProto = function(proto, builder, filename) {
                    return ("string" == typeof builder || builder && "string" == typeof builder.file && "string" == typeof builder.root) && (filename = builder, 
                    builder = void 0), ProtoBuf.loadJson(new ProtoBuf.DotProto.Parser(proto).parse(), builder, filename);
                }, ProtoBuf.protoFromString = ProtoBuf.loadProto, ProtoBuf.loadProtoFile = function(filename, callback, builder) {
                    if (callback && "object" == typeof callback ? (builder = callback, callback = null) : callback && "function" == typeof callback || (callback = null), 
                    callback) return ProtoBuf.Util.fetch("string" == typeof filename ? filename : filename.root + "/" + filename.file, (function(contents) {
                        if (null !== contents) try {
                            callback(null, ProtoBuf.loadProto(contents, builder, filename));
                        } catch (e) {
                            callback(e);
                        } else callback(Error("Failed to fetch file"));
                    }));
                    var contents = ProtoBuf.Util.fetch("object" == typeof filename ? filename.root + "/" + filename.file : filename);
                    return null === contents ? null : ProtoBuf.loadProto(contents, builder, filename);
                }, ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile, ProtoBuf.newBuilder = function(options) {
                    return void 0 === (options = options || {}).convertFieldsToCamelCase && (options.convertFieldsToCamelCase = ProtoBuf.convertFieldsToCamelCase), 
                    void 0 === options.populateAccessors && (options.populateAccessors = ProtoBuf.populateAccessors), 
                    new ProtoBuf.Builder(options);
                }, ProtoBuf.loadJson = function(json, builder, filename) {
                    return ("string" == typeof builder || builder && "string" == typeof builder.file && "string" == typeof builder.root) && (filename = builder, 
                    builder = null), builder && "object" == typeof builder || (builder = ProtoBuf.newBuilder()), 
                    "string" == typeof json && (json = JSON.parse(json)), builder.import(json, filename), 
                    builder.resolveAll(), builder;
                }, ProtoBuf.loadJsonFile = function(filename, callback, builder) {
                    if (callback && "object" == typeof callback ? (builder = callback, callback = null) : callback && "function" == typeof callback || (callback = null), 
                    callback) return ProtoBuf.Util.fetch("string" == typeof filename ? filename : filename.root + "/" + filename.file, (function(contents) {
                        if (null !== contents) try {
                            callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
                        } catch (e) {
                            callback(e);
                        } else callback(Error("Failed to fetch file"));
                    }));
                    var contents = ProtoBuf.Util.fetch("object" == typeof filename ? filename.root + "/" + filename.file : filename);
                    return null === contents ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
                }, ProtoBuf;
            }
            module && "object" == typeof exports && exports ? module.exports = init(__webpack_require__(445)) : (__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(445) ], 
            void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = init) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        })();
    }).call(this, __webpack_require__(62)(module));
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
    void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = function() {
        "use strict";
        function Long(low, high, unsigned) {
            this.low = 0 | low, this.high = 0 | high, this.unsigned = !!unsigned;
        }
        Long.__isLong__, Object.defineProperty(Long.prototype, "__isLong__", {
            value: !0,
            enumerable: !1,
            configurable: !1
        }), Long.isLong = function(obj) {
            return !0 === (obj && obj.__isLong__);
        };
        var INT_CACHE = {}, UINT_CACHE = {};
        Long.fromInt = function(value, unsigned) {
            var obj, cachedObj;
            return unsigned ? 0 <= (value >>>= 0) && value < 256 && (cachedObj = UINT_CACHE[value]) ? cachedObj : (obj = new Long(value, (0 | value) < 0 ? -1 : 0, !0), 
            0 <= value && value < 256 && (UINT_CACHE[value] = obj), obj) : -128 <= (value |= 0) && value < 128 && (cachedObj = INT_CACHE[value]) ? cachedObj : (obj = new Long(value, value < 0 ? -1 : 0, !1), 
            -128 <= value && value < 128 && (INT_CACHE[value] = obj), obj);
        }, Long.fromNumber = function(value, unsigned) {
            return unsigned = !!unsigned, isNaN(value) || !isFinite(value) ? Long.ZERO : !unsigned && value <= -TWO_PWR_63_DBL ? Long.MIN_VALUE : !unsigned && value + 1 >= TWO_PWR_63_DBL ? Long.MAX_VALUE : unsigned && value >= TWO_PWR_64_DBL ? Long.MAX_UNSIGNED_VALUE : value < 0 ? Long.fromNumber(-value, unsigned).negate() : new Long(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
        }, Long.fromBits = function(lowBits, highBits, unsigned) {
            return new Long(lowBits, highBits, unsigned);
        }, Long.fromString = function(str, unsigned, radix) {
            if (0 === str.length) throw Error("number format error: empty string");
            if ("NaN" === str || "Infinity" === str || "+Infinity" === str || "-Infinity" === str) return Long.ZERO;
            if ("number" == typeof unsigned && (radix = unsigned, unsigned = !1), (radix = radix || 10) < 2 || 36 < radix) throw Error("radix out of range: " + radix);
            var p;
            if ((p = str.indexOf("-")) > 0) throw Error('number format error: interior "-" character: ' + str);
            if (0 === p) return Long.fromString(str.substring(1), unsigned, radix).negate();
            for (var radixToPower = Long.fromNumber(Math.pow(radix, 8)), result = Long.ZERO, i = 0; i < str.length; i += 8) {
                var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
                if (size < 8) {
                    var power = Long.fromNumber(Math.pow(radix, size));
                    result = result.multiply(power).add(Long.fromNumber(value));
                } else result = (result = result.multiply(radixToPower)).add(Long.fromNumber(value));
            }
            return result.unsigned = unsigned, result;
        }, Long.fromValue = function(val) {
            return val instanceof Long ? val : "number" == typeof val ? Long.fromNumber(val) : "string" == typeof val ? Long.fromString(val) : new Long(val.low, val.high, val.unsigned);
        };
        var TWO_PWR_32_DBL = 4294967296, TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL, TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2, TWO_PWR_24 = Long.fromInt(1 << 24);
        return Long.ZERO = Long.fromInt(0), Long.UZERO = Long.fromInt(0, !0), Long.ONE = Long.fromInt(1), 
        Long.UONE = Long.fromInt(1, !0), Long.NEG_ONE = Long.fromInt(-1), Long.MAX_VALUE = Long.fromBits(-1, 2147483647, !1), 
        Long.MAX_UNSIGNED_VALUE = Long.fromBits(-1, -1, !0), Long.MIN_VALUE = Long.fromBits(0, -2147483648, !1), 
        Long.prototype.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
        }, Long.prototype.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        }, Long.prototype.toString = function(radix) {
            if ((radix = radix || 10) < 2 || 36 < radix) throw RangeError("radix out of range: " + radix);
            if (this.isZero()) return "0";
            var rem;
            if (this.isNegative()) {
                if (this.equals(Long.MIN_VALUE)) {
                    var radixLong = Long.fromNumber(radix), div = this.divide(radixLong);
                    return rem = div.multiply(radixLong).subtract(this), div.toString(radix) + rem.toInt().toString(radix);
                }
                return "-" + this.negate().toString(radix);
            }
            var radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
            rem = this;
            for (var result = ""; ;) {
                var remDiv = rem.divide(radixToPower), digits = (rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0).toString(radix);
                if ((rem = remDiv).isZero()) return digits + result;
                for (;digits.length < 6; ) digits = "0" + digits;
                result = "" + digits + result;
            }
        }, Long.prototype.getHighBits = function() {
            return this.high;
        }, Long.prototype.getHighBitsUnsigned = function() {
            return this.high >>> 0;
        }, Long.prototype.getLowBits = function() {
            return this.low;
        }, Long.prototype.getLowBitsUnsigned = function() {
            return this.low >>> 0;
        }, Long.prototype.getNumBitsAbs = function() {
            if (this.isNegative()) return this.equals(Long.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
            for (var val = 0 != this.high ? this.high : this.low, bit = 31; bit > 0 && 0 == (val & 1 << bit); bit--) ;
            return 0 != this.high ? bit + 33 : bit + 1;
        }, Long.prototype.isZero = function() {
            return 0 === this.high && 0 === this.low;
        }, Long.prototype.isNegative = function() {
            return !this.unsigned && this.high < 0;
        }, Long.prototype.isPositive = function() {
            return this.unsigned || this.high >= 0;
        }, Long.prototype.isOdd = function() {
            return 1 == (1 & this.low);
        }, Long.prototype.isEven = function() {
            return 0 == (1 & this.low);
        }, Long.prototype.equals = function(other) {
            return Long.isLong(other) || (other = Long.fromValue(other)), (this.unsigned === other.unsigned || this.high >>> 31 != 1 || other.high >>> 31 != 1) && this.high === other.high && this.low === other.low;
        }, Long.eq = Long.prototype.equals, Long.prototype.notEquals = function(other) {
            return !this.equals(other);
        }, Long.neq = Long.prototype.notEquals, Long.prototype.lessThan = function(other) {
            return this.compare(other) < 0;
        }, Long.prototype.lt = Long.prototype.lessThan, Long.prototype.lessThanOrEqual = function(other) {
            return this.compare(other) <= 0;
        }, Long.prototype.lte = Long.prototype.lessThanOrEqual, Long.prototype.greaterThan = function(other) {
            return this.compare(other) > 0;
        }, Long.prototype.gt = Long.prototype.greaterThan, Long.prototype.greaterThanOrEqual = function(other) {
            return this.compare(other) >= 0;
        }, Long.prototype.gte = Long.prototype.greaterThanOrEqual, Long.prototype.compare = function(other) {
            if (Long.isLong(other) || (other = Long.fromValue(other)), this.equals(other)) return 0;
            var thisNeg = this.isNegative(), otherNeg = other.isNegative();
            return thisNeg && !otherNeg ? -1 : !thisNeg && otherNeg ? 1 : this.unsigned ? other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.subtract(other).isNegative() ? -1 : 1;
        }, Long.prototype.negate = function() {
            return !this.unsigned && this.equals(Long.MIN_VALUE) ? Long.MIN_VALUE : this.not().add(Long.ONE);
        }, Long.prototype.neg = Long.prototype.negate, Long.prototype.add = function(addend) {
            Long.isLong(addend) || (addend = Long.fromValue(addend));
            var a48 = this.high >>> 16, a32 = 65535 & this.high, a16 = this.low >>> 16, a00 = 65535 & this.low, b48 = addend.high >>> 16, b32 = 65535 & addend.high, b16 = addend.low >>> 16, c48 = 0, c32 = 0, c16 = 0, c00 = 0;
            return c16 += (c00 += a00 + (65535 & addend.low)) >>> 16, c00 &= 65535, c32 += (c16 += a16 + b16) >>> 16, 
            c16 &= 65535, c48 += (c32 += a32 + b32) >>> 16, c32 &= 65535, c48 += a48 + b48, 
            c48 &= 65535, Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        }, Long.prototype.subtract = function(subtrahend) {
            return Long.isLong(subtrahend) || (subtrahend = Long.fromValue(subtrahend)), this.add(subtrahend.negate());
        }, Long.prototype.sub = Long.prototype.subtract, Long.prototype.multiply = function(multiplier) {
            if (this.isZero()) return Long.ZERO;
            if (Long.isLong(multiplier) || (multiplier = Long.fromValue(multiplier)), multiplier.isZero()) return Long.ZERO;
            if (this.equals(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
            if (multiplier.equals(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
            if (this.isNegative()) return multiplier.isNegative() ? this.negate().multiply(multiplier.negate()) : this.negate().multiply(multiplier).negate();
            if (multiplier.isNegative()) return this.multiply(multiplier.negate()).negate();
            if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
            var a48 = this.high >>> 16, a32 = 65535 & this.high, a16 = this.low >>> 16, a00 = 65535 & this.low, b48 = multiplier.high >>> 16, b32 = 65535 & multiplier.high, b16 = multiplier.low >>> 16, b00 = 65535 & multiplier.low, c48 = 0, c32 = 0, c16 = 0, c00 = 0;
            return c16 += (c00 += a00 * b00) >>> 16, c00 &= 65535, c32 += (c16 += a16 * b00) >>> 16, 
            c16 &= 65535, c32 += (c16 += a00 * b16) >>> 16, c16 &= 65535, c48 += (c32 += a32 * b00) >>> 16, 
            c32 &= 65535, c48 += (c32 += a16 * b16) >>> 16, c32 &= 65535, c48 += (c32 += a00 * b32) >>> 16, 
            c32 &= 65535, c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48, c48 &= 65535, 
            Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        }, Long.prototype.mul = Long.prototype.multiply, Long.prototype.divide = function(divisor) {
            if (Long.isLong(divisor) || (divisor = Long.fromValue(divisor)), divisor.isZero()) throw new Error("division by zero");
            if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;
            var approx, rem, res;
            if (this.equals(Long.MIN_VALUE)) return divisor.equals(Long.ONE) || divisor.equals(Long.NEG_ONE) ? Long.MIN_VALUE : divisor.equals(Long.MIN_VALUE) ? Long.ONE : (approx = this.shiftRight(1).divide(divisor).shiftLeft(1)).equals(Long.ZERO) ? divisor.isNegative() ? Long.ONE : Long.NEG_ONE : (rem = this.subtract(divisor.multiply(approx)), 
            res = approx.add(rem.divide(divisor)));
            if (divisor.equals(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;
            if (this.isNegative()) return divisor.isNegative() ? this.negate().divide(divisor.negate()) : this.negate().divide(divisor).negate();
            if (divisor.isNegative()) return this.divide(divisor.negate()).negate();
            for (res = Long.ZERO, rem = this; rem.greaterThanOrEqual(divisor); ) {
                approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
                for (var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48), approxRes = Long.fromNumber(approx), approxRem = approxRes.multiply(divisor); approxRem.isNegative() || approxRem.greaterThan(rem); ) approx -= delta, 
                approxRem = (approxRes = Long.fromNumber(approx, this.unsigned)).multiply(divisor);
                approxRes.isZero() && (approxRes = Long.ONE), res = res.add(approxRes), rem = rem.subtract(approxRem);
            }
            return res;
        }, Long.prototype.div = Long.prototype.divide, Long.prototype.modulo = function(divisor) {
            return Long.isLong(divisor) || (divisor = Long.fromValue(divisor)), this.subtract(this.divide(divisor).multiply(divisor));
        }, Long.prototype.mod = Long.prototype.modulo, Long.prototype.not = function() {
            return Long.fromBits(~this.low, ~this.high, this.unsigned);
        }, Long.prototype.and = function(other) {
            return Long.isLong(other) || (other = Long.fromValue(other)), Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        }, Long.prototype.or = function(other) {
            return Long.isLong(other) || (other = Long.fromValue(other)), Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        }, Long.prototype.xor = function(other) {
            return Long.isLong(other) || (other = Long.fromValue(other)), Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        }, Long.prototype.shiftLeft = function(numBits) {
            return Long.isLong(numBits) && (numBits = numBits.toInt()), 0 == (numBits &= 63) ? this : numBits < 32 ? Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned) : Long.fromBits(0, this.low << numBits - 32, this.unsigned);
        }, Long.prototype.shl = Long.prototype.shiftLeft, Long.prototype.shiftRight = function(numBits) {
            return Long.isLong(numBits) && (numBits = numBits.toInt()), 0 == (numBits &= 63) ? this : numBits < 32 ? Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned) : Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        }, Long.prototype.shr = Long.prototype.shiftRight, Long.prototype.shiftRightUnsigned = function(numBits) {
            if (Long.isLong(numBits) && (numBits = numBits.toInt()), 0 == (numBits &= 63)) return this;
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            }
            return 32 === numBits ? Long.fromBits(high, 0, this.unsigned) : Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
        }, Long.prototype.shru = Long.prototype.shiftRightUnsigned, Long.prototype.toSigned = function() {
            return this.unsigned ? new Long(this.low, this.high, !1) : this;
        }, Long.prototype.toUnsigned = function() {
            return this.unsigned ? this : new Long(this.low, this.high, !0);
        }, Long;
    }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, []) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function(module, exports) {
    module.exports = require("memcpy");
}, function(module, exports) {
    module.exports = {
        package: "extensions.api.cast_channel",
        messages: [ {
            name: "CastMessage",
            fields: [ {
                rule: "required",
                options: {},
                type: "ProtocolVersion",
                name: "protocol_version",
                id: 1
            }, {
                rule: "required",
                options: {},
                type: "string",
                name: "source_id",
                id: 2
            }, {
                rule: "required",
                options: {},
                type: "string",
                name: "destination_id",
                id: 3
            }, {
                rule: "required",
                options: {},
                type: "string",
                name: "namespace",
                id: 4
            }, {
                rule: "required",
                options: {},
                type: "PayloadType",
                name: "payload_type",
                id: 5
            }, {
                rule: "optional",
                options: {},
                type: "string",
                name: "payload_utf8",
                id: 6
            }, {
                rule: "optional",
                options: {},
                type: "bytes",
                name: "payload_binary",
                id: 7
            } ],
            enums: [ {
                name: "ProtocolVersion",
                values: [ {
                    name: "CASTV2_1_0",
                    id: 0
                } ],
                options: {}
            }, {
                name: "PayloadType",
                values: [ {
                    name: "STRING",
                    id: 0
                }, {
                    name: "BINARY",
                    id: 1
                } ],
                options: {}
            } ],
            messages: [],
            options: {},
            oneofs: {}
        }, {
            name: "AuthChallenge",
            fields: [],
            enums: [],
            messages: [],
            options: {},
            oneofs: {}
        }, {
            name: "AuthResponse",
            fields: [ {
                rule: "required",
                options: {},
                type: "bytes",
                name: "signature",
                id: 1
            }, {
                rule: "required",
                options: {},
                type: "bytes",
                name: "client_auth_certificate",
                id: 2
            }, {
                rule: "repeated",
                options: {},
                type: "bytes",
                name: "client_ca",
                id: 3
            } ],
            enums: [],
            messages: [],
            options: {},
            oneofs: {}
        }, {
            name: "AuthError",
            fields: [ {
                rule: "required",
                options: {},
                type: "ErrorType",
                name: "error_type",
                id: 1
            } ],
            enums: [ {
                name: "ErrorType",
                values: [ {
                    name: "INTERNAL_ERROR",
                    id: 0
                }, {
                    name: "NO_TLS",
                    id: 1
                } ],
                options: {}
            } ],
            messages: [],
            options: {},
            oneofs: {}
        }, {
            name: "DeviceAuthMessage",
            fields: [ {
                rule: "optional",
                options: {},
                type: "AuthChallenge",
                name: "challenge",
                id: 1
            }, {
                rule: "optional",
                options: {},
                type: "AuthResponse",
                name: "response",
                id: 2
            }, {
                rule: "optional",
                options: {},
                type: "AuthError",
                name: "error",
                id: 3
            } ],
            enums: [],
            messages: [],
            options: {},
            oneofs: {}
        } ],
        enums: [],
        imports: [],
        options: {
            optimize_for: "LITE_RUNTIME"
        },
        services: []
    };
}, function(module, exports, __webpack_require__) {
    var EventEmitter = __webpack_require__(5).EventEmitter, util = __webpack_require__(0);
    function Channel(bus, sourceId, destinationId, namespace, encoding) {
        EventEmitter.call(this), this.bus = bus, this.sourceId = sourceId, this.destinationId = destinationId, 
        this.namespace = namespace, this.encoding = encoding;
        var self = this;
        function onmessage(sourceId, destinationId, namespace, data) {
            sourceId === self.destinationId && (destinationId !== self.sourceId && "*" !== destinationId || namespace === self.namespace && self.emit("message", (function(data, encoding) {
                if (!encoding) return data;
                if ("JSON" === encoding) return JSON.parse(data);
                throw new Error("Unsupported channel encoding: " + encoding);
            })(data, self.encoding), "*" === destinationId));
        }
        this.bus.on("message", onmessage), this.bus.on("close", self.close), this.once("close", (function() {
            self.bus.removeListener("message", onmessage);
        }));
    }
    __webpack_require__(8)("castv2"), util.inherits(Channel, EventEmitter), Channel.prototype.send = function(data) {
        this.bus.send(this.sourceId, this.destinationId, this.namespace, (function(data, encoding) {
            if (!encoding) return data;
            if ("JSON" === encoding) return JSON.stringify(data);
            throw new Error("Unsupported channel encoding: " + encoding);
        })(data, this.encoding));
    }, Channel.prototype.close = function() {
        this.emit("close");
    }, module.exports = Channel;
}, function(module, exports, __webpack_require__) {
    var EventEmitter = __webpack_require__(5).EventEmitter, util = __webpack_require__(0), tls = __webpack_require__(92), debug = __webpack_require__(8)("castv2"), protocol = __webpack_require__(222), PacketStreamWrapper = __webpack_require__(446), CastMessage = protocol.CastMessage;
    function Server(options) {
        EventEmitter.call(this), this.server = new tls.Server(options), this.clients = {};
    }
    function genClientId(socket) {
        return [ socket.remoteAddress, socket.remotePort ].join(":");
    }
    util.inherits(Server, EventEmitter), Server.prototype.listen = function(port, host, callback) {
        var self = this, args = Array.prototype.slice.call(arguments);
        function onlisten() {
            var addr = self.server.address();
            debug("server listening on %s:%d", addr.address, addr.port), callback && callback();
        }
        function onconnect(socket) {
            debug("connection from %s:%d", socket.remoteAddress, socket.remotePort);
            var ps = new PacketStreamWrapper(socket), clientId = genClientId(socket);
            function onpacket(buf) {
                var message = CastMessage.parse(buf);
                if (debug("recv message: clientId=%s protocolVersion=%s sourceId=%s destinationId=%s namespace=%s data=%s", clientId, message.protocol_version, message.source_id, message.destination_id, message.namespace, 1 === message.payload_type ? util.inspect(message.payload_binary) : message.payload_utf8), 
                0 !== message.protocol_version) return debug("client error: clientId=%s unsupported protocol version (%s)", clientId, message.protocolVersion), 
                void self.clients[clientId].socket.end();
                self.emit("message", clientId, message.source_id, message.destination_id, message.namespace, 1 === message.payload_type ? message.payload_binary : message.payload_utf8);
            }
            ps.on("packet", onpacket), socket.once("close", (function() {
                debug("client %s disconnected", clientId), ps.removeListener("packet", onpacket), 
                delete self.clients[clientId];
            })), self.clients[clientId] = {
                socket: socket,
                ps: ps
            };
        }
        function onshutdown() {
            debug("server shutting down"), self.server.removeListener("secureConnection", onconnect), 
            self.emit("close");
        }
        function onerror(err) {
            debug("error: %s %j", err.message, err), self.emit("error", err);
        }
        "function" == typeof args[args.length - 1] && (callback = args.pop()), this.server.listen.apply(this.server, args.concat([ onlisten ])), 
        this.server.on("secureConnection", onconnect), this.server.on("error", onerror), 
        this.server.once("close", onshutdown);
    }, Server.prototype.close = function() {
        for (var clientId in this.server.close(), this.clients) this.clients[clientId].socket.end();
    }, Server.prototype.send = function(clientId, sourceId, destinationId, namespace, data) {
        var message = {
            protocol_version: 0,
            source_id: sourceId,
            destination_id: destinationId,
            namespace: namespace
        };
        Buffer.isBuffer(data) ? (message.payload_type = 1, message.payload_binary = data) : (message.payload_type = 0, 
        message.payload_utf8 = data), debug("send message: clientId=%s protocolVersion=%s sourceId=%s destinationId=%s namespace=%s data=%s", clientId, message.protocol_version, message.source_id, message.destination_id, message.namespace, 1 === message.payload_type ? util.inspect(message.payload_binary) : message.payload_utf8);
        var buf = CastMessage.serialize(message);
        this.clients[clientId].ps.send(buf);
    }, module.exports = Server;
}, function(module, exports, __webpack_require__) {
    "use strict";
    __webpack_require__(7);
    var querystring = __webpack_require__(28), Promise = __webpack_require__(219), MediaRendererClient = (__webpack_require__(33), 
    Promise.promisifyAll(__webpack_require__(440)), __webpack_require__(31), __webpack_require__(162), 
    __webpack_require__(952)), util = __webpack_require__(0), castingUtils = __webpack_require__(218), Player = __webpack_require__(447);
    function DLNAClient(device, executables) {
        Player.call(this, device), this.device = device, this.seekTime = 0, this.stateFlags = 1, 
        this.executables = executables, this.videoDuration = {}, this._handleError = this._handleError.bind(this), 
        this._updateStatus = this._updateStatus.bind(this);
        var client = new MediaRendererClient(device.location);
        this.player = Promise.promisifyAll(client);
        var self = this;
        client.on("status", this._updateStatus), client.on("loading", (function() {
            self._updateStatusField("state", "TRANSITIONING");
        })), client.on("playing", (function() {
            self._updateStatusField("state", "PLAYING");
        })), client.on("paused", (function() {
            self._updateStatusField("state", "PAUSED_PLAYBACK");
        })), client.on("stopped", (function() {
            self._updateStatusField("state", "STOPPED");
        })), client.on("error", this._handleError);
    }
    util.inherits(DLNAClient, Player), DLNAClient.FLAG_DISABLE_UPDATES = 2, DLNAClient.PLAYBACK_DELAY = 3e3, 
    DLNAClient.prototype._handleError = function(err) {
        this.mediaStatus.state = 7, console.log(err.toString());
    }, DLNAClient.prototype._updateStatusField = function(field, value) {
        if (void 0 !== value && !(this.stateFlags & DLNAClient.FLAG_DISABLE_UPDATES)) switch (field) {
          case "state":
            this.mediaStatus.realStatus = value, this.mediaStatus[field] = {
                IDLE: 0,
                TRANSITIONING: 2,
                PLAYING: 3,
                PAUSED_PLAYBACK: 4,
                STOPPED: 5,
                NO_MEDIA_PRESENT: 6,
                ERROR_OCCURRED: 7
            }[value], 6 == this.mediaStatus[field] && this.stateFlags && (this.mediaStatus[field] = 5), 
            this.mediaStatus.paused = 4 == this.mediaStatus[field];
            break;

          case "time":
            this.mediaStatus[field] = this.seekTime + 1e3 * parseInt(value, 10);
            break;

          case "volume":
            this.mediaStatus[field] = parseFloat(value, 10) / 100;
            break;

          default:
            this.mediaStatus[field] = value;
        }
    }, DLNAClient.prototype._updateStatus = function(status) {
        status && (this._updateStatusField("state", status.TransportState), this._updateStatusField("time", status.CurrentTrackPosition), 
        this._updateStatusField("volume", status.CurrentVolume));
    }, DLNAClient.prototype.middleware = function(req, res, next) {
        return this.setEndpoint(req), this.transcodeURL = this.endpoint + req.baseUrl + "/transcode.mp4", 
        Player.prototype.middleware.call(this, req, res, next);
    }, DLNAClient.prototype.init = function() {
        var self = this;
        return Promise.all([ this.player.getPositionAsync(), this.player.getVolumeAsync() ]).then((function(res) {
            return self._updateStatus({
                CurrentTrackPosition: res[0],
                CurrentVolume: res[1]
            }), self.mediaStatus;
        }));
    }, DLNAClient.prototype._simplePlayerCommand = function(cmd, args) {
        return args = args || [], this.player[cmd].apply(this.player, args).then(this.status.bind(this));
    }, DLNAClient.prototype.status = function() {
        return Promise.resolve(this.mediaStatus);
    }, DLNAClient.prototype.playFromStatus = function() {
        if (!this.mediaStatus.source) return Promise.reject("No source!");
        this.stateFlags |= DLNAClient.FLAG_DISABLE_UPDATES, this.mediaStatus.state = 3, 
        this.seekTime = this.mediaStatus.time;
        var options = {
            autoplay: !0,
            contentType: "video/x-mkv",
            metadata: {
                title: "Video by Stremio",
                creator: "Stremio",
                type: "video"
            }
        }, proxySrv = this.transcodeURL + "?" + querystring.stringify({
            video: this.mediaStatus.source,
            audioTrack: this.mediaStatus.audioTrack,
            time: this.mediaStatus.time / 1e3 || 0,
            subtitles: this.mediaStatus.subtitlesSrc,
            subtitlesDelay: this.mediaStatus.subtitlesDelay
        }), self = this;
        return this.player.stopAsync().catch(Function.prototype).then((function() {
            return self.stateFlags &= ~DLNAClient.FLAG_DISABLE_UPDATES, self.player.loadAsync(proxySrv, options);
        }));
    }, DLNAClient.prototype.delayedPlayFromStatus = function() {
        clearTimeout(this.deferedPlay), this.stateFlags |= DLNAClient.FLAG_DISABLE_UPDATES, 
        this.mediaStatus.state = 3;
        var playFromStatus = this.playFromStatus.bind(this);
        return this.deferedPlay = setTimeout(playFromStatus, DLNAClient.PLAYBACK_DELAY), 
        this.mediaStatus;
    }, DLNAClient.prototype.play = function(srcURL) {
        this.mediaStatus.source = srcURL, this.mediaStatus.time = 0, this.mediaStatus.subtitlesSrc = null, 
        this.mediaStatus.subtitlesDelay = 0;
        var self = this;
        return castingUtils.getVideoInfo(this.executables.ffmpeg, srcURL).then((function(info) {
            return self.mediaStatus.audio = info.streams.filter((function(stream) {
                return "Audio" === stream.type;
            })), self.mediaStatus.audioTrack = (self.mediaStatus.audio[0] || {}).id, self.stateFlags = 0, 
            self.mediaStatus.length = 1e3 * info.duration, self.delayedPlayFromStatus();
        }));
    }, DLNAClient.prototype.audioTrack = function(audioTrack, offset) {
        return offset && console.log("Audio track offset is not implemented yet"), this.mediaStatus.source ? (this.mediaStatus.audioTrack = audioTrack, 
        this.delayedPlayFromStatus()) : this.status();
    }, DLNAClient.prototype.subtitles = function(subsURL, offset, style) {
        return this.mediaStatus.source ? (this.mediaStatus.subtitlesSrc = subsURL, this.mediaStatus.subtitlesDelay = offset, 
        this.delayedPlayFromStatus()) : this.status();
    }, DLNAClient.prototype.resume = function() {
        return this._simplePlayerCommand("playAsync");
    }, DLNAClient.prototype.pause = function() {
        return this._simplePlayerCommand("pauseAsync");
    }, DLNAClient.prototype.stop = function() {
        return this._simplePlayerCommand("stopAsync");
    }, DLNAClient.prototype.seek = function(time) {
        return 3 != this.mediaStatus.state ? this.status() : (this.mediaStatus.time = parseInt(time, 10), 
        this.delayedPlayFromStatus());
    }, DLNAClient.prototype.volume = function(vol) {
        return this._simplePlayerCommand("setVolumeAsync", [ 100 * parseFloat(vol, 10) ]);
    }, DLNAClient.prototype.close = function() {
        return this.stateFlags = 1, this.stop();
    }, module.exports = DLNAClient;
}, function(module, exports, __webpack_require__) {
    var DeviceClient = __webpack_require__(953), util = __webpack_require__(0), et = (__webpack_require__(8)("upnp-mediarenderer-client"), 
    __webpack_require__(223)), MEDIA_EVENTS = [ "status", "loading", "playing", "paused", "stopped", "speedChanged" ];
    function MediaRendererClient(url) {
        DeviceClient.call(this, url), this.instanceId = 0;
        var receivedState, self = this, refs = 0;
        function onstatus(e) {
            if (self.emit("status", e), receivedState) {
                if (e.hasOwnProperty("TransportState")) switch (e.TransportState) {
                  case "TRANSITIONING":
                    self.emit("loading");
                    break;

                  case "PLAYING":
                    self.emit("playing");
                    break;

                  case "PAUSED_PLAYBACK":
                    self.emit("paused");
                    break;

                  case "STOPPED":
                    self.emit("stopped");
                }
                e.hasOwnProperty("TransportPlaySpeed") && self.emit("speedChanged", Number(e.TransportPlaySpeed));
            } else receivedState = !0;
        }
        this.addListener("newListener", (function(eventName, listener) {
            -1 !== MEDIA_EVENTS.indexOf(eventName) && (0 === refs && (receivedState = !1, self.subscribe("AVTransport", onstatus)), 
            refs++);
        })), this.addListener("removeListener", (function(eventName, listener) {
            -1 !== MEDIA_EVENTS.indexOf(eventName) && 0 == --refs && self.unsubscribe("AVTransport", onstatus);
        }));
    }
    function formatTime(seconds) {
        var s, h = 0, m = 0;
        function pad(v) {
            return v < 10 ? "0" + v : v;
        }
        return s = seconds - 3600 * (h = Math.floor((seconds - 0 * h - 0 * m) / 3600)) - 60 * (m = Math.floor((seconds - 3600 * h - 0 * m) / 60)), 
        [ pad(h), pad(m), pad(s) ].join(":");
    }
    function parseTime(time) {
        var parts = time.split(":").map(Number);
        return 3600 * parts[0] + 60 * parts[1] + parts[2];
    }
    function buildMetadata(metadata) {
        var didl = et.Element("DIDL-Lite");
        didl.set("xmlns", "urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/"), didl.set("xmlns:dc", "http://purl.org/dc/elements/1.1/"), 
        didl.set("xmlns:upnp", "urn:schemas-upnp-org:metadata-1-0/upnp/"), didl.set("xmlns:sec", "http://www.sec.co.kr/");
        var item = et.SubElement(didl, "item");
        if (item.set("id", 0), item.set("parentID", -1), item.set("restricted", !1), metadata.type && (et.SubElement(item, "upnp:class").text = {
            audio: "object.item.audioItem.musicTrack",
            video: "object.item.videoItem.movie",
            image: "object.item.imageItem.photo"
        }[metadata.type]), metadata.title && (et.SubElement(item, "dc:title").text = metadata.title), 
        metadata.creator && (et.SubElement(item, "dc:creator").text = metadata.creator), 
        metadata.url && metadata.protocolInfo && ((res = et.SubElement(item, "res")).set("protocolInfo", metadata.protocolInfo), 
        res.text = metadata.url), metadata.subtitlesUrl) {
            var captionInfo = et.SubElement(item, "sec:CaptionInfo");
            captionInfo.set("sec:type", "srt"), captionInfo.text = metadata.subtitlesUrl;
            var res, captionInfoEx = et.SubElement(item, "sec:CaptionInfoEx");
            captionInfoEx.set("sec:type", "srt"), captionInfoEx.text = metadata.subtitlesUrl, 
            (res = et.SubElement(item, "res")).set("protocolInfo", "http-get:*:text/srt:*"), 
            res.text = metadata.subtitlesUrl;
        }
        return new et.ElementTree(didl).write({
            xml_declaration: !1
        });
    }
    function noop() {}
    util.inherits(MediaRendererClient, DeviceClient), MediaRendererClient.prototype.getSupportedProtocols = function(callback) {
        this.callAction("ConnectionManager", "GetProtocolInfo", {}, (function(err, result) {
            if (err) return callback(err);
            var protocols = result.Sink.split(",").map((function(line) {
                var tmp = line.split(":");
                return {
                    protocol: tmp[0],
                    network: tmp[1],
                    contentFormat: tmp[2],
                    additionalInfo: tmp[3]
                };
            }));
            callback(null, protocols);
        }));
    }, MediaRendererClient.prototype.getPosition = function(callback) {
        this.callAction("AVTransport", "GetPositionInfo", {
            InstanceID: this.instanceId
        }, (function(err, result) {
            if (err) return callback(err);
            var str = "NOT_IMPLEMENTED" !== result.AbsTime ? result.AbsTime : result.RelTime;
            callback(null, parseTime(str));
        }));
    }, MediaRendererClient.prototype.getDuration = function(callback) {
        this.callAction("AVTransport", "GetMediaInfo", {
            InstanceID: this.instanceId
        }, (function(err, result) {
            if (err) return callback(err);
            callback(null, parseTime(result.MediaDuration));
        }));
    }, MediaRendererClient.prototype.load = function(url, options, callback) {
        var self = this;
        "function" == typeof options && (callback = options, options = {});
        var protocolInfo = "http-get:*:" + (options.contentType || "video/mpeg") + ":*", metadata = options.metadata || {};
        metadata.url = url, metadata.protocolInfo = protocolInfo;
        var params = {
            RemoteProtocolInfo: protocolInfo,
            PeerConnectionManager: null,
            PeerConnectionID: -1,
            Direction: "Input"
        };
        this.callAction("ConnectionManager", "PrepareForConnection", params, (function(err, result) {
            if (err) {
                if ("ENOACTION" !== err.code) return callback(err);
            } else self.instanceId = result.AVTransportID;
            var params = {
                InstanceID: self.instanceId,
                CurrentURI: url,
                CurrentURIMetaData: buildMetadata(metadata)
            };
            self.callAction("AVTransport", "SetAVTransportURI", params, (function(err) {
                if (err) return callback(err);
                options.autoplay ? self.play(callback) : callback();
            }));
        }));
    }, MediaRendererClient.prototype.play = function(callback) {
        var params = {
            InstanceID: this.instanceId,
            Speed: 1
        };
        this.callAction("AVTransport", "Play", params, callback || noop);
    }, MediaRendererClient.prototype.pause = function(callback) {
        var params = {
            InstanceID: this.instanceId
        };
        this.callAction("AVTransport", "Pause", params, callback || noop);
    }, MediaRendererClient.prototype.stop = function(callback) {
        var params = {
            InstanceID: this.instanceId
        };
        this.callAction("AVTransport", "Stop", params, callback || noop);
    }, MediaRendererClient.prototype.seek = function(seconds, callback) {
        var params = {
            InstanceID: this.instanceId,
            Unit: "REL_TIME",
            Target: formatTime(seconds)
        };
        this.callAction("AVTransport", "Seek", params, callback || noop);
    }, MediaRendererClient.prototype.getVolume = function(callback) {
        this.callAction("RenderingControl", "GetVolume", {
            InstanceID: this.instanceId,
            Channel: "Master"
        }, (function(err, result) {
            if (err) return callback(err);
            callback(null, parseInt(result.CurrentVolume));
        }));
    }, MediaRendererClient.prototype.setVolume = function(volume, callback) {
        var params = {
            InstanceID: this.instanceId,
            Channel: "Master",
            DesiredVolume: volume
        };
        this.callAction("RenderingControl", "SetVolume", params, callback || noop);
    }, module.exports = MediaRendererClient;
}, function(module, exports, __webpack_require__) {
    var http = __webpack_require__(11), util = __webpack_require__(0), EventEmitter = __webpack_require__(5).EventEmitter, et = __webpack_require__(223), parseUrl = __webpack_require__(7).parse, os = __webpack_require__(21), concat = __webpack_require__(961), address = __webpack_require__(966), debug = __webpack_require__(8)("upnp-device-client"), pkg = __webpack_require__(967), OS_VERSION = [ os.platform(), os.release() ].join("/"), PACKAGE_VERSION = [ pkg.name, pkg.version ].join("/");
    function DeviceClient(url) {
        EventEmitter.call(this), this.url = url, this.deviceDescription = null, this.serviceDescriptions = {}, 
        this.server = null, this.listening = !1, this.subscriptions = {};
    }
    function parseTimeout(header) {
        return Number(header.split("-")[1]);
    }
    function fetch(url, callback) {
        var req = http.get(url, (function(res) {
            if (200 !== res.statusCode) {
                var err = new Error("Request failed");
                return err.statusCode = res.statusCode, callback(err);
            }
            res.pipe(concat((function(buf) {
                callback(null, buf.toString());
            })));
        }));
        req.on("error", callback), req.end();
    }
    function extractFields(node, fields) {
        var data = {};
        return fields.forEach((function(field) {
            var value = node.findtext("./" + field);
            void 0 !== value && (data[field] = value);
        })), data;
    }
    function buildAbsoluteUrl(base, url) {
        return "" === url ? "" : "http" === url.substring(0, 4) ? url : "/" === url[0] ? base.split("/").slice(0, 3).join("/") + url : base + "/" + url;
    }
    function resolveService(serviceId) {
        return -1 === serviceId.indexOf(":") ? "urn:upnp-org:serviceId:" + serviceId : serviceId;
    }
    util.inherits(DeviceClient, EventEmitter), DeviceClient.prototype.getDeviceDescription = function(callback) {
        var self = this;
        this.deviceDescription ? process.nextTick((function() {
            callback(null, self.deviceDescription);
        })) : (debug("fetch device description"), fetch(this.url, (function(err, body) {
            if (err) return callback(err);
            var desc = (function(xml, url) {
                var doc = et.parse(xml), desc = extractFields(doc.find("./device"), [ "deviceType", "friendlyName", "manufacturer", "manufacturerURL", "modelName", "modelNumber", "modelDescription", "UDN" ]), nodes = doc.findall("./device/iconList/icon");
                desc.icons = nodes.map((function(icon) {
                    return extractFields(icon, [ "mimetype", "width", "height", "depth", "url" ]);
                })), nodes = doc.findall("./device/serviceList/service"), desc.services = {}, nodes.forEach((function(service) {
                    var tmp = extractFields(service, [ "serviceType", "serviceId", "SCPDURL", "controlURL", "eventSubURL" ]), id = tmp.serviceId;
                    delete tmp.serviceId, desc.services[id] = tmp;
                }));
                var baseUrl = (function(url) {
                    return url.split("/").slice(0, -1).join("/");
                })(url);
                return desc.icons.map((function(icon) {
                    return icon.url = buildAbsoluteUrl(baseUrl, icon.url), icon;
                })), Object.keys(desc.services).forEach((function(id) {
                    var service = desc.services[id];
                    service.SCPDURL = buildAbsoluteUrl(baseUrl, service.SCPDURL), service.controlURL = buildAbsoluteUrl(baseUrl, service.controlURL), 
                    service.eventSubURL = buildAbsoluteUrl(baseUrl, service.eventSubURL);
                })), desc;
            })(body, self.url);
            self.deviceDescription = desc, callback(null, desc);
        })));
    }, DeviceClient.prototype.getServiceDescription = function(serviceId, callback) {
        var self = this;
        serviceId = resolveService(serviceId), this.getDeviceDescription((function(err, desc) {
            if (err) return callback(err);
            var service = desc.services[serviceId];
            return service ? self.serviceDescriptions[serviceId] ? callback(null, self.serviceDescriptions[serviceId]) : (debug("fetch service description (%s)", serviceId), 
            void fetch(service.SCPDURL, (function(err, body) {
                if (err) return callback(err);
                var desc = (function(xml) {
                    var doc = et.parse(xml), desc = {
                        actions: {}
                    };
                    return doc.findall("./actionList/action").forEach((function(action) {
                        var name = action.findtext("./name"), inputs = [], outputs = [];
                        action.findall("./argumentList/argument").forEach((function(argument) {
                            var arg = extractFields(argument, [ "name", "direction", "relatedStateVariable" ]), direction = arg.direction;
                            delete arg.direction, "in" === direction ? inputs.push(arg) : outputs.push(arg);
                        })), desc.actions[name] = {
                            inputs: inputs,
                            outputs: outputs
                        };
                    })), desc.stateVariables = {}, doc.findall("./serviceStateTable/stateVariable").forEach((function(stateVariable) {
                        var name = stateVariable.findtext("./name"), allowedValues = stateVariable.findall("./allowedValueList/allowedValue").map((function(allowedValue) {
                            return allowedValue.text;
                        }));
                        desc.stateVariables[name] = {
                            dataType: stateVariable.findtext("./dataType"),
                            sendEvents: stateVariable.get("sendEvents"),
                            allowedValues: allowedValues,
                            defaultValue: stateVariable.findtext("./defaultValue")
                        };
                    })), desc;
                })(body);
                self.serviceDescriptions[serviceId] = desc, callback(null, desc);
            }))) : ((err = new Error("Service " + serviceId + " not provided by device")).code = "ENOSERVICE", 
            callback(err));
        }));
    }, DeviceClient.prototype.callAction = function(serviceId, actionName, params, callback) {
        var self = this;
        serviceId = resolveService(serviceId), this.getServiceDescription(serviceId, (function(err, desc) {
            if (err) return callback(err);
            if (!desc.actions[actionName]) return (err = new Error("Action " + actionName + " not implemented by service")).code = "ENOACTION", 
            callback(err);
            var service = self.deviceDescription.services[serviceId], envelope = et.Element("s:Envelope");
            envelope.set("xmlns:s", "http://schemas.xmlsoap.org/soap/envelope/"), envelope.set("s:encodingStyle", "http://schemas.xmlsoap.org/soap/encoding/");
            var body = et.SubElement(envelope, "s:Body"), action = et.SubElement(body, "u:" + actionName);
            action.set("xmlns:u", service.serviceType), Object.keys(params).forEach((function(paramName) {
                var tmp = et.SubElement(action, paramName), value = params[paramName];
                tmp.text = null === value ? "" : params[paramName].toString();
            }));
            var xml = new et.ElementTree(envelope).write({
                xml_declaration: !0
            }), options = parseUrl(service.controlURL);
            options.method = "POST", options.headers = {
                "Content-Type": 'text/xml; charset="utf-8"',
                "Content-Length": xml.length,
                Connection: "close",
                SOAPACTION: '"' + service.serviceType + "#" + actionName + '"'
            }, debug("call action %s on service %s with params %j", actionName, serviceId, params);
            var req = http.request(options, (function(res) {
                res.pipe(concat((function(buf) {
                    var doc = et.parse(buf.toString());
                    if (200 !== res.statusCode) {
                        var errorCode = doc.findtext(".//errorCode"), errorDescription = doc.findtext(".//errorDescription").trim(), err = new Error(errorDescription + " (" + errorCode + ")");
                        return err.code = "EUPNP", err.statusCode = res.statusCode, err.errorCode = errorCode, 
                        callback(err);
                    }
                    var outputs = self.serviceDescriptions[serviceId].actions[actionName].outputs.map((function(desc) {
                        return desc.name;
                    })), result = {};
                    outputs.forEach((function(name) {
                        result[name] = doc.findtext(".//" + name);
                    })), callback(null, result);
                })));
            }));
            req.on("error", callback), req.end(xml);
        }));
    }, DeviceClient.prototype.subscribe = function(serviceId, listener) {
        var self = this;
        serviceId = resolveService(serviceId), this.subscriptions[serviceId] ? this.subscriptions[serviceId].listeners.push(listener) : this.getDeviceDescription((function(err, desc) {
            if (err) return self.emit("error", err);
            var service = desc.services[serviceId];
            if (!service) return (err = new Error("Service " + serviceId + " not provided by device")).code = "ENOSERVICE", 
            self.emit("error", err);
            self.ensureEventingServer((function() {
                var options = parseUrl(service.eventSubURL), server = self.server;
                options.method = "SUBSCRIBE", options.headers = {
                    HOST: options.host,
                    "USER-AGENT": [ OS_VERSION, "UPnP/1.1", PACKAGE_VERSION ].join(" "),
                    CALLBACK: "<http://" + server.address().address + ":" + server.address().port + "/>",
                    NT: "upnp:event",
                    TIMEOUT: "Second-300"
                };
                var req = http.request(options, (function(res) {
                    if (200 !== res.statusCode) {
                        var err = new Error("SUBSCRIBE error");
                        return err.statusCode = res.statusCode, self.releaseEventingServer(), void self.emit("error", err);
                    }
                    var sid = res.headers.sid, timeout = parseTimeout(res.headers.timeout), renewTimeout = Math.max(timeout - 30, 30);
                    debug("renewing subscription to %s in %d seconds", serviceId, renewTimeout);
                    var timer = setTimeout((function renew() {
                        debug("renew subscription to %s", serviceId);
                        var options = parseUrl(service.eventSubURL);
                        options.method = "SUBSCRIBE", options.headers = {
                            HOST: options.host,
                            SID: sid,
                            TIMEOUT: "Second-300"
                        };
                        var req = http.request(options, (function(res) {
                            if (200 !== res.statusCode) {
                                var err = new Error("SUBSCRIBE renewal error");
                                return err.statusCode = res.statusCode, void self.emit("error", err);
                            }
                            var timeout = parseTimeout(res.headers.timeout), renewTimeout = Math.max(timeout - 30, 30);
                            debug("renewing subscription to %s in %d seconds", serviceId, renewTimeout);
                            var timer = setTimeout(renew, 1e3 * renewTimeout);
                            self.subscriptions[serviceId].timer = timer;
                        }));
                        req.on("error", (function(err) {
                            self.emit("error", err);
                        })), req.end();
                    }), 1e3 * renewTimeout);
                    self.subscriptions[serviceId] = {
                        sid: sid,
                        url: service.eventSubURL,
                        timer: timer,
                        listeners: [ listener ]
                    };
                }));
                req.on("error", (function(err) {
                    self.releaseEventingServer(), self.emit("error", err);
                })), req.end();
            }));
        }));
    }, DeviceClient.prototype.unsubscribe = function(serviceId, listener) {
        var self = this;
        serviceId = resolveService(serviceId);
        var subscription = this.subscriptions[serviceId];
        if (subscription) {
            var idx = subscription.listeners.indexOf(listener);
            if (-1 !== idx && (subscription.listeners.splice(idx, 1), 0 === subscription.listeners.length)) {
                debug("unsubscribe from service %s", serviceId);
                var options = parseUrl(subscription.url);
                options.method = "UNSUBSCRIBE", options.headers = {
                    HOST: options.host,
                    SID: subscription.sid
                };
                var req = http.request(options, (function(res) {
                    if (200 !== res.statusCode) {
                        var err = new Error("UNSUBSCRIBE error");
                        return err.statusCode = res.statusCode, self.emit("error", err);
                    }
                    clearTimeout(self.subscriptions[serviceId].timer), delete self.subscriptions[serviceId], 
                    self.releaseEventingServer();
                }));
                req.on("error", (function(err) {
                    self.emit("error", err);
                })), req.end();
            }
        }
    }, DeviceClient.prototype.ensureEventingServer = function(callback) {
        var self = this;
        this.server || (debug("create eventing server"), this.server = http.createServer((function(req, res) {
            req.pipe(concat((function(buf) {
                var sid = req.headers.sid, seq = req.headers.seq, events = (function(buf) {
                    var events = [], doc = et.parse(buf.toString()), lastChange = doc.findtext(".//LastChange");
                    if (lastChange) (doc = et.parse(lastChange)).findall("./InstanceID").forEach((function(instance) {
                        var data = {
                            InstanceID: Number(instance.get("val"))
                        };
                        instance.findall("./*").forEach((function(node) {
                            data[node.tag] = node.get("val");
                        })), events.push(data);
                    })); else {
                        var data = {};
                        doc.findall("./property/*").forEach((function(node) {
                            data[node.tag] = node.text;
                        })), events.push(data);
                    }
                    return events;
                })(buf);
                debug("received events %s %d %j", sid, seq, events);
                var keys = Object.keys(self.subscriptions), idx = keys.map((function(key) {
                    return self.subscriptions[key].sid;
                })).indexOf(sid);
                if (-1 !== idx) {
                    var serviceId = keys[idx];
                    self.subscriptions[serviceId].listeners.forEach((function(listener) {
                        events.forEach((function(e) {
                            listener(e);
                        }));
                    }));
                } else debug("WARNING unknown SID %s", sid);
            })));
        })), this.server.listen(0, address.ipv4())), this.listening ? process.nextTick(callback) : this.server.on("listening", (function() {
            self.listening = !0, callback();
        }));
    }, DeviceClient.prototype.releaseEventingServer = function() {
        0 === Object.keys(this.subscriptions).length && (debug("shutdown eventing server"), 
        this.server.close(), this.server = null, this.listening = !1);
    }, module.exports = DeviceClient;
}, function(module, exports, __webpack_require__) {
    var sprintf = __webpack_require__(224).sprintf, utils = __webpack_require__(448), SyntaxError = __webpack_require__(955).SyntaxError, _cache = {}, RE = new RegExp("('[^']*'|\"[^\"]*\"|::|//?|\\.\\.|\\(\\)|[/.*:\\[\\]\\(\\)@=])|((?:\\{[^}]+\\})?[^/\\[\\]\\(\\)@=\\s]+)|\\s+", "g"), xpath_tokenizer = utils.findall.bind(null, RE), ops = {
        "": function(next, token) {
            var tag = token[0];
            return function(context, result) {
                var i, len, rv = [];
                for (i = 0, len = result.length; i < len; i++) result[i]._children.forEach((function(e) {
                    e.tag === tag && rv.push(e);
                }));
                return rv;
            };
        },
        "*": function(next, token) {
            return function(context, result) {
                var i, len, rv = [];
                for (i = 0, len = result.length; i < len; i++) result[i]._children.forEach((function(e) {
                    rv.push(e);
                }));
                return rv;
            };
        },
        ".": function(next, token) {
            return function(context, result) {
                var i, len, elem, rv = [];
                for (i = 0, len = result.length; i < len; i++) elem = result[i], rv.push(elem);
                return rv;
            };
        },
        "..": function(next, token) {
            return function(context, result) {
                var i, len, elem, rv = [], parent_map = context.parent_map;
                for (parent_map || (context.parent_map = parent_map = {}, context.root.iter(null, (function(p) {
                    p._children.forEach((function(e) {
                        parent_map[e] = p;
                    }));
                }))), i = 0, len = result.length; i < len; i++) elem = result[i], parent_map.hasOwnProperty(elem) && rv.push(parent_map[elem]);
                return rv;
            };
        },
        "//": function(next, token) {
            var tag;
            if ("*" === (token = next())[1]) tag = "*"; else {
                if (token[1]) throw new SyntaxError(token);
                tag = token[0] || "";
            }
            return function(context, result) {
                var i, len, elem, rv = [];
                for (i = 0, len = result.length; i < len; i++) (elem = result[i]).iter(tag, (function(e) {
                    e !== elem && rv.push(e);
                }));
                return rv;
            };
        },
        "[": function(next, token) {
            var tag, key, value, select;
            if ("@" === (token = next())[1]) {
                if ((token = next())[1]) throw new SyntaxError(token, "Invalid attribute predicate");
                if (key = token[0], "]" === (token = next())[1]) select = function(context, result) {
                    var i, len, elem, rv = [];
                    for (i = 0, len = result.length; i < len; i++) (elem = result[i]).get(key) && rv.push(elem);
                    return rv;
                }; else if ("=" === token[1]) {
                    if ('"' !== (value = next()[1])[0] && "'" !== value[value.length - 1]) throw new SyntaxError(token, "Ivalid comparison target");
                    value = value.slice(1, value.length - 1), token = next(), select = function(context, result) {
                        var i, len, elem, rv = [];
                        for (i = 0, len = result.length; i < len; i++) (elem = result[i]).get(key) === value && rv.push(elem);
                        return rv;
                    };
                }
                if ("]" !== token[1]) throw new SyntaxError(token, "Invalid attribute predicate");
            } else {
                if (token[1]) throw new SyntaxError(null, "Invalid predicate");
                if (tag = token[0] || "", "]" !== (token = next())[1]) throw new SyntaxError(token, "Invalid node predicate");
                select = function(context, result) {
                    var i, len, elem, rv = [];
                    for (i = 0, len = result.length; i < len; i++) (elem = result[i]).find(tag) && rv.push(elem);
                    return rv;
                };
            }
            return select;
        }
    };
    function _SelectorContext(root) {
        this.parent_map = null, this.root = root;
    }
    function findall(elem, path) {
        var selector, result, i, len, token, value, select, context;
        if (_cache.hasOwnProperty(path)) selector = _cache[path]; else {
            if (Object.keys(_cache).length > 100 && (_cache = {}), "/" === path.charAt(0)) throw new SyntaxError(null, "Cannot use absolute path on element");
            function getToken() {
                return result.shift();
            }
            for (result = xpath_tokenizer(path), selector = [], token = getToken(); ;) {
                var c = token[1] || "";
                if (!(value = ops[c](getToken, token))) throw new SyntaxError(null, sprintf("Invalid path: %s", path));
                if (selector.push(value), !(token = getToken())) break;
                if ("/" === token[1] && (token = getToken()), !token) break;
            }
            _cache[path] = selector;
        }
        for (result = [ elem ], context = new _SelectorContext(elem), i = 0, len = selector.length; i < len; i++) select = selector[i], 
        result = select(context, result);
        return result || [];
    }
    exports.find = function(element, path) {
        var resultElements = findall(element, path);
        return resultElements && resultElements.length > 0 ? resultElements[0] : null;
    }, exports.findall = findall, exports.findtext = function(element, path, defvalue) {
        var resultElements = findall(element, path);
        return resultElements && resultElements.length > 0 ? resultElements[0].text : defvalue;
    };
}, function(module, exports, __webpack_require__) {
    var util = __webpack_require__(0), sprintf = __webpack_require__(224).sprintf;
    function SyntaxError(token, msg) {
        msg = msg || sprintf("Syntax Error at token %s", token.toString()), this.token = token, 
        this.message = msg, Error.call(this, msg);
    }
    util.inherits(SyntaxError, Error), exports.SyntaxError = SyntaxError;
}, function(module, exports, __webpack_require__) {
    __webpack_require__(0);
    var parsers = __webpack_require__(957);
    exports.get_parser = function(name) {
        if ("sax" === name) return parsers.sax;
        throw new Error("Invalid parser: " + name);
    };
}, function(module, exports, __webpack_require__) {
    exports.sax = __webpack_require__(958);
}, function(module, exports, __webpack_require__) {
    __webpack_require__(0);
    var sax = __webpack_require__(959), TreeBuilder = __webpack_require__(449).TreeBuilder;
    function XMLParser(target) {
        this.parser = sax.parser(!0), this.target = target || new TreeBuilder, this.parser.onopentag = this._handleOpenTag.bind(this), 
        this.parser.ontext = this._handleText.bind(this), this.parser.oncdata = this._handleCdata.bind(this), 
        this.parser.ondoctype = this._handleDoctype.bind(this), this.parser.oncomment = this._handleComment.bind(this), 
        this.parser.onclosetag = this._handleCloseTag.bind(this), this.parser.onerror = this._handleError.bind(this);
    }
    XMLParser.prototype._handleOpenTag = function(tag) {
        this.target.start(tag.name, tag.attributes);
    }, XMLParser.prototype._handleText = function(text) {
        this.target.data(text);
    }, XMLParser.prototype._handleCdata = function(text) {
        this.target.data(text);
    }, XMLParser.prototype._handleDoctype = function(text) {}, XMLParser.prototype._handleComment = function(comment) {}, 
    XMLParser.prototype._handleCloseTag = function(tag) {
        this.target.end(tag);
    }, XMLParser.prototype._handleError = function(err) {
        throw err;
    }, XMLParser.prototype.feed = function(chunk) {
        this.parser.write(chunk);
    }, XMLParser.prototype.close = function() {
        return this.parser.close(), this.target.close();
    }, exports.XMLParser = XMLParser;
}, function(module, exports, __webpack_require__) {
    !(function(sax) {
        sax.parser = function(strict, opt) {
            return new SAXParser(strict, opt);
        }, sax.SAXParser = SAXParser, sax.SAXStream = SAXStream, sax.createStream = function(strict, opt) {
            return new SAXStream(strict, opt);
        }, sax.MAX_BUFFER_LENGTH = 65536;
        var Stream, buffers = [ "comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script" ];
        function SAXParser(strict, opt) {
            if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
            !(function(parser) {
                for (var i = 0, l = buffers.length; i < l; i++) parser[buffers[i]] = "";
            })(this), this.q = this.c = "", this.bufferCheckPosition = sax.MAX_BUFFER_LENGTH, 
            this.opt = opt || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, 
            this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], 
            this.closed = this.closedRoot = this.sawRoot = !1, this.tag = this.error = null, 
            this.strict = !!strict, this.noscript = !(!strict && !this.opt.noscript), this.state = S.BEGIN, 
            this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES), 
            this.attribList = [], this.opt.xmlns && (this.ns = Object.create(rootNS)), this.trackPosition = !1 !== this.opt.position, 
            this.trackPosition && (this.position = this.line = this.column = 0), emit(this, "onready");
        }
        sax.EVENTS = [ "text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace" ], 
        Object.create || (Object.create = function(o) {
            function F() {}
            return F.prototype = o, new F;
        }), Object.keys || (Object.keys = function(o) {
            var a = [];
            for (var i in o) o.hasOwnProperty(i) && a.push(i);
            return a;
        }), SAXParser.prototype = {
            end: function() {
                end(this);
            },
            write: function(chunk) {
                if (this.error) throw this.error;
                if (this.closed) return error(this, "Cannot write after close. Assign an onready handler.");
                if (null === chunk) return end(this);
                for (var parser, num, entity, entityLC, numStr, i = 0, c = ""; c = chunk.charAt(i++), 
                this.c = c, c; ) switch (this.trackPosition && (this.position++, "\n" === c ? (this.line++, 
                this.column = 0) : this.column++), this.state) {
                  case S.BEGIN:
                    if (this.state = S.BEGIN_WHITESPACE, "\ufeff" === c) continue;
                    beginWhiteSpace(this, c);
                    continue;

                  case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(this, c);
                    continue;

                  case S.TEXT:
                    if (this.sawRoot && !this.closedRoot) {
                        for (var starti = i - 1; c && "<" !== c && "&" !== c; ) (c = chunk.charAt(i++)) && this.trackPosition && (this.position++, 
                        "\n" === c ? (this.line++, this.column = 0) : this.column++);
                        this.textNode += chunk.substring(starti, i - 1);
                    }
                    "<" !== c || this.sawRoot && this.closedRoot && !this.strict ? (!not(whitespace, c) || this.sawRoot && !this.closedRoot || strictFail(this, "Text data outside of root node."), 
                    "&" === c ? this.state = S.TEXT_ENTITY : this.textNode += c) : (this.state = S.OPEN_WAKA, 
                    this.startTagPosition = this.position);
                    continue;

                  case S.SCRIPT:
                    "<" === c ? this.state = S.SCRIPT_ENDING : this.script += c;
                    continue;

                  case S.SCRIPT_ENDING:
                    "/" === c ? this.state = S.CLOSE_TAG : (this.script += "<" + c, this.state = S.SCRIPT);
                    continue;

                  case S.OPEN_WAKA:
                    if ("!" === c) this.state = S.SGML_DECL, this.sgmlDecl = ""; else if (is(whitespace, c)) ; else if (is(nameStart, c)) this.state = S.OPEN_TAG, 
                    this.tagName = c; else if ("/" === c) this.state = S.CLOSE_TAG, this.tagName = ""; else if ("?" === c) this.state = S.PROC_INST, 
                    this.procInstName = this.procInstBody = ""; else {
                        if (strictFail(this, "Unencoded <"), this.startTagPosition + 1 < this.position) {
                            var pad = this.position - this.startTagPosition;
                            c = new Array(pad).join(" ") + c;
                        }
                        this.textNode += "<" + c, this.state = S.TEXT;
                    }
                    continue;

                  case S.SGML_DECL:
                    "[CDATA[" === (this.sgmlDecl + c).toUpperCase() ? (emitNode(this, "onopencdata"), 
                    this.state = S.CDATA, this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + c === "--" ? (this.state = S.COMMENT, 
                    this.comment = "", this.sgmlDecl = "") : "DOCTYPE" === (this.sgmlDecl + c).toUpperCase() ? (this.state = S.DOCTYPE, 
                    (this.doctype || this.sawRoot) && strictFail(this, "Inappropriately located doctype declaration"), 
                    this.doctype = "", this.sgmlDecl = "") : ">" === c ? (emitNode(this, "onsgmldeclaration", this.sgmlDecl), 
                    this.sgmlDecl = "", this.state = S.TEXT) : is(quote, c) ? (this.state = S.SGML_DECL_QUOTED, 
                    this.sgmlDecl += c) : this.sgmlDecl += c;
                    continue;

                  case S.SGML_DECL_QUOTED:
                    c === this.q && (this.state = S.SGML_DECL, this.q = ""), this.sgmlDecl += c;
                    continue;

                  case S.DOCTYPE:
                    ">" === c ? (this.state = S.TEXT, emitNode(this, "ondoctype", this.doctype), this.doctype = !0) : (this.doctype += c, 
                    "[" === c ? this.state = S.DOCTYPE_DTD : is(quote, c) && (this.state = S.DOCTYPE_QUOTED, 
                    this.q = c));
                    continue;

                  case S.DOCTYPE_QUOTED:
                    this.doctype += c, c === this.q && (this.q = "", this.state = S.DOCTYPE);
                    continue;

                  case S.DOCTYPE_DTD:
                    this.doctype += c, "]" === c ? this.state = S.DOCTYPE : is(quote, c) && (this.state = S.DOCTYPE_DTD_QUOTED, 
                    this.q = c);
                    continue;

                  case S.DOCTYPE_DTD_QUOTED:
                    this.doctype += c, c === this.q && (this.state = S.DOCTYPE_DTD, this.q = "");
                    continue;

                  case S.COMMENT:
                    "-" === c ? this.state = S.COMMENT_ENDING : this.comment += c;
                    continue;

                  case S.COMMENT_ENDING:
                    "-" === c ? (this.state = S.COMMENT_ENDED, this.comment = textopts(this.opt, this.comment), 
                    this.comment && emitNode(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + c, 
                    this.state = S.COMMENT);
                    continue;

                  case S.COMMENT_ENDED:
                    ">" !== c ? (strictFail(this, "Malformed comment"), this.comment += "--" + c, this.state = S.COMMENT) : this.state = S.TEXT;
                    continue;

                  case S.CDATA:
                    "]" === c ? this.state = S.CDATA_ENDING : this.cdata += c;
                    continue;

                  case S.CDATA_ENDING:
                    "]" === c ? this.state = S.CDATA_ENDING_2 : (this.cdata += "]" + c, this.state = S.CDATA);
                    continue;

                  case S.CDATA_ENDING_2:
                    ">" === c ? (this.cdata && emitNode(this, "oncdata", this.cdata), emitNode(this, "onclosecdata"), 
                    this.cdata = "", this.state = S.TEXT) : "]" === c ? this.cdata += "]" : (this.cdata += "]]" + c, 
                    this.state = S.CDATA);
                    continue;

                  case S.PROC_INST:
                    "?" === c ? this.state = S.PROC_INST_ENDING : is(whitespace, c) ? this.state = S.PROC_INST_BODY : this.procInstName += c;
                    continue;

                  case S.PROC_INST_BODY:
                    if (!this.procInstBody && is(whitespace, c)) continue;
                    "?" === c ? this.state = S.PROC_INST_ENDING : this.procInstBody += c;
                    continue;

                  case S.PROC_INST_ENDING:
                    ">" === c ? (emitNode(this, "onprocessinginstruction", {
                        name: this.procInstName,
                        body: this.procInstBody
                    }), this.procInstName = this.procInstBody = "", this.state = S.TEXT) : (this.procInstBody += "?" + c, 
                    this.state = S.PROC_INST_BODY);
                    continue;

                  case S.OPEN_TAG:
                    is(nameBody, c) ? this.tagName += c : (newTag(this), ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : (not(whitespace, c) && strictFail(this, "Invalid character in tag name"), 
                    this.state = S.ATTRIB));
                    continue;

                  case S.OPEN_TAG_SLASH:
                    ">" === c ? (openTag(this, !0), closeTag(this)) : (strictFail(this, "Forward-slash in opening tag not followed by >"), 
                    this.state = S.ATTRIB);
                    continue;

                  case S.ATTRIB:
                    if (is(whitespace, c)) continue;
                    ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : is(nameStart, c) ? (this.attribName = c, 
                    this.attribValue = "", this.state = S.ATTRIB_NAME) : strictFail(this, "Invalid attribute name");
                    continue;

                  case S.ATTRIB_NAME:
                    "=" === c ? this.state = S.ATTRIB_VALUE : ">" === c ? (strictFail(this, "Attribute without value"), 
                    this.attribValue = this.attribName, attrib(this), openTag(this)) : is(whitespace, c) ? this.state = S.ATTRIB_NAME_SAW_WHITE : is(nameBody, c) ? this.attribName += c : strictFail(this, "Invalid attribute name");
                    continue;

                  case S.ATTRIB_NAME_SAW_WHITE:
                    if ("=" === c) this.state = S.ATTRIB_VALUE; else {
                        if (is(whitespace, c)) continue;
                        strictFail(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", 
                        this.attribValue = "", emitNode(this, "onattribute", {
                            name: this.attribName,
                            value: ""
                        }), this.attribName = "", ">" === c ? openTag(this) : is(nameStart, c) ? (this.attribName = c, 
                        this.state = S.ATTRIB_NAME) : (strictFail(this, "Invalid attribute name"), this.state = S.ATTRIB);
                    }
                    continue;

                  case S.ATTRIB_VALUE:
                    if (is(whitespace, c)) continue;
                    is(quote, c) ? (this.q = c, this.state = S.ATTRIB_VALUE_QUOTED) : (strictFail(this, "Unquoted attribute value"), 
                    this.state = S.ATTRIB_VALUE_UNQUOTED, this.attribValue = c);
                    continue;

                  case S.ATTRIB_VALUE_QUOTED:
                    if (c !== this.q) {
                        "&" === c ? this.state = S.ATTRIB_VALUE_ENTITY_Q : this.attribValue += c;
                        continue;
                    }
                    attrib(this), this.q = "", this.state = S.ATTRIB_VALUE_CLOSED;
                    continue;

                  case S.ATTRIB_VALUE_CLOSED:
                    is(whitespace, c) ? this.state = S.ATTRIB : ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : is(nameStart, c) ? (strictFail(this, "No whitespace between attributes"), 
                    this.attribName = c, this.attribValue = "", this.state = S.ATTRIB_NAME) : strictFail(this, "Invalid attribute name");
                    continue;

                  case S.ATTRIB_VALUE_UNQUOTED:
                    if (not(attribEnd, c)) {
                        "&" === c ? this.state = S.ATTRIB_VALUE_ENTITY_U : this.attribValue += c;
                        continue;
                    }
                    attrib(this), ">" === c ? openTag(this) : this.state = S.ATTRIB;
                    continue;

                  case S.CLOSE_TAG:
                    if (this.tagName) ">" === c ? closeTag(this) : is(nameBody, c) ? this.tagName += c : this.script ? (this.script += "</" + this.tagName, 
                    this.tagName = "", this.state = S.SCRIPT) : (not(whitespace, c) && strictFail(this, "Invalid tagname in closing tag"), 
                    this.state = S.CLOSE_TAG_SAW_WHITE); else {
                        if (is(whitespace, c)) continue;
                        not(nameStart, c) ? this.script ? (this.script += "</" + c, this.state = S.SCRIPT) : strictFail(this, "Invalid tagname in closing tag.") : this.tagName = c;
                    }
                    continue;

                  case S.CLOSE_TAG_SAW_WHITE:
                    if (is(whitespace, c)) continue;
                    ">" === c ? closeTag(this) : strictFail(this, "Invalid characters in closing tag");
                    continue;

                  case S.TEXT_ENTITY:
                  case S.ATTRIB_VALUE_ENTITY_Q:
                  case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState, buffer;
                    switch (this.state) {
                      case S.TEXT_ENTITY:
                        returnState = S.TEXT, buffer = "textNode";
                        break;

                      case S.ATTRIB_VALUE_ENTITY_Q:
                        returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue";
                        break;

                      case S.ATTRIB_VALUE_ENTITY_U:
                        returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue";
                    }
                    ";" === c ? (this[buffer] += (num = void 0, entity = void 0, entityLC = void 0, 
                    numStr = void 0, entity = (parser = this).entity, entityLC = entity.toLowerCase(), 
                    numStr = "", parser.ENTITIES[entity] ? parser.ENTITIES[entity] : parser.ENTITIES[entityLC] ? parser.ENTITIES[entityLC] : ("#" === (entity = entityLC).charAt(0) && ("x" === entity.charAt(1) ? (entity = entity.slice(2), 
                    numStr = (num = parseInt(entity, 16)).toString(16)) : (entity = entity.slice(1), 
                    numStr = (num = parseInt(entity, 10)).toString(10))), entity = entity.replace(/^0+/, ""), 
                    numStr.toLowerCase() !== entity ? (strictFail(parser, "Invalid character entity"), 
                    "&" + parser.entity + ";") : String.fromCodePoint(num))), this.entity = "", this.state = returnState) : is(this.entity.length ? entityBody : entityStart, c) ? this.entity += c : (strictFail(this, "Invalid character in entity name"), 
                    this[buffer] += "&" + this.entity + c, this.entity = "", this.state = returnState);
                    continue;

                  default:
                    throw new Error(this, "Unknown state: " + this.state);
                }
                return this.position >= this.bufferCheckPosition && (function(parser) {
                    for (var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10), maxActual = 0, i = 0, l = buffers.length; i < l; i++) {
                        var len = parser[buffers[i]].length;
                        if (len > maxAllowed) switch (buffers[i]) {
                          case "textNode":
                            closeText(parser);
                            break;

                          case "cdata":
                            emitNode(parser, "oncdata", parser.cdata), parser.cdata = "";
                            break;

                          case "script":
                            emitNode(parser, "onscript", parser.script), parser.script = "";
                            break;

                          default:
                            error(parser, "Max buffer length exceeded: " + buffers[i]);
                        }
                        maxActual = Math.max(maxActual, len);
                    }
                    var m = sax.MAX_BUFFER_LENGTH - maxActual;
                    parser.bufferCheckPosition = m + parser.position;
                })(this), this;
            },
            resume: function() {
                return this.error = null, this;
            },
            close: function() {
                return this.write(null);
            },
            flush: function() {
                closeText(this), "" !== this.cdata && (emitNode(this, "oncdata", this.cdata), this.cdata = ""), 
                "" !== this.script && (emitNode(this, "onscript", this.script), this.script = "");
            }
        };
        try {
            Stream = __webpack_require__(3).Stream;
        } catch (ex) {
            Stream = function() {};
        }
        var streamWraps = sax.EVENTS.filter((function(ev) {
            return "error" !== ev && "end" !== ev;
        }));
        function SAXStream(strict, opt) {
            if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
            Stream.apply(this), this._parser = new SAXParser(strict, opt), this.writable = !0, 
            this.readable = !0;
            var me = this;
            this._parser.onend = function() {
                me.emit("end");
            }, this._parser.onerror = function(er) {
                me.emit("error", er), me._parser.error = null;
            }, this._decoder = null, streamWraps.forEach((function(ev) {
                Object.defineProperty(me, "on" + ev, {
                    get: function() {
                        return me._parser["on" + ev];
                    },
                    set: function(h) {
                        if (!h) return me.removeAllListeners(ev), me._parser["on" + ev] = h, h;
                        me.on(ev, h);
                    },
                    enumerable: !0,
                    configurable: !1
                });
            }));
        }
        SAXStream.prototype = Object.create(Stream.prototype, {
            constructor: {
                value: SAXStream
            }
        }), SAXStream.prototype.write = function(data) {
            if ("function" == typeof Buffer && "function" == typeof Buffer.isBuffer && Buffer.isBuffer(data)) {
                if (!this._decoder) {
                    var SD = __webpack_require__(156).StringDecoder;
                    this._decoder = new SD("utf8");
                }
                data = this._decoder.write(data);
            }
            return this._parser.write(data.toString()), this.emit("data", data), !0;
        }, SAXStream.prototype.end = function(chunk) {
            return chunk && chunk.length && this.write(chunk), this._parser.end(), !0;
        }, SAXStream.prototype.on = function(ev, handler) {
            var me = this;
            return me._parser["on" + ev] || -1 === streamWraps.indexOf(ev) || (me._parser["on" + ev] = function() {
                var args = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments);
                args.splice(0, 0, ev), me.emit.apply(me, args);
            }), Stream.prototype.on.call(me, ev, handler);
        };
        var whitespace = "\r\n\t ", number = "0124356789", letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", quote = "'\"", attribEnd = whitespace + ">", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", rootNS = {
            xml: XML_NAMESPACE,
            xmlns: "http://www.w3.org/2000/xmlns/"
        };
        whitespace = charClass(whitespace), number = charClass(number), letter = charClass(letter);
        var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
        function charClass(str) {
            return str.split("").reduce((function(s, c) {
                return s[c] = !0, s;
            }), {});
        }
        function is(charclass, c) {
            return (function(c) {
                return "[object RegExp]" === Object.prototype.toString.call(c);
            })(charclass) ? !!c.match(charclass) : charclass[c];
        }
        function not(charclass, c) {
            return !is(charclass, c);
        }
        quote = charClass(quote), attribEnd = charClass(attribEnd);
        var stringFromCharCode, floor, fromCodePoint, S = 0;
        for (var s in sax.STATE = {
            BEGIN: S++,
            BEGIN_WHITESPACE: S++,
            TEXT: S++,
            TEXT_ENTITY: S++,
            OPEN_WAKA: S++,
            SGML_DECL: S++,
            SGML_DECL_QUOTED: S++,
            DOCTYPE: S++,
            DOCTYPE_QUOTED: S++,
            DOCTYPE_DTD: S++,
            DOCTYPE_DTD_QUOTED: S++,
            COMMENT_STARTING: S++,
            COMMENT: S++,
            COMMENT_ENDING: S++,
            COMMENT_ENDED: S++,
            CDATA: S++,
            CDATA_ENDING: S++,
            CDATA_ENDING_2: S++,
            PROC_INST: S++,
            PROC_INST_BODY: S++,
            PROC_INST_ENDING: S++,
            OPEN_TAG: S++,
            OPEN_TAG_SLASH: S++,
            ATTRIB: S++,
            ATTRIB_NAME: S++,
            ATTRIB_NAME_SAW_WHITE: S++,
            ATTRIB_VALUE: S++,
            ATTRIB_VALUE_QUOTED: S++,
            ATTRIB_VALUE_CLOSED: S++,
            ATTRIB_VALUE_UNQUOTED: S++,
            ATTRIB_VALUE_ENTITY_Q: S++,
            ATTRIB_VALUE_ENTITY_U: S++,
            CLOSE_TAG: S++,
            CLOSE_TAG_SAW_WHITE: S++,
            SCRIPT: S++,
            SCRIPT_ENDING: S++
        }, sax.XML_ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'"
        }, sax.ENTITIES = {
            amp: "&",
            gt: ">",
            lt: "<",
            quot: '"',
            apos: "'",
            AElig: 198,
            Aacute: 193,
            Acirc: 194,
            Agrave: 192,
            Aring: 197,
            Atilde: 195,
            Auml: 196,
            Ccedil: 199,
            ETH: 208,
            Eacute: 201,
            Ecirc: 202,
            Egrave: 200,
            Euml: 203,
            Iacute: 205,
            Icirc: 206,
            Igrave: 204,
            Iuml: 207,
            Ntilde: 209,
            Oacute: 211,
            Ocirc: 212,
            Ograve: 210,
            Oslash: 216,
            Otilde: 213,
            Ouml: 214,
            THORN: 222,
            Uacute: 218,
            Ucirc: 219,
            Ugrave: 217,
            Uuml: 220,
            Yacute: 221,
            aacute: 225,
            acirc: 226,
            aelig: 230,
            agrave: 224,
            aring: 229,
            atilde: 227,
            auml: 228,
            ccedil: 231,
            eacute: 233,
            ecirc: 234,
            egrave: 232,
            eth: 240,
            euml: 235,
            iacute: 237,
            icirc: 238,
            igrave: 236,
            iuml: 239,
            ntilde: 241,
            oacute: 243,
            ocirc: 244,
            ograve: 242,
            oslash: 248,
            otilde: 245,
            ouml: 246,
            szlig: 223,
            thorn: 254,
            uacute: 250,
            ucirc: 251,
            ugrave: 249,
            uuml: 252,
            yacute: 253,
            yuml: 255,
            copy: 169,
            reg: 174,
            nbsp: 160,
            iexcl: 161,
            cent: 162,
            pound: 163,
            curren: 164,
            yen: 165,
            brvbar: 166,
            sect: 167,
            uml: 168,
            ordf: 170,
            laquo: 171,
            not: 172,
            shy: 173,
            macr: 175,
            deg: 176,
            plusmn: 177,
            sup1: 185,
            sup2: 178,
            sup3: 179,
            acute: 180,
            micro: 181,
            para: 182,
            middot: 183,
            cedil: 184,
            ordm: 186,
            raquo: 187,
            frac14: 188,
            frac12: 189,
            frac34: 190,
            iquest: 191,
            times: 215,
            divide: 247,
            OElig: 338,
            oelig: 339,
            Scaron: 352,
            scaron: 353,
            Yuml: 376,
            fnof: 402,
            circ: 710,
            tilde: 732,
            Alpha: 913,
            Beta: 914,
            Gamma: 915,
            Delta: 916,
            Epsilon: 917,
            Zeta: 918,
            Eta: 919,
            Theta: 920,
            Iota: 921,
            Kappa: 922,
            Lambda: 923,
            Mu: 924,
            Nu: 925,
            Xi: 926,
            Omicron: 927,
            Pi: 928,
            Rho: 929,
            Sigma: 931,
            Tau: 932,
            Upsilon: 933,
            Phi: 934,
            Chi: 935,
            Psi: 936,
            Omega: 937,
            alpha: 945,
            beta: 946,
            gamma: 947,
            delta: 948,
            epsilon: 949,
            zeta: 950,
            eta: 951,
            theta: 952,
            iota: 953,
            kappa: 954,
            lambda: 955,
            mu: 956,
            nu: 957,
            xi: 958,
            omicron: 959,
            pi: 960,
            rho: 961,
            sigmaf: 962,
            sigma: 963,
            tau: 964,
            upsilon: 965,
            phi: 966,
            chi: 967,
            psi: 968,
            omega: 969,
            thetasym: 977,
            upsih: 978,
            piv: 982,
            ensp: 8194,
            emsp: 8195,
            thinsp: 8201,
            zwnj: 8204,
            zwj: 8205,
            lrm: 8206,
            rlm: 8207,
            ndash: 8211,
            mdash: 8212,
            lsquo: 8216,
            rsquo: 8217,
            sbquo: 8218,
            ldquo: 8220,
            rdquo: 8221,
            bdquo: 8222,
            dagger: 8224,
            Dagger: 8225,
            bull: 8226,
            hellip: 8230,
            permil: 8240,
            prime: 8242,
            Prime: 8243,
            lsaquo: 8249,
            rsaquo: 8250,
            oline: 8254,
            frasl: 8260,
            euro: 8364,
            image: 8465,
            weierp: 8472,
            real: 8476,
            trade: 8482,
            alefsym: 8501,
            larr: 8592,
            uarr: 8593,
            rarr: 8594,
            darr: 8595,
            harr: 8596,
            crarr: 8629,
            lArr: 8656,
            uArr: 8657,
            rArr: 8658,
            dArr: 8659,
            hArr: 8660,
            forall: 8704,
            part: 8706,
            exist: 8707,
            empty: 8709,
            nabla: 8711,
            isin: 8712,
            notin: 8713,
            ni: 8715,
            prod: 8719,
            sum: 8721,
            minus: 8722,
            lowast: 8727,
            radic: 8730,
            prop: 8733,
            infin: 8734,
            ang: 8736,
            and: 8743,
            or: 8744,
            cap: 8745,
            cup: 8746,
            int: 8747,
            there4: 8756,
            sim: 8764,
            cong: 8773,
            asymp: 8776,
            ne: 8800,
            equiv: 8801,
            le: 8804,
            ge: 8805,
            sub: 8834,
            sup: 8835,
            nsub: 8836,
            sube: 8838,
            supe: 8839,
            oplus: 8853,
            otimes: 8855,
            perp: 8869,
            sdot: 8901,
            lceil: 8968,
            rceil: 8969,
            lfloor: 8970,
            rfloor: 8971,
            lang: 9001,
            rang: 9002,
            loz: 9674,
            spades: 9824,
            clubs: 9827,
            hearts: 9829,
            diams: 9830
        }, Object.keys(sax.ENTITIES).forEach((function(key) {
            var e = sax.ENTITIES[key], s = "number" == typeof e ? String.fromCharCode(e) : e;
            sax.ENTITIES[key] = s;
        })), sax.STATE) sax.STATE[sax.STATE[s]] = s;
        function emit(parser, event, data) {
            parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
            parser.textNode && closeText(parser), emit(parser, nodeType, data);
        }
        function closeText(parser) {
            parser.textNode = textopts(parser.opt, parser.textNode), parser.textNode && emit(parser, "ontext", parser.textNode), 
            parser.textNode = "";
        }
        function textopts(opt, text) {
            return opt.trim && (text = text.trim()), opt.normalize && (text = text.replace(/\s+/g, " ")), 
            text;
        }
        function error(parser, er) {
            return closeText(parser), parser.trackPosition && (er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c), 
            er = new Error(er), parser.error = er, emit(parser, "onerror", er), parser;
        }
        function end(parser) {
            return parser.sawRoot && !parser.closedRoot && strictFail(parser, "Unclosed root tag"), 
            parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT && error(parser, "Unexpected end"), 
            closeText(parser), parser.c = "", parser.closed = !0, emit(parser, "onend"), SAXParser.call(parser, parser.strict, parser.opt), 
            parser;
        }
        function strictFail(parser, message) {
            if ("object" != typeof parser || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
            parser.strict && error(parser, message);
        }
        function newTag(parser) {
            parser.strict || (parser.tagName = parser.tagName[parser.looseCase]());
            var parent = parser.tags[parser.tags.length - 1] || parser, tag = parser.tag = {
                name: parser.tagName,
                attributes: {}
            };
            parser.opt.xmlns && (tag.ns = parent.ns), parser.attribList.length = 0;
        }
        function qname(name, attribute) {
            var qualName = name.indexOf(":") < 0 ? [ "", name ] : name.split(":"), prefix = qualName[0], local = qualName[1];
            return attribute && "xmlns" === name && (prefix = "xmlns", local = ""), {
                prefix: prefix,
                local: local
            };
        }
        function attrib(parser) {
            if (parser.strict || (parser.attribName = parser.attribName[parser.looseCase]()), 
            -1 !== parser.attribList.indexOf(parser.attribName) || parser.tag.attributes.hasOwnProperty(parser.attribName)) parser.attribName = parser.attribValue = ""; else {
                if (parser.opt.xmlns) {
                    var qn = qname(parser.attribName, !0), prefix = qn.prefix, local = qn.local;
                    if ("xmlns" === prefix) if ("xml" === local && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue); else if ("xmlns" === local && "http://www.w3.org/2000/xmlns/" !== parser.attribValue) strictFail(parser, "xmlns: prefix must be bound to http://www.w3.org/2000/xmlns/\nActual: " + parser.attribValue); else {
                        var tag = parser.tag, parent = parser.tags[parser.tags.length - 1] || parser;
                        tag.ns === parent.ns && (tag.ns = Object.create(parent.ns)), tag.ns[local] = parser.attribValue;
                    }
                    parser.attribList.push([ parser.attribName, parser.attribValue ]);
                } else parser.tag.attributes[parser.attribName] = parser.attribValue, emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: parser.attribValue
                });
                parser.attribName = parser.attribValue = "";
            }
        }
        function openTag(parser, selfClosing) {
            if (parser.opt.xmlns) {
                var tag = parser.tag, qn = qname(parser.tagName);
                tag.prefix = qn.prefix, tag.local = qn.local, tag.uri = tag.ns[qn.prefix] || "", 
                tag.prefix && !tag.uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName)), 
                tag.uri = qn.prefix);
                var parent = parser.tags[parser.tags.length - 1] || parser;
                tag.ns && parent.ns !== tag.ns && Object.keys(tag.ns).forEach((function(p) {
                    emitNode(parser, "onopennamespace", {
                        prefix: p,
                        uri: tag.ns[p]
                    });
                }));
                for (var i = 0, l = parser.attribList.length; i < l; i++) {
                    var nv = parser.attribList[i], name = nv[0], value = nv[1], qualName = qname(name, !0), prefix = qualName.prefix, local = qualName.local, uri = "" === prefix ? "" : tag.ns[prefix] || "", a = {
                        name: name,
                        value: value,
                        prefix: prefix,
                        local: local,
                        uri: uri
                    };
                    prefix && "xmlns" !== prefix && !uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix)), 
                    a.uri = prefix), parser.tag.attributes[name] = a, emitNode(parser, "onattribute", a);
                }
                parser.attribList.length = 0;
            }
            parser.tag.isSelfClosing = !!selfClosing, parser.sawRoot = !0, parser.tags.push(parser.tag), 
            emitNode(parser, "onopentag", parser.tag), selfClosing || (parser.noscript || "script" !== parser.tagName.toLowerCase() ? parser.state = S.TEXT : parser.state = S.SCRIPT, 
            parser.tag = null, parser.tagName = ""), parser.attribName = parser.attribValue = "", 
            parser.attribList.length = 0;
        }
        function closeTag(parser) {
            if (!parser.tagName) return strictFail(parser, "Weird empty close tag."), parser.textNode += "</>", 
            void (parser.state = S.TEXT);
            if (parser.script) {
                if ("script" !== parser.tagName) return parser.script += "</" + parser.tagName + ">", 
                parser.tagName = "", void (parser.state = S.SCRIPT);
                emitNode(parser, "onscript", parser.script), parser.script = "";
            }
            var t = parser.tags.length, tagName = parser.tagName;
            parser.strict || (tagName = tagName[parser.looseCase]());
            for (var closeTo = tagName; t-- && parser.tags[t].name !== closeTo; ) strictFail(parser, "Unexpected close tag");
            if (t < 0) return strictFail(parser, "Unmatched closing tag: " + parser.tagName), 
            parser.textNode += "</" + parser.tagName + ">", void (parser.state = S.TEXT);
            parser.tagName = tagName;
            for (var s = parser.tags.length; s-- > t; ) {
                var tag = parser.tag = parser.tags.pop();
                parser.tagName = parser.tag.name, emitNode(parser, "onclosetag", parser.tagName);
                var x = {};
                for (var i in tag.ns) x[i] = tag.ns[i];
                var parent = parser.tags[parser.tags.length - 1] || parser;
                parser.opt.xmlns && tag.ns !== parent.ns && Object.keys(tag.ns).forEach((function(p) {
                    var n = tag.ns[p];
                    emitNode(parser, "onclosenamespace", {
                        prefix: p,
                        uri: n
                    });
                }));
            }
            0 === t && (parser.closedRoot = !0), parser.tagName = parser.attribValue = parser.attribName = "", 
            parser.attribList.length = 0, parser.state = S.TEXT;
        }
        function beginWhiteSpace(parser, c) {
            "<" === c ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : not(whitespace, c) && (strictFail(parser, "Non-whitespace before first tag."), 
            parser.textNode = c, parser.state = S.TEXT);
        }
        S = sax.STATE, String.fromCodePoint || (stringFromCharCode = String.fromCharCode, 
        floor = Math.floor, fromCodePoint = function() {
            var highSurrogate, lowSurrogate, MAX_SIZE = 16384, codeUnits = [], index = -1, length = arguments.length;
            if (!length) return "";
            for (var result = ""; ++index < length; ) {
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
                codePoint <= 65535 ? codeUnits.push(codePoint) : (highSurrogate = 55296 + ((codePoint -= 65536) >> 10), 
                lowSurrogate = codePoint % 1024 + 56320, codeUnits.push(highSurrogate, lowSurrogate)), 
                (index + 1 === length || codeUnits.length > MAX_SIZE) && (result += stringFromCharCode.apply(null, codeUnits), 
                codeUnits.length = 0);
            }
            return result;
        }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: !0,
            writable: !0
        }) : String.fromCodePoint = fromCodePoint);
    })(exports);
}, function(module, exports) {
    exports.DEFAULT_PARSER = "sax";
}, function(module, exports, __webpack_require__) {
    var Writable = __webpack_require__(77).Writable, inherits = __webpack_require__(6), bufferFrom = __webpack_require__(387);
    if ("undefined" == typeof Uint8Array) var U8 = __webpack_require__(965).Uint8Array; else U8 = Uint8Array;
    function ConcatStream(opts, cb) {
        if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb);
        "function" == typeof opts && (cb = opts, opts = {}), opts || (opts = {});
        var encoding = opts.encoding, shouldInferEncoding = !1;
        encoding ? "u8" !== (encoding = String(encoding).toLowerCase()) && "uint8" !== encoding || (encoding = "uint8array") : shouldInferEncoding = !0, 
        Writable.call(this, {
            objectMode: !0
        }), this.encoding = encoding, this.shouldInferEncoding = shouldInferEncoding, cb && this.on("finish", (function() {
            cb(this.getBody());
        })), this.body = [];
    }
    function isBufferish(p) {
        return "string" == typeof p || (arr = p, /Array\]$/.test(Object.prototype.toString.call(arr))) || p && "function" == typeof p.subarray;
        var arr;
    }
    module.exports = ConcatStream, inherits(ConcatStream, Writable), ConcatStream.prototype._write = function(chunk, enc, next) {
        this.body.push(chunk), next();
    }, ConcatStream.prototype.inferEncoding = function(buff) {
        var firstBuffer = void 0 === buff ? this.body[0] : buff;
        return Buffer.isBuffer(firstBuffer) ? "buffer" : "undefined" != typeof Uint8Array && firstBuffer instanceof Uint8Array ? "uint8array" : Array.isArray(firstBuffer) ? "array" : "string" == typeof firstBuffer ? "string" : "[object Object]" === Object.prototype.toString.call(firstBuffer) ? "object" : "buffer";
    }, ConcatStream.prototype.getBody = function() {
        return this.encoding || 0 !== this.body.length ? (this.shouldInferEncoding && (this.encoding = this.inferEncoding()), 
        "array" === this.encoding ? (function(parts) {
            for (var res = [], i = 0; i < parts.length; i++) res.push.apply(res, parts[i]);
            return res;
        })(this.body) : "string" === this.encoding ? (function(parts) {
            for (var strings = [], i = 0; i < parts.length; i++) {
                var p = parts[i];
                "string" == typeof p || Buffer.isBuffer(p) ? strings.push(p) : isBufferish(p) ? strings.push(bufferFrom(p)) : strings.push(bufferFrom(String(p)));
            }
            return strings = Buffer.isBuffer(parts[0]) ? (strings = Buffer.concat(strings)).toString("utf8") : strings.join("");
        })(this.body) : "buffer" === this.encoding ? (function(parts) {
            for (var bufs = [], i = 0; i < parts.length; i++) {
                var p = parts[i];
                Buffer.isBuffer(p) ? bufs.push(p) : isBufferish(p) ? bufs.push(bufferFrom(p)) : bufs.push(bufferFrom(String(p)));
            }
            return Buffer.concat(bufs);
        })(this.body) : "uint8array" === this.encoding ? (function(parts) {
            for (var len = 0, i = 0; i < parts.length; i++) "string" == typeof parts[i] && (parts[i] = bufferFrom(parts[i])), 
            len += parts[i].length;
            for (var u8 = new U8(len), offset = (i = 0, 0); i < parts.length; i++) for (var part = parts[i], j = 0; j < part.length; j++) u8[offset++] = part[j];
            return u8;
        })(this.body) : this.body) : [];
    }, Array.isArray;
}, function(module, exports) {
    "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
        superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }));
    } : module.exports = function(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Buffer = __webpack_require__(23).Buffer, util = __webpack_require__(0);
    module.exports = (function() {
        function BufferList() {
            !(function(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            })(this, BufferList), this.head = null, this.tail = null, this.length = 0;
        }
        return BufferList.prototype.push = function(v) {
            var entry = {
                data: v,
                next: null
            };
            this.length > 0 ? this.tail.next = entry : this.head = entry, this.tail = entry, 
            ++this.length;
        }, BufferList.prototype.unshift = function(v) {
            var entry = {
                data: v,
                next: this.head
            };
            0 === this.length && (this.tail = entry), this.head = entry, ++this.length;
        }, BufferList.prototype.shift = function() {
            if (0 !== this.length) {
                var ret = this.head.data;
                return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, 
                --this.length, ret;
            }
        }, BufferList.prototype.clear = function() {
            this.head = this.tail = null, this.length = 0;
        }, BufferList.prototype.join = function(s) {
            if (0 === this.length) return "";
            for (var p = this.head, ret = "" + p.data; p = p.next; ) ret += s + p.data;
            return ret;
        }, BufferList.prototype.concat = function(n) {
            if (0 === this.length) return Buffer.alloc(0);
            if (1 === this.length) return this.head.data;
            for (var target, offset, ret = Buffer.allocUnsafe(n >>> 0), p = this.head, i = 0; p; ) target = ret, 
            offset = i, p.data.copy(target, offset), i += p.data.length, p = p.next;
            return ret;
        }, BufferList;
    })(), util && util.inspect && util.inspect.custom && (module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({
            length: this.length
        });
        return this.constructor.name + " " + obj;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = PassThrough;
    var Transform = __webpack_require__(455), util = __webpack_require__(32);
    function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
    }
    util.inherits = __webpack_require__(96), util.inherits(PassThrough, Transform), 
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
    };
}, function(module, exports) {
    var opts, ophop, defineProp, ECMAScript = (opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty, 
    {
        Class: function(v) {
            return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
            return p in o;
        },
        HasOwnProperty: function(o, p) {
            return ophop.call(o, p);
        },
        IsCallable: function(o) {
            return "function" == typeof o;
        },
        ToInt32: function(v) {
            return v >> 0;
        },
        ToUint32: function(v) {
            return v >>> 0;
        }
    }), LN2 = Math.LN2, abs = Math.abs, floor = Math.floor, log = Math.log, min = Math.min, pow = Math.pow, round = Math.round;
    function configureProperties(obj) {
        if (getOwnPropNames && defineProp) {
            var i, props = getOwnPropNames(obj);
            for (i = 0; i < props.length; i += 1) defineProp(obj, props[i], {
                value: obj[props[i]],
                writable: !1,
                enumerable: !1,
                configurable: !1
            });
        }
    }
    defineProp = Object.defineProperty && (function() {
        try {
            return Object.defineProperty({}, "x", {}), !0;
        } catch (e) {
            return !1;
        }
    })() ? Object.defineProperty : function(o, p, desc) {
        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
        return ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__ && Object.prototype.__defineGetter__.call(o, p, desc.get), 
        ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__ && Object.prototype.__defineSetter__.call(o, p, desc.set), 
        ECMAScript.HasProperty(desc, "value") && (o[p] = desc.value), o;
    };
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
        if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
        var p, props = [];
        for (p in o) ECMAScript.HasOwnProperty(o, p) && props.push(p);
        return props;
    };
    function makeArrayAccessors(obj) {
        if (defineProp) {
            if (obj.length > 1e5) throw new RangeError("Array too large for polyfill");
            var i;
            for (i = 0; i < obj.length; i += 1) makeArrayAccessor(i);
        }
        function makeArrayAccessor(index) {
            defineProp(obj, index, {
                get: function() {
                    return obj._getter(index);
                },
                set: function(v) {
                    obj._setter(index, v);
                },
                enumerable: !0,
                configurable: !1
            });
        }
    }
    function as_signed(value, bits) {
        var s = 32 - bits;
        return value << s >> s;
    }
    function as_unsigned(value, bits) {
        var s = 32 - bits;
        return value << s >>> s;
    }
    function packI8(n) {
        return [ 255 & n ];
    }
    function unpackI8(bytes) {
        return as_signed(bytes[0], 8);
    }
    function packU8(n) {
        return [ 255 & n ];
    }
    function unpackU8(bytes) {
        return as_unsigned(bytes[0], 8);
    }
    function packU8Clamped(n) {
        return [ (n = round(Number(n))) < 0 ? 0 : n > 255 ? 255 : 255 & n ];
    }
    function packI16(n) {
        return [ n >> 8 & 255, 255 & n ];
    }
    function unpackI16(bytes) {
        return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    function packU16(n) {
        return [ n >> 8 & 255, 255 & n ];
    }
    function unpackU16(bytes) {
        return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    function packI32(n) {
        return [ n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n ];
    }
    function unpackI32(bytes) {
        return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packU32(n) {
        return [ n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n ];
    }
    function unpackU32(bytes) {
        return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
        var s, e, f, i, bits, str, bytes, bias = (1 << ebits - 1) - 1;
        function roundToEven(n) {
            var w = floor(n), f = n - w;
            return f < .5 ? w : f > .5 || w % 2 ? w + 1 : w;
        }
        for (v != v ? (e = (1 << ebits) - 1, f = pow(2, fbits - 1), s = 0) : v === 1 / 0 || v === -1 / 0 ? (e = (1 << ebits) - 1, 
        f = 0, s = v < 0 ? 1 : 0) : 0 === v ? (e = 0, f = 0, s = 1 / v == -1 / 0 ? 1 : 0) : (s = v < 0, 
        (v = abs(v)) >= pow(2, 1 - bias) ? (e = min(floor(log(v) / LN2), 1023), (f = roundToEven(v / pow(2, e) * pow(2, fbits))) / pow(2, fbits) >= 2 && (e += 1, 
        f = 1), e > bias ? (e = (1 << ebits) - 1, f = 0) : (e += bias, f -= pow(2, fbits))) : (e = 0, 
        f = roundToEven(v / pow(2, 1 - bias - fbits)))), bits = [], i = fbits; i; i -= 1) bits.push(f % 2 ? 1 : 0), 
        f = floor(f / 2);
        for (i = ebits; i; i -= 1) bits.push(e % 2 ? 1 : 0), e = floor(e / 2);
        for (bits.push(s ? 1 : 0), bits.reverse(), str = bits.join(""), bytes = []; str.length; ) bytes.push(parseInt(str.substring(0, 8), 2)), 
        str = str.substring(8);
        return bytes;
    }
    function unpackIEEE754(bytes, ebits, fbits) {
        var i, j, b, str, bias, s, e, f, bits = [];
        for (i = bytes.length; i; i -= 1) for (b = bytes[i - 1], j = 8; j; j -= 1) bits.push(b % 2 ? 1 : 0), 
        b >>= 1;
        return bits.reverse(), str = bits.join(""), bias = (1 << ebits - 1) - 1, s = parseInt(str.substring(0, 1), 2) ? -1 : 1, 
        e = parseInt(str.substring(1, 1 + ebits), 2), f = parseInt(str.substring(1 + ebits), 2), 
        e === (1 << ebits) - 1 ? 0 !== f ? NaN : s * (1 / 0) : e > 0 ? s * pow(2, e - bias) * (1 + f / pow(2, fbits)) : 0 !== f ? s * pow(2, -(bias - 1)) * (f / pow(2, fbits)) : s < 0 ? -0 : 0;
    }
    function unpackF64(b) {
        return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
        return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
        return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
        return packIEEE754(v, 8, 23);
    }
    !(function() {
        var ArrayBuffer = function(length) {
            if ((length = ECMAScript.ToInt32(length)) < 0) throw new RangeError("ArrayBuffer size is not a small enough positive integer");
            var i;
            for (this.byteLength = length, this._bytes = [], this._bytes.length = length, i = 0; i < this.byteLength; i += 1) this._bytes[i] = 0;
            configureProperties(this);
        };
        exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
        var ArrayBufferView = function() {};
        function makeConstructor(bytesPerElement, pack, unpack) {
            var ctor;
            return ctor = function(buffer, byteOffset, length) {
                var array, sequence, i, s;
                if (arguments.length && "number" != typeof arguments[0]) if ("object" == typeof arguments[0] && arguments[0].constructor === ctor) for (array = arguments[0], 
                this.length = array.length, this.byteLength = this.length * this.BYTES_PER_ELEMENT, 
                this.buffer = new ArrayBuffer(this.byteLength), this.byteOffset = 0, i = 0; i < this.length; i += 1) this._setter(i, array._getter(i)); else if ("object" != typeof arguments[0] || arguments[0] instanceof ArrayBuffer || "ArrayBuffer" === ECMAScript.Class(arguments[0])) {
                    if ("object" != typeof arguments[0] || !(arguments[0] instanceof ArrayBuffer || "ArrayBuffer" === ECMAScript.Class(arguments[0]))) throw new TypeError("Unexpected argument type(s)");
                    if (this.buffer = buffer, this.byteOffset = ECMAScript.ToUint32(byteOffset), this.byteOffset > this.buffer.byteLength) throw new RangeError("byteOffset out of range");
                    if (this.byteOffset % this.BYTES_PER_ELEMENT) throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
                    if (arguments.length < 3) {
                        if (this.byteLength = this.buffer.byteLength - this.byteOffset, this.byteLength % this.BYTES_PER_ELEMENT) throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
                        this.length = this.byteLength / this.BYTES_PER_ELEMENT;
                    } else this.length = ECMAScript.ToUint32(length), this.byteLength = this.length * this.BYTES_PER_ELEMENT;
                    if (this.byteOffset + this.byteLength > this.buffer.byteLength) throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
                } else for (sequence = arguments[0], this.length = ECMAScript.ToUint32(sequence.length), 
                this.byteLength = this.length * this.BYTES_PER_ELEMENT, this.buffer = new ArrayBuffer(this.byteLength), 
                this.byteOffset = 0, i = 0; i < this.length; i += 1) s = sequence[i], this._setter(i, Number(s)); else {
                    if (this.length = ECMAScript.ToInt32(arguments[0]), length < 0) throw new RangeError("ArrayBufferView size is not a small enough positive integer");
                    this.byteLength = this.length * this.BYTES_PER_ELEMENT, this.buffer = new ArrayBuffer(this.byteLength), 
                    this.byteOffset = 0;
                }
                this.constructor = ctor, configureProperties(this), makeArrayAccessors(this);
            }, ctor.prototype = new ArrayBufferView, ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement, 
            ctor.prototype._pack = pack, ctor.prototype._unpack = unpack, ctor.BYTES_PER_ELEMENT = bytesPerElement, 
            ctor.prototype._getter = function(index) {
                if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
                if (!((index = ECMAScript.ToUint32(index)) >= this.length)) {
                    var i, o, bytes = [];
                    for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, 
                    o += 1) bytes.push(this.buffer._bytes[o]);
                    return this._unpack(bytes);
                }
            }, ctor.prototype.get = ctor.prototype._getter, ctor.prototype._setter = function(index, value) {
                if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
                if (!((index = ECMAScript.ToUint32(index)) >= this.length)) {
                    var i, o, bytes = this._pack(value);
                    for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, 
                    o += 1) this.buffer._bytes[o] = bytes[i];
                }
            }, ctor.prototype.set = function(index, value) {
                if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
                var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
                if ("object" == typeof arguments[0] && arguments[0].constructor === this.constructor) {
                    if (array = arguments[0], (offset = ECMAScript.ToUint32(arguments[1])) + array.length > this.length) throw new RangeError("Offset plus length of array is out of range");
                    if (byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT, byteLength = array.length * this.BYTES_PER_ELEMENT, 
                    array.buffer === this.buffer) {
                        for (tmp = [], i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) tmp[i] = array.buffer._bytes[s];
                        for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) this.buffer._bytes[d] = tmp[i];
                    } else for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, 
                    s += 1, d += 1) this.buffer._bytes[d] = array.buffer._bytes[s];
                } else {
                    if ("object" != typeof arguments[0] || void 0 === arguments[0].length) throw new TypeError("Unexpected argument type(s)");
                    if (sequence = arguments[0], len = ECMAScript.ToUint32(sequence.length), (offset = ECMAScript.ToUint32(arguments[1])) + len > this.length) throw new RangeError("Offset plus length of array is out of range");
                    for (i = 0; i < len; i += 1) s = sequence[i], this._setter(offset + i, Number(s));
                }
            }, ctor.prototype.subarray = function(start, end) {
                function clamp(v, min, max) {
                    return v < min ? min : v > max ? max : v;
                }
                start = ECMAScript.ToInt32(start), end = ECMAScript.ToInt32(end), arguments.length < 1 && (start = 0), 
                arguments.length < 2 && (end = this.length), start < 0 && (start = this.length + start), 
                end < 0 && (end = this.length + end), start = clamp(start, 0, this.length);
                var len = (end = clamp(end, 0, this.length)) - start;
                return len < 0 && (len = 0), new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
            }, ctor;
        }
        var Int8Array = makeConstructor(1, packI8, unpackI8), Uint8Array = makeConstructor(1, packU8, unpackU8), Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8), Int16Array = makeConstructor(2, packI16, unpackI16), Uint16Array = makeConstructor(2, packU16, unpackU16), Int32Array = makeConstructor(4, packI32, unpackI32), Uint32Array = makeConstructor(4, packU32, unpackU32), Float32Array = makeConstructor(4, packF32, unpackF32), Float64Array = makeConstructor(8, packF64, unpackF64);
        exports.Int8Array = exports.Int8Array || Int8Array, exports.Uint8Array = exports.Uint8Array || Uint8Array, 
        exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray, exports.Int16Array = exports.Int16Array || Int16Array, 
        exports.Uint16Array = exports.Uint16Array || Uint16Array, exports.Int32Array = exports.Int32Array || Int32Array, 
        exports.Uint32Array = exports.Uint32Array || Uint32Array, exports.Float32Array = exports.Float32Array || Float32Array, 
        exports.Float64Array = exports.Float64Array || Float64Array;
    })(), (function() {
        function r(array, index) {
            return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
        }
        var u16array, IS_BIG_ENDIAN = (u16array = new exports.Uint16Array([ 4660 ]), 18 === r(new exports.Uint8Array(u16array.buffer), 0)), DataView = function(buffer, byteOffset, byteLength) {
            if (0 === arguments.length) buffer = new exports.ArrayBuffer(0); else if (!(buffer instanceof exports.ArrayBuffer || "ArrayBuffer" === ECMAScript.Class(buffer))) throw new TypeError("TypeError");
            if (this.buffer = buffer || new exports.ArrayBuffer(0), this.byteOffset = ECMAScript.ToUint32(byteOffset), 
            this.byteOffset > this.buffer.byteLength) throw new RangeError("byteOffset out of range");
            if (this.byteLength = arguments.length < 3 ? this.buffer.byteLength - this.byteOffset : ECMAScript.ToUint32(byteLength), 
            this.byteOffset + this.byteLength > this.buffer.byteLength) throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            configureProperties(this);
        };
        function makeGetter(arrayType) {
            return function(byteOffset, littleEndian) {
                if ((byteOffset = ECMAScript.ToUint32(byteOffset)) + arrayType.BYTES_PER_ELEMENT > this.byteLength) throw new RangeError("Array index out of range");
                byteOffset += this.byteOffset;
                var i, uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [];
                for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) bytes.push(r(uint8Array, i));
                return Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN) && bytes.reverse(), r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
            };
        }
        function makeSetter(arrayType) {
            return function(byteOffset, value, littleEndian) {
                if ((byteOffset = ECMAScript.ToUint32(byteOffset)) + arrayType.BYTES_PER_ELEMENT > this.byteLength) throw new RangeError("Array index out of range");
                var i, typeArray = new arrayType([ value ]), byteArray = new exports.Uint8Array(typeArray.buffer), bytes = [];
                for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) bytes.push(r(byteArray, i));
                Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN) && bytes.reverse(), new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT).set(bytes);
            };
        }
        DataView.prototype.getUint8 = makeGetter(exports.Uint8Array), DataView.prototype.getInt8 = makeGetter(exports.Int8Array), 
        DataView.prototype.getUint16 = makeGetter(exports.Uint16Array), DataView.prototype.getInt16 = makeGetter(exports.Int16Array), 
        DataView.prototype.getUint32 = makeGetter(exports.Uint32Array), DataView.prototype.getInt32 = makeGetter(exports.Int32Array), 
        DataView.prototype.getFloat32 = makeGetter(exports.Float32Array), DataView.prototype.getFloat64 = makeGetter(exports.Float64Array), 
        DataView.prototype.setUint8 = makeSetter(exports.Uint8Array), DataView.prototype.setInt8 = makeSetter(exports.Int8Array), 
        DataView.prototype.setUint16 = makeSetter(exports.Uint16Array), DataView.prototype.setInt16 = makeSetter(exports.Int16Array), 
        DataView.prototype.setUint32 = makeSetter(exports.Uint32Array), DataView.prototype.setInt32 = makeSetter(exports.Int32Array), 
        DataView.prototype.setFloat32 = makeSetter(exports.Float32Array), DataView.prototype.setFloat64 = makeSetter(exports.Float64Array), 
        exports.DataView = exports.DataView || DataView;
    })();
}, function(module, exports, __webpack_require__) {
    var os = __webpack_require__(21);
    function pickInterface(interfaces, family) {
        for (var i in interfaces) for (var j = interfaces[i].length - 1; j >= 0; j--) {
            var face = interfaces[i][j], reachable = "IPv4" === family || 0 === face.scopeid;
            if (!face.internal && face.family === family && reachable) return face.address;
        }
        return "IPv4" === family ? "127.0.0.1" : "::1";
    }
    function reduceInterfaces(interfaces, iface) {
        var ifaces = {};
        for (var i in interfaces) i === iface && (ifaces[i] = interfaces[i]);
        return ifaces;
    }
    function ipv4(iface) {
        var interfaces = os.networkInterfaces();
        return iface && (interfaces = reduceInterfaces(interfaces, iface)), pickInterface(interfaces, "IPv4");
    }
    ipv4.ipv4 = ipv4, ipv4.ipv6 = function(iface) {
        var interfaces = os.networkInterfaces();
        return iface && (interfaces = reduceInterfaces(interfaces, iface)), pickInterface(interfaces, "IPv6");
    }, module.exports = ipv4;
}, function(module) {
    module.exports = {
        name: "upnp-device-client",
        version: "1.0.2",
        description: "A simple and versatile UPnP device client",
        author: "thibauts",
        license: "MIT",
        main: "index.js",
        dependencies: {
            "concat-stream": "^1.4.8",
            debug: "^2.1.3",
            elementtree: "~0.1.6",
            "network-address": "^1.0.0"
        },
        scripts: {
            test: 'echo "Error: no test specified" && exit 1'
        },
        repository: {
            type: "git",
            url: "git://github.com/thibauts/node-upnp-device-client.git"
        },
        keywords: [ "upnp", "dlna" ]
    };
}, function(module, exports, __webpack_require__) {
    const addonSDK = __webpack_require__(969), fs = __webpack_require__(2);
    let engineUrl = "http://127.0.0.1:11470";
    const manifest = __webpack_require__(465), manifestNoCatalogs = __webpack_require__(999), catalogHandler = __webpack_require__(1e3), metaHandler = __webpack_require__(1001), streamHandler = __webpack_require__(1023), Storage = __webpack_require__(1024), findFiles = __webpack_require__(1025), indexer = __webpack_require__(467), mapEntryToMeta = __webpack_require__(468), storage = new Storage({
        validateRecord: function(index, entry) {
            fs.accessSync(index, fs.constants.R_OK);
        },
        entryIndexes: [ "itemId" ]
    }), metaStorage = new Storage;
    function logError(err) {
        console.log("Error:", err);
    }
    function onDiscoveredFile(fPath) {
        storage.indexes.primaryKey.has(fPath) || storage.indexes.primaryKey.size >= 1e4 || indexer.indexFile(fPath, (function(err, entry) {
            err ? indexLog(fPath, "indexing error: " + (err.message || err)) : entry && (storage.saveEntry(fPath, entry, (function(err) {
                err ? console.log(err) : entry.itemId && indexLog(fPath, "is now indexed: " + entry.itemId);
            })), entry.files && entry.files.length > 0 && entry.itemId && mapEntryToMeta(entry).then((function(meta) {
                metaStorage.saveEntry(meta.id, meta, (function() {}));
            })).catch((() => {})));
        }));
    }
    function indexLog(fPath, status) {
        console.log("-> " + fPath + ": " + status);
    }
    module.exports = {
        addon: function(options) {
            const addonBuilder = new addonSDK((options = options || {}).disableCatalogSupport ? manifestNoCatalogs : manifest);
            return addonBuilder.defineCatalogHandler((function(args, cb) {
                catalogHandler(storage, metaStorage, args, cb);
            })), addonBuilder.defineMetaHandler((function(args, cb) {
                metaHandler(storage, metaStorage, engineUrl, args, cb);
            })), addonBuilder.defineStreamHandler((function(args, cb) {
                streamHandler(storage, args, cb);
            })), addonBuilder;
        },
        setEngineUrl: function(url) {
            engineUrl = url;
        },
        startIndexing: function(fPath) {
            Promise.all([ metaStorage.load(fPath + "Meta").catch(logError), storage.load(fPath).catch(logError) ]).then((function(err) {
                findFiles().on("file", onDiscoveredFile);
            }));
        }
    };
}, function(module, exports, __webpack_require__) {
    const express = __webpack_require__(970), cors = __webpack_require__(992), http = __webpack_require__(11), linter = __webpack_require__(994), qs = __webpack_require__(28), publishToDir = __webpack_require__(997), publishToCentral = __webpack_require__(998);
    module.exports = function(manifest) {
        const addonHTTP = express.Router();
        addonHTTP.use(cors());
        const handlers = {}, linterRes = linter.lintManifest(manifest);
        if (!linterRes.valid) throw linterRes.errors[0];
        linterRes.warnings.length && linterRes.warnings.forEach((function(warning) {
            console.log("WARNING:", warning.message);
        }));
        const manifestBuf = new Buffer(JSON.stringify(manifest));
        if (manifestBuf.length > 8192) throw "manifest size exceeds 8kb, which is incompatible with addonCollection API";
        return addonHTTP.get("/manifest.json", (function(req, res) {
            res.setHeader("Content-Type", "application/json; charset=utf-8"), res.end(manifestBuf);
        })), addonHTTP.get("/:resource/:type/:id/:extra?.json", (function(req, res, next) {
            let handler = handlers[req.params.resource];
            handler ? (res.setHeader("Content-Type", "application/json; charset=utf-8"), handler({
                type: req.params.type,
                id: req.params.id,
                extra: req.params.extra ? qs.parse(req.params.extra) : {}
            }, (function(err, resp) {
                err && (console.error(err), res.writeHead(500), res.end(JSON.stringify({
                    err: "handler error"
                }))), res.end(JSON.stringify(resp));
            }))) : next();
        })), this.defineResourceHandler = function(resource, handler) {
            if (handlers[resource]) throw "handler for " + resource + " already defined";
            handlers[resource] = handler;
        }, this.defineStreamHandler = this.defineResourceHandler.bind(this, "stream"), this.defineMetaHandler = this.defineResourceHandler.bind(this, "meta"), 
        this.defineCatalogHandler = this.defineResourceHandler.bind(this, "catalog"), this.defineSubtitleHandler = this.defineResourceHandler.bind(this, "subtitles"), 
        this.run = function(cb) {
            this.runHTTPWithOptions({
                port: process.env.PORT || null,
                cache: 7200
            }, cb);
        }, this.runHTTPWithOptions = function(options, cb) {
            var addonHTTPApp = express();
            addonHTTPApp.use((function(req, res, next) {
                options.cache && res.setHeader("Cache-Control", "max-age=" + options.cache), next();
            })), addonHTTPApp.use("/", addonHTTP);
            var server = http.createServer(addonHTTPApp);
            server.listen(options.port, (function() {
                var url = "http://127.0.0.1:" + server.address().port + "/manifest.json";
                console.log("HTTP addon accessible at:", url), cb && cb(null, {
                    server: server,
                    url: url
                });
            }));
        }, this.getRouter = function() {
            return addonHTTP;
        }, this.publishToCentral = function(addonURL, apiURL) {
            return publishToCentral(addonURL, apiURL);
        }, this.publishToDir = function(baseDir) {
            publishToDir(baseDir || "./publish-" + manifest.id, manifest, handlers);
        }, this;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = __webpack_require__(971);
}, function(module, exports, __webpack_require__) {
    "use strict";
    var bodyParser = __webpack_require__(106), EventEmitter = __webpack_require__(5).EventEmitter, mixin = __webpack_require__(972), proto = __webpack_require__(973), Route = __webpack_require__(457), Router = __webpack_require__(456), req = __webpack_require__(981), res = __webpack_require__(988);
    (exports = module.exports = function() {
        var app = function(req, res, next) {
            app.handle(req, res, next);
        };
        return mixin(app, EventEmitter.prototype, !1), mixin(app, proto, !1), app.request = Object.create(req, {
            app: {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                value: app
            }
        }), app.response = Object.create(res, {
            app: {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                value: app
            }
        }), app.init(), app;
    }).application = proto, exports.request = req, exports.response = res, exports.Route = Route, 
    exports.Router = Router, exports.json = bodyParser.json, exports.query = __webpack_require__(459), 
    exports.raw = bodyParser.raw, exports.static = __webpack_require__(991), exports.text = bodyParser.text, 
    exports.urlencoded = bodyParser.urlencoded, [ "bodyParser", "compress", "cookieSession", "session", "logger", "cookieParser", "favicon", "responseTime", "errorHandler", "timeout", "methodOverride", "vhost", "csrf", "directory", "limit", "multipart", "staticCache" ].forEach((function(name) {
        Object.defineProperty(exports, name, {
            get: function() {
                throw new Error("Most middleware (like " + name + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
            },
            configurable: !0
        });
    }));
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(dest, src, redefine) {
        if (!dest) throw new TypeError("argument dest is required");
        if (!src) throw new TypeError("argument src is required");
        return void 0 === redefine && (redefine = !0), Object.getOwnPropertyNames(src).forEach((function(name) {
            if (redefine || !hasOwnProperty.call(dest, name)) {
                var descriptor = Object.getOwnPropertyDescriptor(src, name);
                Object.defineProperty(dest, name, descriptor);
            }
        })), dest;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var finalhandler = __webpack_require__(974), Router = __webpack_require__(456), methods = __webpack_require__(61), middleware = __webpack_require__(975), query = __webpack_require__(459), debug = __webpack_require__(8)("express:application"), View = __webpack_require__(976), http = __webpack_require__(11), compileETag = __webpack_require__(67).compileETag, compileQueryParser = __webpack_require__(67).compileQueryParser, compileTrust = __webpack_require__(67).compileTrust, deprecate = __webpack_require__(47)("express"), flatten = __webpack_require__(149), merge = __webpack_require__(60), resolve = __webpack_require__(4).resolve, setPrototypeOf = __webpack_require__(108), slice = Array.prototype.slice, app = module.exports = {};
    function logerror(err) {
        "test" !== this.get("env") && console.error(err.stack || err.toString());
    }
    app.init = function() {
        this.cache = {}, this.engines = {}, this.settings = {}, this.defaultConfiguration();
    }, app.defaultConfiguration = function() {
        var env = "production";
        this.enable("x-powered-by"), this.set("etag", "weak"), this.set("env", env), this.set("query parser", "extended"), 
        this.set("subdomain offset", 2), this.set("trust proxy", !1), Object.defineProperty(this.settings, "@@symbol:trust_proxy_default", {
            configurable: !0,
            value: !0
        }), debug("booting in %s mode", env), this.on("mount", (function(parent) {
            !0 === this.settings["@@symbol:trust_proxy_default"] && "function" == typeof parent.settings["trust proxy fn"] && (delete this.settings["trust proxy"], 
            delete this.settings["trust proxy fn"]), setPrototypeOf(this.request, parent.request), 
            setPrototypeOf(this.response, parent.response), setPrototypeOf(this.engines, parent.engines), 
            setPrototypeOf(this.settings, parent.settings);
        })), this.locals = Object.create(null), this.mountpath = "/", this.locals.settings = this.settings, 
        this.set("view", View), this.set("views", resolve("views")), this.set("jsonp callback name", "callback"), 
        this.enable("view cache"), Object.defineProperty(this, "router", {
            get: function() {
                throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
            }
        });
    }, app.lazyrouter = function() {
        this._router || (this._router = new Router({
            caseSensitive: this.enabled("case sensitive routing"),
            strict: this.enabled("strict routing")
        }), this._router.use(query(this.get("query parser fn"))), this._router.use(middleware.init(this)));
    }, app.handle = function(req, res, callback) {
        var router = this._router, done = callback || finalhandler(req, res, {
            env: this.get("env"),
            onerror: logerror.bind(this)
        });
        if (!router) return debug("no routes defined on app"), void done();
        router.handle(req, res, done);
    }, app.use = function(fn) {
        var offset = 0, path = "/";
        if ("function" != typeof fn) {
            for (var arg = fn; Array.isArray(arg) && 0 !== arg.length; ) arg = arg[0];
            "function" != typeof arg && (offset = 1, path = fn);
        }
        var fns = flatten(slice.call(arguments, offset));
        if (0 === fns.length) throw new TypeError("app.use() requires a middleware function");
        this.lazyrouter();
        var router = this._router;
        return fns.forEach((function(fn) {
            if (!fn || !fn.handle || !fn.set) return router.use(path, fn);
            debug(".use app under %s", path), fn.mountpath = path, fn.parent = this, router.use(path, (function(req, res, next) {
                var orig = req.app;
                fn.handle(req, res, (function(err) {
                    setPrototypeOf(req, orig.request), setPrototypeOf(res, orig.response), next(err);
                }));
            })), fn.emit("mount", this);
        }), this), this;
    }, app.route = function(path) {
        return this.lazyrouter(), this._router.route(path);
    }, app.engine = function(ext, fn) {
        if ("function" != typeof fn) throw new Error("callback function required");
        var extension = "." !== ext[0] ? "." + ext : ext;
        return this.engines[extension] = fn, this;
    }, app.param = function(name, fn) {
        if (this.lazyrouter(), Array.isArray(name)) {
            for (var i = 0; i < name.length; i++) this.param(name[i], fn);
            return this;
        }
        return this._router.param(name, fn), this;
    }, app.set = function(setting, val) {
        if (1 === arguments.length) return this.settings[setting];
        switch (debug('set "%s" to %o', setting, val), this.settings[setting] = val, setting) {
          case "etag":
            this.set("etag fn", compileETag(val));
            break;

          case "query parser":
            this.set("query parser fn", compileQueryParser(val));
            break;

          case "trust proxy":
            this.set("trust proxy fn", compileTrust(val)), Object.defineProperty(this.settings, "@@symbol:trust_proxy_default", {
                configurable: !0,
                value: !1
            });
        }
        return this;
    }, app.path = function() {
        return this.parent ? this.parent.path() + this.mountpath : "";
    }, app.enabled = function(setting) {
        return Boolean(this.set(setting));
    }, app.disabled = function(setting) {
        return !this.set(setting);
    }, app.enable = function(setting) {
        return this.set(setting, !0);
    }, app.disable = function(setting) {
        return this.set(setting, !1);
    }, methods.forEach((function(method) {
        app[method] = function(path) {
            if ("get" === method && 1 === arguments.length) return this.set(path);
            this.lazyrouter();
            var route = this._router.route(path);
            return route[method].apply(route, slice.call(arguments, 1)), this;
        };
    })), app.all = function(path) {
        this.lazyrouter();
        for (var route = this._router.route(path), args = slice.call(arguments, 1), i = 0; i < methods.length; i++) route[methods[i]].apply(route, args);
        return this;
    }, app.del = deprecate.function(app.delete, "app.del: Use app.delete instead"), 
    app.render = function(name, options, callback) {
        var view, cache = this.cache, done = callback, engines = this.engines, opts = options, renderOptions = {};
        if ("function" == typeof options && (done = options, opts = {}), merge(renderOptions, this.locals), 
        opts._locals && merge(renderOptions, opts._locals), merge(renderOptions, opts), 
        null == renderOptions.cache && (renderOptions.cache = this.enabled("view cache")), 
        renderOptions.cache && (view = cache[name]), !view) {
            if (!(view = new (this.get("view"))(name, {
                defaultEngine: this.get("view engine"),
                root: this.get("views"),
                engines: engines
            })).path) {
                var dirs = Array.isArray(view.root) && view.root.length > 1 ? 'directories "' + view.root.slice(0, -1).join('", "') + '" or "' + view.root[view.root.length - 1] + '"' : 'directory "' + view.root + '"', err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
                return err.view = view, done(err);
            }
            renderOptions.cache && (cache[name] = view);
        }
        !(function(view, options, callback) {
            try {
                view.render(options, callback);
            } catch (err) {
                callback(err);
            }
        })(view, renderOptions, done);
    }, app.listen = function() {
        var server = http.createServer(this);
        return server.listen.apply(server, arguments);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var debug = __webpack_require__(8)("finalhandler"), encodeUrl = __webpack_require__(83), escapeHtml = __webpack_require__(84), onFinished = __webpack_require__(85), parseUrl = __webpack_require__(46), statuses = __webpack_require__(109), unpipe = __webpack_require__(158), DOUBLE_SPACE_REGEXP = /\x20{2}/g, NEWLINE_REGEXP = /\n/g, defer = "function" == typeof setImmediate ? setImmediate : function(fn) {
        process.nextTick(fn.bind.apply(fn, arguments));
    }, isFinished = onFinished.isFinished;
    function headersSent(res) {
        return "boolean" != typeof res.headersSent ? Boolean(res._header) : res.headersSent;
    }
    module.exports = function(req, res, options) {
        var opts = options || {}, env = opts.env || "production", onerror = opts.onerror;
        return function(err) {
            var headers, msg, status;
            if (err || !headersSent(res)) {
                if (err ? (status = (function(err) {
                    return "number" == typeof err.status && err.status >= 400 && err.status < 600 ? err.status : "number" == typeof err.statusCode && err.statusCode >= 400 && err.statusCode < 600 ? err.statusCode : void 0;
                })(err), void 0 === status ? status = (function(res) {
                    var status = res.statusCode;
                    return ("number" != typeof status || status < 400 || status > 599) && (status = 500), 
                    status;
                })(res) : headers = (function(err) {
                    if (err.headers && "object" == typeof err.headers) {
                        for (var headers = Object.create(null), keys = Object.keys(err.headers), i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            headers[key] = err.headers[key];
                        }
                        return headers;
                    }
                })(err), msg = (function(err, status, env) {
                    var msg;
                    return "production" !== env && ((msg = err.stack) || "function" != typeof err.toString || (msg = err.toString())), 
                    msg || statuses[status];
                })(err, status, env)) : (status = 404, msg = "Cannot " + req.method + " " + encodeUrl((function(req) {
                    try {
                        return parseUrl.original(req).pathname;
                    } catch (e) {
                        return "resource";
                    }
                })(req))), debug("default %s", status), err && onerror && defer(onerror, err, req, res), 
                headersSent(res)) return debug("cannot %d after headers sent", status), void req.socket.destroy();
                !(function(req, res, status, headers, message) {
                    function write() {
                        var body = (function(message) {
                            return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;") + "</pre>\n</body>\n</html>\n";
                        })(message);
                        res.statusCode = status, res.statusMessage = statuses[status], (function(res, headers) {
                            if (headers) for (var keys = Object.keys(headers), i = 0; i < keys.length; i++) {
                                var key = keys[i];
                                res.setHeader(key, headers[key]);
                            }
                        })(res, headers), res.setHeader("Content-Security-Policy", "default-src 'none'"), 
                        res.setHeader("X-Content-Type-Options", "nosniff"), res.setHeader("Content-Type", "text/html; charset=utf-8"), 
                        res.setHeader("Content-Length", Buffer.byteLength(body, "utf8")), "HEAD" !== req.method ? res.end(body, "utf8") : res.end();
                    }
                    isFinished(req) ? write() : (unpipe(req), onFinished(req, write), req.resume());
                })(req, res, status, headers, msg);
            } else debug("cannot 404 after headers sent");
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var setPrototypeOf = __webpack_require__(108);
    exports.init = function(app) {
        return function(req, res, next) {
            app.enabled("x-powered-by") && res.setHeader("X-Powered-By", "Express"), req.res = res, 
            res.req = req, req.next = next, setPrototypeOf(req, app.request), setPrototypeOf(res, app.response), 
            res.locals = res.locals || Object.create(null), next();
        };
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var debug = __webpack_require__(8)("express:view"), path = __webpack_require__(4), fs = __webpack_require__(2), dirname = path.dirname, basename = path.basename, extname = path.extname, join = path.join, resolve = path.resolve;
    function View(name, options) {
        var opts = options || {};
        if (this.defaultEngine = opts.defaultEngine, this.ext = extname(name), this.name = name, 
        this.root = opts.root, !this.ext && !this.defaultEngine) throw new Error("No default engine was specified and no extension was provided.");
        var fileName = name;
        if (this.ext || (this.ext = "." !== this.defaultEngine[0] ? "." + this.defaultEngine : this.defaultEngine, 
        fileName += this.ext), !opts.engines[this.ext]) {
            var mod = this.ext.substr(1);
            debug('require "%s"', mod);
            var fn = __webpack_require__(977)(mod).__express;
            if ("function" != typeof fn) throw new Error('Module "' + mod + '" does not provide a view engine.');
            opts.engines[this.ext] = fn;
        }
        this.engine = opts.engines[this.ext], this.path = this.lookup(fileName);
    }
    function tryStat(path) {
        debug('stat "%s"', path);
        try {
            return fs.statSync(path);
        } catch (e) {
            return;
        }
    }
    module.exports = View, View.prototype.lookup = function(name) {
        var path, roots = [].concat(this.root);
        debug('lookup "%s"', name);
        for (var i = 0; i < roots.length && !path; i++) {
            var root = roots[i], loc = resolve(root, name), dir = dirname(loc), file = basename(loc);
            path = this.resolve(dir, file);
        }
        return path;
    }, View.prototype.render = function(options, callback) {
        debug('render "%s"', this.path), this.engine(this.path, options, callback);
    }, View.prototype.resolve = function(dir, file) {
        var ext = this.ext, path = join(dir, file), stat = tryStat(path);
        return stat && stat.isFile() || (stat = tryStat(path = join(dir, basename(file, ext), "index" + ext))) && stat.isFile() ? path : void 0;
    };
}, function(module, exports) {
    function webpackEmptyContext(req) {
        var e = new Error("Cannot find module '" + req + "'");
        throw e.code = "MODULE_NOT_FOUND", e;
    }
    webpackEmptyContext.keys = function() {
        return [];
    }, webpackEmptyContext.resolve = webpackEmptyContext, module.exports = webpackEmptyContext, 
    webpackEmptyContext.id = 977;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var ReadStream = __webpack_require__(2).ReadStream, Stream = __webpack_require__(3);
    function onOpenClose() {
        "number" == typeof this.fd && this.close();
    }
    module.exports = function(stream) {
        return stream instanceof ReadStream ? (function(stream) {
            return stream.destroy(), "function" == typeof stream.close && stream.on("open", onOpenClose), 
            stream;
        })(stream) : stream instanceof Stream ? ("function" == typeof stream.destroy && stream.destroy(), 
        stream) : stream;
    };
}, function(module, exports) {
    var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h;
    function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= 1.5 * n;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    module.exports = function(val, options) {
        options = options || {};
        var ms, msAbs, type = typeof val;
        if ("string" === type && val.length > 0) return (function(str) {
            if (!((str = String(str)).length > 100)) {
                var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
                if (match) {
                    var n = parseFloat(match[1]);
                    switch ((match[2] || "ms").toLowerCase()) {
                      case "years":
                      case "year":
                      case "yrs":
                      case "yr":
                      case "y":
                        return 315576e5 * n;

                      case "weeks":
                      case "week":
                      case "w":
                        return 6048e5 * n;

                      case "days":
                      case "day":
                      case "d":
                        return n * d;

                      case "hours":
                      case "hour":
                      case "hrs":
                      case "hr":
                      case "h":
                        return n * h;

                      case "minutes":
                      case "minute":
                      case "mins":
                      case "min":
                      case "m":
                        return n * m;

                      case "seconds":
                      case "second":
                      case "secs":
                      case "sec":
                      case "s":
                        return n * s;

                      case "milliseconds":
                      case "millisecond":
                      case "msecs":
                      case "msec":
                      case "ms":
                        return n;

                      default:
                        return;
                    }
                }
            }
        })(val);
        if ("number" === type && !1 === isNaN(val)) return options.long ? (ms = val, (msAbs = Math.abs(ms)) >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms") : (function(ms) {
            var msAbs = Math.abs(ms);
            return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
        })(val);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(req) {
        if (!req) throw new TypeError("argument req is required");
        var proxyAddrs = (function(header) {
            for (var end = header.length, list = [], start = header.length, i = header.length - 1; i >= 0; i--) switch (header.charCodeAt(i)) {
              case 32:
                start === end && (start = end = i);
                break;

              case 44:
                start !== end && list.push(header.substring(start, end)), start = end = i;
                break;

              default:
                start = i;
            }
            return start !== end && list.push(header.substring(start, end)), list;
        })(req.headers["x-forwarded-for"] || "");
        return [ req.connection.remoteAddress ].concat(proxyAddrs);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var accepts = __webpack_require__(982), deprecate = __webpack_require__(47)("express"), isIP = __webpack_require__(42).isIP, typeis = __webpack_require__(88), http = __webpack_require__(11), fresh = __webpack_require__(462), parseRange = __webpack_require__(159), parse = __webpack_require__(46), proxyaddr = __webpack_require__(463), req = Object.create(http.IncomingMessage.prototype);
    function defineGetter(obj, name, getter) {
        Object.defineProperty(obj, name, {
            configurable: !0,
            enumerable: !0,
            get: getter
        });
    }
    module.exports = req, req.get = req.header = function(name) {
        if (!name) throw new TypeError("name argument is required to req.get");
        if ("string" != typeof name) throw new TypeError("name must be a string to req.get");
        var lc = name.toLowerCase();
        switch (lc) {
          case "referer":
          case "referrer":
            return this.headers.referrer || this.headers.referer;

          default:
            return this.headers[lc];
        }
    }, req.accepts = function() {
        var accept = accepts(this);
        return accept.types.apply(accept, arguments);
    }, req.acceptsEncodings = function() {
        var accept = accepts(this);
        return accept.encodings.apply(accept, arguments);
    }, req.acceptsEncoding = deprecate.function(req.acceptsEncodings, "req.acceptsEncoding: Use acceptsEncodings instead"), 
    req.acceptsCharsets = function() {
        var accept = accepts(this);
        return accept.charsets.apply(accept, arguments);
    }, req.acceptsCharset = deprecate.function(req.acceptsCharsets, "req.acceptsCharset: Use acceptsCharsets instead"), 
    req.acceptsLanguages = function() {
        var accept = accepts(this);
        return accept.languages.apply(accept, arguments);
    }, req.acceptsLanguage = deprecate.function(req.acceptsLanguages, "req.acceptsLanguage: Use acceptsLanguages instead"), 
    req.range = function(size, options) {
        var range = this.get("Range");
        if (range) return parseRange(size, range, options);
    }, req.param = function(name, defaultValue) {
        var params = this.params || {}, body = this.body || {}, query = this.query || {}, args = 1 === arguments.length ? "name" : "name, default";
        return deprecate("req.param(" + args + "): Use req.params, req.body, or req.query instead"), 
        null != params[name] && params.hasOwnProperty(name) ? params[name] : null != body[name] ? body[name] : null != query[name] ? query[name] : defaultValue;
    }, req.is = function(types) {
        var arr = types;
        if (!Array.isArray(types)) {
            arr = new Array(arguments.length);
            for (var i = 0; i < arr.length; i++) arr[i] = arguments[i];
        }
        return typeis(this, arr);
    }, defineGetter(req, "protocol", (function() {
        var proto = this.connection.encrypted ? "https" : "http";
        if (!this.app.get("trust proxy fn")(this.connection.remoteAddress, 0)) return proto;
        var header = this.get("X-Forwarded-Proto") || proto, index = header.indexOf(",");
        return -1 !== index ? header.substring(0, index).trim() : header.trim();
    })), defineGetter(req, "secure", (function() {
        return "https" === this.protocol;
    })), defineGetter(req, "ip", (function() {
        var trust = this.app.get("trust proxy fn");
        return proxyaddr(this, trust);
    })), defineGetter(req, "ips", (function() {
        var trust = this.app.get("trust proxy fn"), addrs = proxyaddr.all(this, trust);
        return addrs.reverse().pop(), addrs;
    })), defineGetter(req, "subdomains", (function() {
        var hostname = this.hostname;
        if (!hostname) return [];
        var offset = this.app.get("subdomain offset");
        return (isIP(hostname) ? [ hostname ] : hostname.split(".").reverse()).slice(offset);
    })), defineGetter(req, "path", (function() {
        return parse(this).pathname;
    })), defineGetter(req, "hostname", (function() {
        var trust = this.app.get("trust proxy fn"), host = this.get("X-Forwarded-Host");
        if (host && trust(this.connection.remoteAddress, 0) ? -1 !== host.indexOf(",") && (host = host.substring(0, host.indexOf(",")).trimRight()) : host = this.get("Host"), 
        host) {
            var offset = "[" === host[0] ? host.indexOf("]") + 1 : 0, index = host.indexOf(":", offset);
            return -1 !== index ? host.substring(0, index) : host;
        }
    })), defineGetter(req, "host", deprecate.function((function() {
        return this.hostname;
    }), "req.host: Use req.hostname instead")), defineGetter(req, "fresh", (function() {
        var method = this.method, res = this.res, status = res.statusCode;
        return ("GET" === method || "HEAD" === method) && (status >= 200 && status < 300 || 304 === status) && fresh(this.headers, {
            etag: res.get("ETag"),
            "last-modified": res.get("Last-Modified")
        });
    })), defineGetter(req, "stale", (function() {
        return !this.fresh;
    })), defineGetter(req, "xhr", (function() {
        return "xmlhttprequest" === (this.get("X-Requested-With") || "").toLowerCase();
    }));
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Negotiator = __webpack_require__(983), mime = __webpack_require__(89);
    function Accepts(req) {
        if (!(this instanceof Accepts)) return new Accepts(req);
        this.headers = req.headers, this.negotiator = new Negotiator(req);
    }
    function extToMime(type) {
        return -1 === type.indexOf("/") ? mime.lookup(type) : type;
    }
    function validMime(type) {
        return "string" == typeof type;
    }
    module.exports = Accepts, Accepts.prototype.type = Accepts.prototype.types = function(types_) {
        var types = types_;
        if (types && !Array.isArray(types)) {
            types = new Array(arguments.length);
            for (var i = 0; i < types.length; i++) types[i] = arguments[i];
        }
        if (!types || 0 === types.length) return this.negotiator.mediaTypes();
        if (!this.headers.accept) return types[0];
        var mimes = types.map(extToMime), accepts = this.negotiator.mediaTypes(mimes.filter(validMime)), first = accepts[0];
        return !!first && types[mimes.indexOf(first)];
    }, Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
        var encodings = encodings_;
        if (encodings && !Array.isArray(encodings)) {
            encodings = new Array(arguments.length);
            for (var i = 0; i < encodings.length; i++) encodings[i] = arguments[i];
        }
        return encodings && 0 !== encodings.length ? this.negotiator.encodings(encodings)[0] || !1 : this.negotiator.encodings();
    }, Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
        var charsets = charsets_;
        if (charsets && !Array.isArray(charsets)) {
            charsets = new Array(arguments.length);
            for (var i = 0; i < charsets.length; i++) charsets[i] = arguments[i];
        }
        return charsets && 0 !== charsets.length ? this.negotiator.charsets(charsets)[0] || !1 : this.negotiator.charsets();
    }, Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
        var languages = languages_;
        if (languages && !Array.isArray(languages)) {
            languages = new Array(arguments.length);
            for (var i = 0; i < languages.length; i++) languages[i] = arguments[i];
        }
        return languages && 0 !== languages.length ? this.negotiator.languages(languages)[0] || !1 : this.negotiator.languages();
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var modules = Object.create(null);
    function Negotiator(request) {
        if (!(this instanceof Negotiator)) return new Negotiator(request);
        this.request = request;
    }
    function loadModule(moduleName) {
        var module = modules[moduleName];
        if (void 0 !== module) return module;
        switch (moduleName) {
          case "charset":
            module = __webpack_require__(984);
            break;

          case "encoding":
            module = __webpack_require__(985);
            break;

          case "language":
            module = __webpack_require__(986);
            break;

          case "mediaType":
            module = __webpack_require__(987);
            break;

          default:
            throw new Error("Cannot find module '" + moduleName + "'");
        }
        return modules[moduleName] = module, module;
    }
    module.exports = Negotiator, module.exports.Negotiator = Negotiator, Negotiator.prototype.charset = function(available) {
        var set = this.charsets(available);
        return set && set[0];
    }, Negotiator.prototype.charsets = function(available) {
        return (0, loadModule("charset").preferredCharsets)(this.request.headers["accept-charset"], available);
    }, Negotiator.prototype.encoding = function(available) {
        var set = this.encodings(available);
        return set && set[0];
    }, Negotiator.prototype.encodings = function(available) {
        return (0, loadModule("encoding").preferredEncodings)(this.request.headers["accept-encoding"], available);
    }, Negotiator.prototype.language = function(available) {
        var set = this.languages(available);
        return set && set[0];
    }, Negotiator.prototype.languages = function(available) {
        return (0, loadModule("language").preferredLanguages)(this.request.headers["accept-language"], available);
    }, Negotiator.prototype.mediaType = function(available) {
        var set = this.mediaTypes(available);
        return set && set[0];
    }, Negotiator.prototype.mediaTypes = function(available) {
        return (0, loadModule("mediaType").preferredMediaTypes)(this.request.headers.accept, available);
    }, Negotiator.prototype.preferredCharset = Negotiator.prototype.charset, Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets, 
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding, Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings, 
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language, Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages, 
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType, Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = preferredCharsets, module.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseCharset(str, i) {
        var match = simpleCharsetRegExp.exec(str);
        if (!match) return null;
        var charset = match[1], q = 1;
        if (match[2]) for (var params = match[2].split(";"), j = 0; j < params.length; j++) {
            var p = params[j].trim().split("=");
            if ("q" === p[0]) {
                q = parseFloat(p[1]);
                break;
            }
        }
        return {
            charset: charset,
            q: q,
            i: i
        };
    }
    function specify(charset, spec, index) {
        var s = 0;
        if (spec.charset.toLowerCase() === charset.toLowerCase()) s |= 1; else if ("*" !== spec.charset) return null;
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    function preferredCharsets(accept, provided) {
        var accepts = (function(accept) {
            for (var accepts = accept.split(","), i = 0, j = 0; i < accepts.length; i++) {
                var charset = parseCharset(accepts[i].trim(), i);
                charset && (accepts[j++] = charset);
            }
            return accepts.length = j, accepts;
        })(void 0 === accept ? "*" : accept || "");
        if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
        var priorities = provided.map((function(type, index) {
            return (function(charset, accepted, index) {
                for (var priority = {
                    o: -1,
                    q: 0,
                    s: 0
                }, i = 0; i < accepted.length; i++) {
                    var spec = specify(charset, accepted[i], index);
                    spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 && (priority = spec);
                }
                return priority;
            })(type, accepts, index);
        }));
        return priorities.filter(isQuality).sort(compareSpecs).map((function(priority) {
            return provided[priorities.indexOf(priority)];
        }));
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullCharset(spec) {
        return spec.charset;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = preferredEncodings, module.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseEncoding(str, i) {
        var match = simpleEncodingRegExp.exec(str);
        if (!match) return null;
        var encoding = match[1], q = 1;
        if (match[2]) for (var params = match[2].split(";"), j = 0; j < params.length; j++) {
            var p = params[j].trim().split("=");
            if ("q" === p[0]) {
                q = parseFloat(p[1]);
                break;
            }
        }
        return {
            encoding: encoding,
            q: q,
            i: i
        };
    }
    function specify(encoding, spec, index) {
        var s = 0;
        if (spec.encoding.toLowerCase() === encoding.toLowerCase()) s |= 1; else if ("*" !== spec.encoding) return null;
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    function preferredEncodings(accept, provided) {
        var accepts = (function(accept) {
            for (var accepts = accept.split(","), hasIdentity = !1, minQuality = 1, i = 0, j = 0; i < accepts.length; i++) {
                var encoding = parseEncoding(accepts[i].trim(), i);
                encoding && (accepts[j++] = encoding, hasIdentity = hasIdentity || specify("identity", encoding), 
                minQuality = Math.min(minQuality, encoding.q || 1));
            }
            return hasIdentity || (accepts[j++] = {
                encoding: "identity",
                q: minQuality,
                i: i
            }), accepts.length = j, accepts;
        })(accept || "");
        if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
        var priorities = provided.map((function(type, index) {
            return (function(encoding, accepted, index) {
                for (var priority = {
                    o: -1,
                    q: 0,
                    s: 0
                }, i = 0; i < accepted.length; i++) {
                    var spec = specify(encoding, accepted[i], index);
                    spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 && (priority = spec);
                }
                return priority;
            })(type, accepts, index);
        }));
        return priorities.filter(isQuality).sort(compareSpecs).map((function(priority) {
            return provided[priorities.indexOf(priority)];
        }));
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullEncoding(spec) {
        return spec.encoding;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = preferredLanguages, module.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseLanguage(str, i) {
        var match = simpleLanguageRegExp.exec(str);
        if (!match) return null;
        var prefix = match[1], suffix = match[2], full = prefix;
        suffix && (full += "-" + suffix);
        var q = 1;
        if (match[3]) for (var params = match[3].split(";"), j = 0; j < params.length; j++) {
            var p = params[j].split("=");
            "q" === p[0] && (q = parseFloat(p[1]));
        }
        return {
            prefix: prefix,
            suffix: suffix,
            q: q,
            i: i,
            full: full
        };
    }
    function specify(language, spec, index) {
        var p = parseLanguage(language);
        if (!p) return null;
        var s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) s |= 4; else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) s |= 2; else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) s |= 1; else if ("*" !== spec.full) return null;
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    function preferredLanguages(accept, provided) {
        var accepts = (function(accept) {
            for (var accepts = accept.split(","), i = 0, j = 0; i < accepts.length; i++) {
                var language = parseLanguage(accepts[i].trim(), i);
                language && (accepts[j++] = language);
            }
            return accepts.length = j, accepts;
        })(void 0 === accept ? "*" : accept || "");
        if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
        var priorities = provided.map((function(type, index) {
            return (function(language, accepted, index) {
                for (var priority = {
                    o: -1,
                    q: 0,
                    s: 0
                }, i = 0; i < accepted.length; i++) {
                    var spec = specify(language, accepted[i], index);
                    spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 && (priority = spec);
                }
                return priority;
            })(type, accepts, index);
        }));
        return priorities.filter(isQuality).sort(compareSpecs).map((function(priority) {
            return provided[priorities.indexOf(priority)];
        }));
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullLanguage(spec) {
        return spec.full;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = preferredMediaTypes, module.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseMediaType(str, i) {
        var match = simpleMediaTypeRegExp.exec(str);
        if (!match) return null;
        var params = Object.create(null), q = 1, subtype = match[2], type = match[1];
        if (match[3]) for (var kvps = (function(str) {
            for (var parameters = str.split(";"), i = 1, j = 0; i < parameters.length; i++) quoteCount(parameters[j]) % 2 == 0 ? parameters[++j] = parameters[i] : parameters[j] += ";" + parameters[i];
            for (parameters.length = j + 1, i = 0; i < parameters.length; i++) parameters[i] = parameters[i].trim();
            return parameters;
        })(match[3]).map(splitKeyValuePair), j = 0; j < kvps.length; j++) {
            var pair = kvps[j], key = pair[0].toLowerCase(), val = pair[1], value = val && '"' === val[0] && '"' === val[val.length - 1] ? val.substr(1, val.length - 2) : val;
            if ("q" === key) {
                q = parseFloat(value);
                break;
            }
            params[key] = value;
        }
        return {
            type: type,
            subtype: subtype,
            params: params,
            q: q,
            i: i
        };
    }
    function specify(type, spec, index) {
        var p = parseMediaType(type), s = 0;
        if (!p) return null;
        if (spec.type.toLowerCase() == p.type.toLowerCase()) s |= 4; else if ("*" != spec.type) return null;
        if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) s |= 2; else if ("*" != spec.subtype) return null;
        var keys = Object.keys(spec.params);
        if (keys.length > 0) {
            if (!keys.every((function(k) {
                return "*" == spec.params[k] || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
            }))) return null;
            s |= 1;
        }
        return {
            i: index,
            o: spec.i,
            q: spec.q,
            s: s
        };
    }
    function preferredMediaTypes(accept, provided) {
        var accepts = (function(accept) {
            for (var accepts = (function(accept) {
                for (var accepts = accept.split(","), i = 1, j = 0; i < accepts.length; i++) quoteCount(accepts[j]) % 2 == 0 ? accepts[++j] = accepts[i] : accepts[j] += "," + accepts[i];
                return accepts.length = j + 1, accepts;
            })(accept), i = 0, j = 0; i < accepts.length; i++) {
                var mediaType = parseMediaType(accepts[i].trim(), i);
                mediaType && (accepts[j++] = mediaType);
            }
            return accepts.length = j, accepts;
        })(void 0 === accept ? "*/*" : accept || "");
        if (!provided) return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
        var priorities = provided.map((function(type, index) {
            return (function(type, accepted, index) {
                for (var priority = {
                    o: -1,
                    q: 0,
                    s: 0
                }, i = 0; i < accepted.length; i++) {
                    var spec = specify(type, accepted[i], index);
                    spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0 && (priority = spec);
                }
                return priority;
            })(type, accepts, index);
        }));
        return priorities.filter(isQuality).sort(compareSpecs).map((function(priority) {
            return provided[priorities.indexOf(priority)];
        }));
    }
    function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    function getFullType(spec) {
        return spec.type + "/" + spec.subtype;
    }
    function isQuality(spec) {
        return spec.q > 0;
    }
    function quoteCount(string) {
        for (var count = 0, index = 0; -1 !== (index = string.indexOf('"', index)); ) count++, 
        index++;
        return count;
    }
    function splitKeyValuePair(str) {
        var key, val, index = str.indexOf("=");
        return -1 === index ? key = str : (key = str.substr(0, index), val = str.substr(index + 1)), 
        [ key, val ];
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Buffer = __webpack_require__(23).Buffer, contentDisposition = __webpack_require__(460), deprecate = __webpack_require__(47)("express"), encodeUrl = __webpack_require__(83), escapeHtml = __webpack_require__(84), http = __webpack_require__(11), isAbsolute = __webpack_require__(67).isAbsolute, onFinished = __webpack_require__(85), path = __webpack_require__(4), statuses = __webpack_require__(109), merge = __webpack_require__(60), sign = __webpack_require__(989).sign, normalizeType = __webpack_require__(67).normalizeType, normalizeTypes = __webpack_require__(67).normalizeTypes, setCharset = __webpack_require__(67).setCharset, cookie = __webpack_require__(990), send = __webpack_require__(225), extname = path.extname, mime = send.mime, resolve = path.resolve, vary = __webpack_require__(464), res = Object.create(http.ServerResponse.prototype);
    module.exports = res;
    var charsetRegExp = /;\s*charset\s*=/;
    function sendfile(res, file, options, callback) {
        var streaming, done = !1;
        function onaborted() {
            if (!done) {
                done = !0;
                var err = new Error("Request aborted");
                err.code = "ECONNABORTED", callback(err);
            }
        }
        function onerror(err) {
            done || (done = !0, callback(err));
        }
        file.on("directory", (function() {
            if (!done) {
                done = !0;
                var err = new Error("EISDIR, read");
                err.code = "EISDIR", callback(err);
            }
        })), file.on("end", (function() {
            done || (done = !0, callback());
        })), file.on("error", onerror), file.on("file", (function() {
            streaming = !1;
        })), file.on("stream", (function() {
            streaming = !0;
        })), onFinished(res, (function(err) {
            return err && "ECONNRESET" === err.code ? onaborted() : err ? onerror(err) : void (done || setImmediate((function() {
                !1 === streaming || done ? done || (done = !0, callback()) : onaborted();
            })));
        })), options.headers && file.on("headers", (function(res) {
            for (var obj = options.headers, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
                var k = keys[i];
                res.setHeader(k, obj[k]);
            }
        })), file.pipe(res);
    }
    function stringify(value, replacer, spaces, escape) {
        var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);
        return escape && (json = json.replace(/[<>&]/g, (function(c) {
            switch (c.charCodeAt(0)) {
              case 60:
                return "\\u003c";

              case 62:
                return "\\u003e";

              case 38:
                return "\\u0026";

              default:
                return c;
            }
        }))), json;
    }
    res.status = function(code) {
        return this.statusCode = code, this;
    }, res.links = function(links) {
        var link = this.get("Link") || "";
        return link && (link += ", "), this.set("Link", link + Object.keys(links).map((function(rel) {
            return "<" + links[rel] + '>; rel="' + rel + '"';
        })).join(", "));
    }, res.send = function(body) {
        var encoding, type, chunk = body, req = this.req, app = this.app;
        switch (2 === arguments.length && ("number" != typeof arguments[0] && "number" == typeof arguments[1] ? (deprecate("res.send(body, status): Use res.status(status).send(body) instead"), 
        this.statusCode = arguments[1]) : (deprecate("res.send(status, body): Use res.status(status).send(body) instead"), 
        this.statusCode = arguments[0], chunk = arguments[1])), "number" == typeof chunk && 1 === arguments.length && (this.get("Content-Type") || this.type("txt"), 
        deprecate("res.send(status): Use res.sendStatus(status) instead"), this.statusCode = chunk, 
        chunk = statuses[chunk]), typeof chunk) {
          case "string":
            this.get("Content-Type") || this.type("html");
            break;

          case "boolean":
          case "number":
          case "object":
            if (null === chunk) chunk = ""; else {
                if (!Buffer.isBuffer(chunk)) return this.json(chunk);
                this.get("Content-Type") || this.type("bin");
            }
        }
        "string" == typeof chunk && (encoding = "utf8", "string" == typeof (type = this.get("Content-Type")) && this.set("Content-Type", setCharset(type, "utf-8")));
        var len, etag, etagFn = app.get("etag fn"), generateETag = !this.get("ETag") && "function" == typeof etagFn;
        return void 0 !== chunk && (Buffer.isBuffer(chunk) ? len = chunk.length : !generateETag && chunk.length < 1e3 ? len = Buffer.byteLength(chunk, encoding) : (chunk = Buffer.from(chunk, encoding), 
        encoding = void 0, len = chunk.length), this.set("Content-Length", len)), generateETag && void 0 !== len && (etag = etagFn(chunk, encoding)) && this.set("ETag", etag), 
        req.fresh && (this.statusCode = 304), 204 !== this.statusCode && 304 !== this.statusCode || (this.removeHeader("Content-Type"), 
        this.removeHeader("Content-Length"), this.removeHeader("Transfer-Encoding"), chunk = ""), 
        "HEAD" === req.method ? this.end() : this.end(chunk, encoding), this;
    }, res.json = function(obj) {
        var val = obj;
        2 === arguments.length && ("number" == typeof arguments[1] ? (deprecate("res.json(obj, status): Use res.status(status).json(obj) instead"), 
        this.statusCode = arguments[1]) : (deprecate("res.json(status, obj): Use res.status(status).json(obj) instead"), 
        this.statusCode = arguments[0], val = arguments[1]));
        var app = this.app, escape = app.get("json escape"), replacer = app.get("json replacer"), spaces = app.get("json spaces"), body = stringify(val, replacer, spaces, escape);
        return this.get("Content-Type") || this.set("Content-Type", "application/json"), 
        this.send(body);
    }, res.jsonp = function(obj) {
        var val = obj;
        2 === arguments.length && ("number" == typeof arguments[1] ? (deprecate("res.jsonp(obj, status): Use res.status(status).json(obj) instead"), 
        this.statusCode = arguments[1]) : (deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead"), 
        this.statusCode = arguments[0], val = arguments[1]));
        var app = this.app, escape = app.get("json escape"), replacer = app.get("json replacer"), spaces = app.get("json spaces"), body = stringify(val, replacer, spaces, escape), callback = this.req.query[app.get("jsonp callback name")];
        return this.get("Content-Type") || (this.set("X-Content-Type-Options", "nosniff"), 
        this.set("Content-Type", "application/json")), Array.isArray(callback) && (callback = callback[0]), 
        "string" == typeof callback && 0 !== callback.length && (this.set("X-Content-Type-Options", "nosniff"), 
        this.set("Content-Type", "text/javascript"), body = "/**/ typeof " + (callback = callback.replace(/[^\[\]\w$.]/g, "")) + " === 'function' && " + callback + "(" + (body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")) + ");"), 
        this.send(body);
    }, res.sendStatus = function(statusCode) {
        var body = statuses[statusCode] || String(statusCode);
        return this.statusCode = statusCode, this.type("txt"), this.send(body);
    }, res.sendFile = function(path, options, callback) {
        var done = callback, req = this.req, next = req.next, opts = options || {};
        if (!path) throw new TypeError("path argument is required to res.sendFile");
        if ("string" != typeof path) throw new TypeError("path must be a string to res.sendFile");
        if ("function" == typeof options && (done = options, opts = {}), !opts.root && !isAbsolute(path)) throw new TypeError("path must be absolute or specify root to res.sendFile");
        var pathname = encodeURI(path);
        sendfile(this, send(req, pathname, opts), opts, (function(err) {
            return done ? done(err) : err && "EISDIR" === err.code ? next() : void (err && "ECONNABORTED" !== err.code && "write" !== err.syscall && next(err));
        }));
    }, res.sendfile = function(path, options, callback) {
        var done = callback, req = this.req, next = req.next, opts = options || {};
        "function" == typeof options && (done = options, opts = {}), sendfile(this, send(req, path, opts), opts, (function(err) {
            return done ? done(err) : err && "EISDIR" === err.code ? next() : void (err && "ECONNABORTED" !== err.code && "write" !== err.syscall && next(err));
        }));
    }, res.sendfile = deprecate.function(res.sendfile, "res.sendfile: Use res.sendFile instead"), 
    res.download = function(path, filename, options, callback) {
        var done = callback, name = filename, opts = options || null;
        "function" == typeof filename ? (done = filename, name = null, opts = null) : "function" == typeof options && (done = options, 
        opts = null);
        var headers = {
            "Content-Disposition": contentDisposition(name || path)
        };
        if (opts && opts.headers) for (var keys = Object.keys(opts.headers), i = 0; i < keys.length; i++) {
            var key = keys[i];
            "content-disposition" !== key.toLowerCase() && (headers[key] = opts.headers[key]);
        }
        (opts = Object.create(opts)).headers = headers;
        var fullPath = resolve(path);
        return this.sendFile(fullPath, opts, done);
    }, res.contentType = res.type = function(type) {
        var ct = -1 === type.indexOf("/") ? mime.lookup(type) : type;
        return this.set("Content-Type", ct);
    }, res.format = function(obj) {
        var req = this.req, next = req.next, fn = obj.default;
        fn && delete obj.default;
        var keys = Object.keys(obj), key = keys.length > 0 && req.accepts(keys);
        if (this.vary("Accept"), key) this.set("Content-Type", normalizeType(key).value), 
        obj[key](req, this, next); else if (fn) fn(); else {
            var err = new Error("Not Acceptable");
            err.status = err.statusCode = 406, err.types = normalizeTypes(keys).map((function(o) {
                return o.value;
            })), next(err);
        }
        return this;
    }, res.attachment = function(filename) {
        return filename && this.type(extname(filename)), this.set("Content-Disposition", contentDisposition(filename)), 
        this;
    }, res.append = function(field, val) {
        var prev = this.get(field), value = val;
        return prev && (value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [ prev ].concat(val) : [ prev, val ]), 
        this.set(field, value);
    }, res.set = res.header = function(field, val) {
        if (2 === arguments.length) {
            var value = Array.isArray(val) ? val.map(String) : String(val);
            if ("content-type" === field.toLowerCase()) {
                if (Array.isArray(value)) throw new TypeError("Content-Type cannot be set to an Array");
                if (!charsetRegExp.test(value)) {
                    var charset = mime.charsets.lookup(value.split(";")[0]);
                    charset && (value += "; charset=" + charset.toLowerCase());
                }
            }
            this.setHeader(field, value);
        } else for (var key in field) this.set(key, field[key]);
        return this;
    }, res.get = function(field) {
        return this.getHeader(field);
    }, res.clearCookie = function(name, options) {
        var opts = merge({
            expires: new Date(1),
            path: "/"
        }, options);
        return this.cookie(name, "", opts);
    }, res.cookie = function(name, value, options) {
        var opts = merge({}, options), secret = this.req.secret, signed = opts.signed;
        if (signed && !secret) throw new Error('cookieParser("secret") required for signed cookies');
        var val = "object" == typeof value ? "j:" + JSON.stringify(value) : String(value);
        return signed && (val = "s:" + sign(val, secret)), "maxAge" in opts && (opts.expires = new Date(Date.now() + opts.maxAge), 
        opts.maxAge /= 1e3), null == opts.path && (opts.path = "/"), this.append("Set-Cookie", cookie.serialize(name, String(val), opts)), 
        this;
    }, res.location = function(url) {
        var loc = url;
        return "back" === url && (loc = this.req.get("Referrer") || "/"), this.set("Location", encodeUrl(loc));
    }, res.redirect = function(url) {
        var body, address = url, status = 302;
        2 === arguments.length && ("number" == typeof arguments[0] ? (status = arguments[0], 
        address = arguments[1]) : (deprecate("res.redirect(url, status): Use res.redirect(status, url) instead"), 
        status = arguments[1])), address = this.location(address).get("Location"), this.format({
            text: function() {
                body = statuses[status] + ". Redirecting to " + address;
            },
            html: function() {
                var u = escapeHtml(address);
                body = "<p>" + statuses[status] + '. Redirecting to <a href="' + u + '">' + u + "</a></p>";
            },
            default: function() {
                body = "";
            }
        }), this.statusCode = status, this.set("Content-Length", Buffer.byteLength(body)), 
        "HEAD" === this.req.method ? this.end() : this.end(body);
    }, res.vary = function(field) {
        return !field || Array.isArray(field) && !field.length ? (deprecate("res.vary(): Provide a field name"), 
        this) : (vary(this, field), this);
    }, res.render = function(view, options, callback) {
        var app = this.req.app, done = callback, opts = options || {}, req = this.req, self = this;
        "function" == typeof options && (done = options, opts = {}), opts._locals = self.locals, 
        done = done || function(err, str) {
            if (err) return req.next(err);
            self.send(str);
        }, app.render(view, opts, done);
    };
}, function(module, exports, __webpack_require__) {
    var crypto = __webpack_require__(9);
    function sha1(str) {
        return crypto.createHash("sha1").update(str).digest("hex");
    }
    exports.sign = function(val, secret) {
        if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
        if ("string" != typeof secret) throw new TypeError("Secret string must be provided.");
        return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    }, exports.unsign = function(val, secret) {
        if ("string" != typeof val) throw new TypeError("Signed cookie string must be provided.");
        if ("string" != typeof secret) throw new TypeError("Secret string must be provided.");
        var str = val.slice(0, val.lastIndexOf("."));
        return sha1(exports.sign(str, secret)) == sha1(val) && str;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    exports.parse = function(str, options) {
        if ("string" != typeof str) throw new TypeError("argument str must be a string");
        for (var obj = {}, opt = options || {}, pairs = str.split(pairSplitRegExp), dec = opt.decode || decode, i = 0; i < pairs.length; i++) {
            var pair = pairs[i], eq_idx = pair.indexOf("=");
            if (!(eq_idx < 0)) {
                var key = pair.substr(0, eq_idx).trim(), val = pair.substr(++eq_idx, pair.length).trim();
                '"' == val[0] && (val = val.slice(1, -1)), null == obj[key] && (obj[key] = tryDecode(val, dec));
            }
        }
        return obj;
    }, exports.serialize = function(name, val, options) {
        var opt = options || {}, enc = opt.encode || encode;
        if ("function" != typeof enc) throw new TypeError("option encode is invalid");
        if (!fieldContentRegExp.test(name)) throw new TypeError("argument name is invalid");
        var value = enc(val);
        if (value && !fieldContentRegExp.test(value)) throw new TypeError("argument val is invalid");
        var str = name + "=" + value;
        if (null != opt.maxAge) {
            var maxAge = opt.maxAge - 0;
            if (isNaN(maxAge)) throw new Error("maxAge should be a Number");
            str += "; Max-Age=" + Math.floor(maxAge);
        }
        if (opt.domain) {
            if (!fieldContentRegExp.test(opt.domain)) throw new TypeError("option domain is invalid");
            str += "; Domain=" + opt.domain;
        }
        if (opt.path) {
            if (!fieldContentRegExp.test(opt.path)) throw new TypeError("option path is invalid");
            str += "; Path=" + opt.path;
        }
        if (opt.expires) {
            if ("function" != typeof opt.expires.toUTCString) throw new TypeError("option expires is invalid");
            str += "; Expires=" + opt.expires.toUTCString();
        }
        if (opt.httpOnly && (str += "; HttpOnly"), opt.secure && (str += "; Secure"), opt.sameSite) switch ("string" == typeof opt.sameSite ? opt.sameSite.toLowerCase() : opt.sameSite) {
          case !0:
            str += "; SameSite=Strict";
            break;

          case "lax":
            str += "; SameSite=Lax";
            break;

          case "strict":
            str += "; SameSite=Strict";
            break;

          case "none":
            str += "; SameSite=None";
            break;

          default:
            throw new TypeError("option sameSite is invalid");
        }
        return str;
    };
    var decode = decodeURIComponent, encode = encodeURIComponent, pairSplitRegExp = /; */, fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function tryDecode(str, decode) {
        try {
            return decode(str);
        } catch (e) {
            return str;
        }
    }
}, function(module, exports, __webpack_require__) {
    "use strict";
    var encodeUrl = __webpack_require__(83), escapeHtml = __webpack_require__(84), parseUrl = __webpack_require__(46), resolve = __webpack_require__(4).resolve, send = __webpack_require__(225), url = __webpack_require__(7);
    module.exports = function(root, options) {
        if (!root) throw new TypeError("root path required");
        if ("string" != typeof root) throw new TypeError("root path must be a string");
        var opts = Object.create(options || null), fallthrough = !1 !== opts.fallthrough, redirect = !1 !== opts.redirect, setHeaders = opts.setHeaders;
        if (setHeaders && "function" != typeof setHeaders) throw new TypeError("option setHeaders must be function");
        opts.maxage = opts.maxage || opts.maxAge || 0, opts.root = resolve(root);
        var onDirectory = redirect ? function(res) {
            if (this.hasTrailingSlash()) this.error(404); else {
                var originalUrl = parseUrl.original(this.req);
                originalUrl.path = null, originalUrl.pathname = (function(str) {
                    for (var i = 0; i < str.length && 47 === str.charCodeAt(i); i++) ;
                    return i > 1 ? "/" + str.substr(i) : str;
                })(originalUrl.pathname + "/");
                var loc = encodeUrl(url.format(originalUrl)), doc = ("Redirecting", '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Redirecting</title>\n</head>\n<body>\n<pre>' + ('Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + "</a>") + "</pre>\n</body>\n</html>\n");
                res.statusCode = 301, res.setHeader("Content-Type", "text/html; charset=UTF-8"), 
                res.setHeader("Content-Length", Buffer.byteLength(doc)), res.setHeader("Content-Security-Policy", "default-src 'none'"), 
                res.setHeader("X-Content-Type-Options", "nosniff"), res.setHeader("Location", loc), 
                res.end(doc);
            }
        } : function() {
            this.error(404);
        };
        return function(req, res, next) {
            if ("GET" !== req.method && "HEAD" !== req.method) return fallthrough ? next() : (res.statusCode = 405, 
            res.setHeader("Allow", "GET, HEAD"), res.setHeader("Content-Length", "0"), void res.end());
            var forwardError = !fallthrough, originalUrl = parseUrl.original(req), path = parseUrl(req).pathname;
            "/" === path && "/" !== originalUrl.pathname.substr(-1) && (path = "");
            var stream = send(req, path, opts);
            stream.on("directory", onDirectory), setHeaders && stream.on("headers", setHeaders), 
            fallthrough && stream.on("file", (function() {
                forwardError = !0;
            })), stream.on("error", (function(err) {
                !forwardError && err.statusCode < 500 ? next() : next(err);
            })), stream.pipe(res);
        };
    }, module.exports.mime = send.mime;
}, function(module, exports, __webpack_require__) {
    !(function() {
        "use strict";
        var assign = __webpack_require__(993), vary = __webpack_require__(464), defaults = {
            origin: "*",
            methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
            preflightContinue: !1,
            optionsSuccessStatus: 204
        };
        function isString(s) {
            return "string" == typeof s || s instanceof String;
        }
        function isOriginAllowed(origin, allowedOrigin) {
            if (Array.isArray(allowedOrigin)) {
                for (var i = 0; i < allowedOrigin.length; ++i) if (isOriginAllowed(origin, allowedOrigin[i])) return !0;
                return !1;
            }
            return isString(allowedOrigin) ? origin === allowedOrigin : allowedOrigin instanceof RegExp ? allowedOrigin.test(origin) : !!allowedOrigin;
        }
        function configureOrigin(options, req) {
            var isAllowed, requestOrigin = req.headers.origin, headers = [];
            return options.origin && "*" !== options.origin ? isString(options.origin) ? (headers.push([ {
                key: "Access-Control-Allow-Origin",
                value: options.origin
            } ]), headers.push([ {
                key: "Vary",
                value: "Origin"
            } ])) : (isAllowed = isOriginAllowed(requestOrigin, options.origin), headers.push([ {
                key: "Access-Control-Allow-Origin",
                value: !!isAllowed && requestOrigin
            } ]), headers.push([ {
                key: "Vary",
                value: "Origin"
            } ])) : headers.push([ {
                key: "Access-Control-Allow-Origin",
                value: "*"
            } ]), headers;
        }
        function configureCredentials(options) {
            return !0 === options.credentials ? {
                key: "Access-Control-Allow-Credentials",
                value: "true"
            } : null;
        }
        function configureExposedHeaders(options) {
            var headers = options.exposedHeaders;
            return headers ? (headers.join && (headers = headers.join(",")), headers && headers.length ? {
                key: "Access-Control-Expose-Headers",
                value: headers
            } : null) : null;
        }
        function applyHeaders(headers, res) {
            for (var i = 0, n = headers.length; i < n; i++) {
                var header = headers[i];
                header && (Array.isArray(header) ? applyHeaders(header, res) : "Vary" === header.key && header.value ? vary(res, header.value) : header.value && res.setHeader(header.key, header.value));
            }
        }
        module.exports = function(o) {
            var optionsCallback = null;
            return optionsCallback = "function" == typeof o ? o : function(req, cb) {
                cb(null, o);
            }, function(req, res, next) {
                optionsCallback(req, (function(err, options) {
                    if (err) next(err); else {
                        var corsOptions = assign({}, defaults, options), originCallback = null;
                        corsOptions.origin && "function" == typeof corsOptions.origin ? originCallback = corsOptions.origin : corsOptions.origin && (originCallback = function(origin, cb) {
                            cb(null, corsOptions.origin);
                        }), originCallback ? originCallback(req.headers.origin, (function(err2, origin) {
                            err2 || !origin ? next(err2) : (corsOptions.origin = origin, (function(options, req, res, next) {
                                var headers = [];
                                "OPTIONS" === (req.method && req.method.toUpperCase && req.method.toUpperCase()) ? (headers.push(configureOrigin(options, req)), 
                                headers.push(configureCredentials(options)), headers.push((function(options) {
                                    var methods = options.methods;
                                    return methods.join && (methods = options.methods.join(",")), {
                                        key: "Access-Control-Allow-Methods",
                                        value: methods
                                    };
                                })(options)), headers.push((function(options, req) {
                                    var allowedHeaders = options.allowedHeaders || options.headers, headers = [];
                                    return allowedHeaders ? allowedHeaders.join && (allowedHeaders = allowedHeaders.join(",")) : (allowedHeaders = req.headers["access-control-request-headers"], 
                                    headers.push([ {
                                        key: "Vary",
                                        value: "Access-Control-Request-Headers"
                                    } ])), allowedHeaders && allowedHeaders.length && headers.push([ {
                                        key: "Access-Control-Allow-Headers",
                                        value: allowedHeaders
                                    } ]), headers;
                                })(options, req)), headers.push((function(options) {
                                    var maxAge = ("number" == typeof options.maxAge || options.maxAge) && options.maxAge.toString();
                                    return maxAge && maxAge.length ? {
                                        key: "Access-Control-Max-Age",
                                        value: maxAge
                                    } : null;
                                })(options)), headers.push(configureExposedHeaders(options)), applyHeaders(headers, res), 
                                options.preflightContinue ? next() : (res.statusCode = options.optionsSuccessStatus, 
                                res.setHeader("Content-Length", "0"), res.end())) : (headers.push(configureOrigin(options, req)), 
                                headers.push(configureCredentials(options)), headers.push(configureExposedHeaders(options)), 
                                applyHeaders(headers, res), next());
                            })(corsOptions, req, res, next));
                        })) : next();
                    }
                }));
            };
        };
    })();
}, function(module, exports, __webpack_require__) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
        if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(val);
    }
    module.exports = (function() {
        try {
            if (!Object.assign) return !1;
            var test1 = new String("abc");
            if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
            for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
            if ("0123456789" !== Object.getOwnPropertyNames(test2).map((function(n) {
                return test2[n];
            })).join("")) return !1;
            var test3 = {};
            return "abcdefghijklmnopqrst".split("").forEach((function(letter) {
                test3[letter] = letter;
            })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
        } catch (err) {
            return !1;
        }
    })() ? Object.assign : function(target, source) {
        for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
            for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
            if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from);
                for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
            }
        }
        return to;
    };
}, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(995);
}, function(module, exports, __webpack_require__) {
    const semver = __webpack_require__(996);
    function lintManifest(manifest) {
        var errors = [], warnings = [];
        if (!manifest || "object" != typeof manifest) return {
            valid: !1,
            errors: [ new Error("manifest must be an object") ]
        };
        function assertString(val, name) {
            "string" != typeof val && errors.push(new Error(name + " must be a string"));
        }
        function assertArray(val, name) {
            Array.isArray(val) || errors.push(new Error(name + " must be an array"));
        }
        return assertString(manifest.id, "manifest.id"), assertString(manifest.name, "manifest.name"), 
        (function(val, name) {
            "string" == typeof val && semver.valid(val) || errors.push(new Error("manifest.version must be a valid semver string"));
        })(manifest.version), assertArray(manifest.resources, "manifest.resources"), Array.isArray(manifest.resources) && (function(val, set, name) {
            Array.isArray(val) && val.forEach((function(m) {
                set.includes(m) || warnings.push(new Error("manifest.resources: unknown value " + m));
            }));
        })(manifest.resources.map((function(r) {
            return r && r.name ? r.name : r;
        })), [ "catalog", "meta", "stream", "subtitles" ]), assertArray(manifest.types, "manifest.types"), 
        assertArray(manifest.catalogs, "manifest.catalogs"), manifest.hasOwnProperty("idPrefixes") && null !== manifest.idPrefixes && assertArray(manifest.idPrefixes, "manifest.idPrefixes"), 
        Array.isArray(manifest.catalogs) && manifest.catalogs.forEach((function(catalog, i) {
            "string" == typeof catalog.id && "string" == typeof catalog.type || errors.push(new Error("manifest.catalogs[" + i + "]: id and type must be string properties")), 
            catalog.hasOwnProperty("extra") && assertArray(catalog.extra, "manifest.catalogs[" + i + "].extra"), 
            catalog.hasOwnProperty("extraSupported") && assertArray(catalog.extraSupported, "manifest.catalogs[" + i + "].extraSupported"), 
            catalog.hasOwnProperty("extraRequired") && assertArray(catalog.extraRequired, "manifest.catalogs[" + i + "].extraRequired");
        })), {
            valid: !errors.length,
            errors: errors,
            warnings: warnings
        };
    }
    module.exports = {
        lintManifest: lintManifest,
        lintCollection: function(col) {
            var errors = [];
            return Array.isArray(col) ? col.forEach((function(item, i) {
                "string" != typeof item.transportUrl && errors.push(new Error(i + ": transportUrl must be a string")), 
                "string" != typeof item.transportName && errors.push(new Error(i + ": transportName must be a string")), 
                errors = errors.concat(lintManifest(item.manifest).errors);
            })) : errors.push(new Error("col is not an array")), {
                valid: !errors.length,
                errors: errors,
                warnings: []
            };
        }
    };
}, function(module, exports) {
    var debug;
    exports = module.exports = SemVer, debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER"), console.log.apply(console, args);
    } : function() {}, exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, re = exports.re = [], src = exports.src = [], R = 0, NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++, FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?", LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+", re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+", re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")", 
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (var i = 0; i < 35; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
    function parse(version, options) {
        if (options && "object" == typeof options || (options = {
            loose: !!options,
            includePrerelease: !1
        }), version instanceof SemVer) return version;
        if ("string" != typeof version) return null;
        if (version.length > 256) return null;
        if (!(options.loose ? re[LOOSE] : re[FULL]).test(version)) return null;
        try {
            return new SemVer(version, options);
        } catch (er) {
            return null;
        }
    }
    function SemVer(version, options) {
        if (options && "object" == typeof options || (options = {
            loose: !!options,
            includePrerelease: !1
        }), version instanceof SemVer) {
            if (version.loose === options.loose) return version;
            version = version.version;
        } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);
        if (version.length > 256) throw new TypeError("version is longer than 256 characters");
        if (!(this instanceof SemVer)) return new SemVer(version, options);
        debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
        var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
        if (!m) throw new TypeError("Invalid Version: " + version);
        if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
        this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        m[4] ? this.prerelease = m[4].split(".").map((function(id) {
            if (/^[0-9]+$/.test(id)) {
                var num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
            }
            return id;
        })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
    }
    exports.parse = parse, exports.valid = function(version, options) {
        var v = parse(version, options);
        return v ? v.version : null;
    }, exports.clean = function(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
    }, exports.SemVer = SemVer, SemVer.prototype.format = function() {
        return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), 
        this.version;
    }, SemVer.prototype.toString = function() {
        return this.version;
    }, SemVer.prototype.compare = function(other) {
        return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), 
        this.compareMain(other) || this.comparePre(other);
    }, SemVer.prototype.compareMain = function(other) {
        return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }, SemVer.prototype.comparePre = function(other) {
        if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
        if (!this.prerelease.length && other.prerelease.length) return 1;
        if (!this.prerelease.length && !other.prerelease.length) return 0;
        var i = 0;
        do {
            var a = this.prerelease[i], b = other.prerelease[i];
            if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
            if (void 0 === b) return 1;
            if (void 0 === a) return -1;
            if (a !== b) return compareIdentifiers(a, b);
        } while (++i);
    }, SemVer.prototype.inc = function(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
            break;

          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
            break;

          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
            break;

          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
            break;

          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
            this.minor = 0, this.patch = 0, this.prerelease = [];
            break;

          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
            this.prerelease = [];
            break;

          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;

          case "pre":
            if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
                for (var i = this.prerelease.length; --i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
                i = -2);
                -1 === i && this.prerelease.push(0);
            }
            identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
            break;

          default:
            throw new Error("invalid increment argument: " + release);
        }
        return this.format(), this.raw = this.version, this;
    }, exports.inc = function(version, release, loose, identifier) {
        "string" == typeof loose && (identifier = loose, loose = void 0);
        try {
            return new SemVer(version, loose).inc(release, identifier).version;
        } catch (er) {
            return null;
        }
    }, exports.diff = function(version1, version2) {
        if (eq(version1, version2)) return null;
        var v1 = parse(version1), v2 = parse(version2), prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
            prefix = "pre";
            var defaultResult = "prerelease";
        }
        for (var key in v1) if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return prefix + key;
        return defaultResult;
    }, exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
        var anum = numeric.test(a), bnum = numeric.test(b);
        return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    function compare(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    function gt(a, b, loose) {
        return compare(a, b, loose) > 0;
    }
    function lt(a, b, loose) {
        return compare(a, b, loose) < 0;
    }
    function eq(a, b, loose) {
        return 0 === compare(a, b, loose);
    }
    function neq(a, b, loose) {
        return 0 !== compare(a, b, loose);
    }
    function gte(a, b, loose) {
        return compare(a, b, loose) >= 0;
    }
    function lte(a, b, loose) {
        return compare(a, b, loose) <= 0;
    }
    function cmp(a, op, b, loose) {
        switch (op) {
          case "===":
            return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
            a === b;

          case "!==":
            return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
            a !== b;

          case "":
          case "=":
          case "==":
            return eq(a, b, loose);

          case "!=":
            return neq(a, b, loose);

          case ">":
            return gt(a, b, loose);

          case ">=":
            return gte(a, b, loose);

          case "<":
            return lt(a, b, loose);

          case "<=":
            return lte(a, b, loose);

          default:
            throw new TypeError("Invalid operator: " + op);
        }
    }
    function Comparator(comp, options) {
        if (options && "object" == typeof options || (options = {
            loose: !!options,
            includePrerelease: !1
        }), comp instanceof Comparator) {
            if (comp.loose === !!options.loose) return comp;
            comp = comp.value;
        }
        if (!(this instanceof Comparator)) return new Comparator(comp, options);
        debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, 
        this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
        debug("comp", this);
    }
    exports.rcompareIdentifiers = function(a, b) {
        return compareIdentifiers(b, a);
    }, exports.major = function(a, loose) {
        return new SemVer(a, loose).major;
    }, exports.minor = function(a, loose) {
        return new SemVer(a, loose).minor;
    }, exports.patch = function(a, loose) {
        return new SemVer(a, loose).patch;
    }, exports.compare = compare, exports.compareLoose = function(a, b) {
        return compare(a, b, !0);
    }, exports.rcompare = function(a, b, loose) {
        return compare(b, a, loose);
    }, exports.sort = function(list, loose) {
        return list.sort((function(a, b) {
            return exports.compare(a, b, loose);
        }));
    }, exports.rsort = function(list, loose) {
        return list.sort((function(a, b) {
            return exports.rcompare(a, b, loose);
        }));
    }, exports.gt = gt, exports.lt = lt, exports.eq = eq, exports.neq = neq, exports.gte = gte, 
    exports.lte = lte, exports.cmp = cmp, exports.Comparator = Comparator;
    var ANY = {};
    function Range(range, options) {
        if (options && "object" == typeof options || (options = {
            loose: !!options,
            includePrerelease: !1
        }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
        if (range instanceof Comparator) return new Range(range.value, options);
        if (!(this instanceof Range)) return new Range(range, options);
        if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
        this.raw = range, this.set = range.split(/\s*\|\|\s*/).map((function(range) {
            return this.parseRange(range.trim());
        }), this).filter((function(c) {
            return c.length;
        })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + range);
        this.format();
    }
    function isX(id) {
        return !id || "x" === id.toLowerCase() || "*" === id;
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
        return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
    }
    function testSet(set, version, options) {
        for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
        if (version.prerelease.length && !options.includePrerelease) {
            for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
                var allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
            }
            return !1;
        }
        return !0;
    }
    function satisfies(version, range, options) {
        try {
            range = new Range(range, options);
        } catch (er) {
            return !1;
        }
        return range.test(version);
    }
    function outside(version, range, hilo, options) {
        var gtfn, ltefn, ltfn, comp, ecomp;
        switch (version = new SemVer(version, options), range = new Range(range, options), 
        hilo) {
          case ">":
            gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
            break;

          case "<":
            gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
            break;

          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version, range, options)) return !1;
        for (var i = 0; i < range.set.length; ++i) {
            var comparators = range.set[i], high = null, low = null;
            if (comparators.forEach((function(comparator) {
                comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
                low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
            })), high.operator === comp || high.operator === ecomp) return !1;
            if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
            if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
        }
        return !0;
    }
    Comparator.prototype.parse = function(comp) {
        var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR], m = comp.match(r);
        if (!m) throw new TypeError("Invalid comparator: " + comp);
        this.operator = m[1], "=" === this.operator && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
    }, Comparator.prototype.toString = function() {
        return this.value;
    }, Comparator.prototype.test = function(version) {
        return debug("Comparator.test", version, this.options.loose), this.semver === ANY || ("string" == typeof version && (version = new SemVer(version, this.options)), 
        cmp(version, this.operator, this.semver, this.options));
    }, Comparator.prototype.intersects = function(comp, options) {
        if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
        var rangeTmp;
        if (options && "object" == typeof options || (options = {
            loose: !!options,
            includePrerelease: !1
        }), "" === this.operator) return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
        if ("" === comp.operator) return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
        var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator), sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }, exports.Range = Range, Range.prototype.format = function() {
        return this.range = this.set.map((function(comps) {
            return comps.join(" ").trim();
        })).join("||").trim(), this.range;
    }, Range.prototype.toString = function() {
        return this.range;
    }, Range.prototype.parseRange = function(range) {
        var loose = this.options.loose;
        range = range.trim();
        var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
        range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[COMPARATORTRIM], "$1$2$3"), 
        debug("comparator trim", range, re[COMPARATORTRIM]), range = (range = (range = range.replace(re[TILDETRIM], "$1~")).replace(re[CARETTRIM], "$1^")).split(/\s+/).join(" ");
        var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR], set = range.split(" ").map((function(comp) {
            return (function(comp, options) {
                return debug("comp", comp, options), comp = (function(comp, options) {
                    return comp.trim().split(/\s+/).map((function(comp) {
                        return (function(comp, options) {
                            debug("caret", comp, options);
                            var r = options.loose ? re[CARETLOOSE] : re[CARET];
                            return comp.replace(r, (function(_, M, m, p, pr) {
                                var ret;
                                return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), 
                                ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), 
                                ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), 
                                debug("caret return", ret), ret;
                            }));
                        })(comp, options);
                    })).join(" ");
                })(comp, options), debug("caret", comp), comp = (function(comp, options) {
                    return comp.trim().split(/\s+/).map((function(comp) {
                        return (function(comp, options) {
                            var r = options.loose ? re[TILDELOOSE] : re[TILDE];
                            return comp.replace(r, (function(_, M, m, p, pr) {
                                var ret;
                                return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), 
                                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", 
                                debug("tilde return", ret), ret;
                            }));
                        })(comp, options);
                    })).join(" ");
                })(comp, options), debug("tildes", comp), comp = (function(comp, options) {
                    return debug("replaceXRanges", comp, options), comp.split(/\s+/).map((function(comp) {
                        return (function(comp, options) {
                            comp = comp.trim();
                            var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
                            return comp.replace(r, (function(ret, gtlt, M, m, p, pr) {
                                debug("xRange", comp, ret, gtlt, M, m, p, pr);
                                var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p);
                                return "=" === gtlt && xp && (gtlt = ""), xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0" : "*" : gtlt && xp ? (xm && (m = 0), 
                                p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
                                p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), 
                                debug("xRange return", ret), ret;
                            }));
                        })(comp, options);
                    })).join(" ");
                })(comp, options), debug("xrange", comp), comp = (function(comp, options) {
                    return debug("replaceStars", comp, options), comp.trim().replace(re[STAR], "");
                })(comp, options), debug("stars", comp), comp;
            })(comp, this.options);
        }), this).join(" ").split(/\s+/);
        return this.options.loose && (set = set.filter((function(comp) {
            return !!comp.match(compRe);
        }))), set.map((function(comp) {
            return new Comparator(comp, this.options);
        }), this);
    }, Range.prototype.intersects = function(range, options) {
        if (!(range instanceof Range)) throw new TypeError("a Range is required");
        return this.set.some((function(thisComparators) {
            return thisComparators.every((function(thisComparator) {
                return range.set.some((function(rangeComparators) {
                    return rangeComparators.every((function(rangeComparator) {
                        return thisComparator.intersects(rangeComparator, options);
                    }));
                }));
            }));
        }));
    }, exports.toComparators = function(range, options) {
        return new Range(range, options).set.map((function(comp) {
            return comp.map((function(c) {
                return c.value;
            })).join(" ").trim().split(" ");
        }));
    }, Range.prototype.test = function(version) {
        if (!version) return !1;
        "string" == typeof version && (version = new SemVer(version, this.options));
        for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
        return !1;
    }, exports.satisfies = satisfies, exports.maxSatisfying = function(versions, range, options) {
        var max = null, maxSV = null;
        try {
            var rangeObj = new Range(range, options);
        } catch (er) {
            return null;
        }
        return versions.forEach((function(v) {
            rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (maxSV = new SemVer(max = v, options)));
        })), max;
    }, exports.minSatisfying = function(versions, range, options) {
        var min = null, minSV = null;
        try {
            var rangeObj = new Range(range, options);
        } catch (er) {
            return null;
        }
        return versions.forEach((function(v) {
            rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (minSV = new SemVer(min = v, options)));
        })), min;
    }, exports.minVersion = function(range, loose) {
        range = new Range(range, loose);
        var minver = new SemVer("0.0.0");
        if (range.test(minver)) return minver;
        if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
        minver = null;
        for (var i = 0; i < range.set.length; ++i) range.set[i].forEach((function(comparator) {
            var compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
                compver.raw = compver.format();

              case "":
              case ">=":
                minver && !gt(minver, compver) || (minver = compver);
                break;

              case "<":
              case "<=":
                break;

              default:
                throw new Error("Unexpected operation: " + comparator.operator);
            }
        }));
        return minver && range.test(minver) ? minver : null;
    }, exports.validRange = function(range, options) {
        try {
            return new Range(range, options).range || "*";
        } catch (er) {
            return null;
        }
    }, exports.ltr = function(version, range, options) {
        return outside(version, range, "<", options);
    }, exports.gtr = function(version, range, options) {
        return outside(version, range, ">", options);
    }, exports.outside = outside, exports.prerelease = function(version, options) {
        var parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }, exports.intersects = function(r1, r2, options) {
        return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
    }, exports.coerce = function(version) {
        if (version instanceof SemVer) return version;
        if ("string" != typeof version) return null;
        var match = version.match(re[COERCE]);
        return null == match ? null : parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    };
}, function(module, exports, __webpack_require__) {
    const mkdirp = __webpack_require__(132), path = __webpack_require__(4), fs = __webpack_require__(2);
    function commitRes(endPath, res) {
        mkdirp(path.dirname(endPath), (function(err) {
            if (err) return console.error(err);
            fs.writeFile(endPath, JSON.stringify(res), (function(err) {
                if (err) return console.error(err);
                console.log("Written " + endPath);
            }));
        }));
    }
    module.exports = function(baseDir, manifest, handlers) {
        function addToQueue(res, type, id, extra, cb) {
            const endPath = path.join(baseDir, res, type, id + ".json");
            handlers[res]({
                id: id,
                type: type,
                extra: {}
            }, (function(err, res) {
                if (err) return cb(err);
                commitRes(endPath, res), cb(null, res);
            }));
        }
        mkdirp.sync(baseDir), commitRes(path.join(baseDir, "manifest.json"), manifest), 
        manifest.catalogs && handlers.catalog && manifest.catalogs.forEach((function(cat) {
            addToQueue("catalog", cat.type, cat.id, 0, (function(err, res) {
                err && console.error(err), res && Array.isArray(res.metas) && (function(res) {
                    res.metas.forEach((function(meta) {
                        meta.id && addToQueue("meta", meta.type, meta.id, 0, (function(err, res) {
                            err && console.error(err);
                        }));
                    }));
                })(res);
            }));
        }));
    };
}, function(module, exports, __webpack_require__) {
    const fetch = __webpack_require__(33);
    module.exports = function(addonURL, apiURL) {
        return fetch((apiURL = apiURL || "https://api.strem.io") + "/api/addonPublish", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                transportUrl: addonURL,
                transportName: "http"
            })
        }).then((function(res) {
            return res.json();
        })).then((function(resp) {
            if (resp.error) throw resp.error;
            return resp.result;
        }));
    };
}, function(module, exports, __webpack_require__) {
    const manifest = __webpack_require__(465), manifestNoCatalogs = Object.assign({}, manifest);
    manifestNoCatalogs.name += " (without catalog support)", manifestNoCatalogs.catalogs = [], 
    manifestNoCatalogs.resources = manifest.resources.filter((resource => "catalog" != resource.name && "catalog" != resource)), 
    module.exports = manifestNoCatalogs;
}, function(module, exports, __webpack_require__) {
    const consts = __webpack_require__(79);
    module.exports = function(storage, metaStorage, args, cb) {
        const metas = [];
        storage.indexes.itemId.forEach((function(items, itemId) {
            const entry = storage.getAggrEntry("itemId", itemId, [ "files" ]);
            if (!(entry.itemId && entry.files && entry.files.length)) return;
            const firstFile = entry.files[0], meta = metaStorage.indexes.primaryKey.get(entry.itemId);
            metas.push(meta || {
                id: entry.itemId,
                type: "other",
                name: firstFile.parsedName || entry.name,
                poster: firstFile.imdb_id ? consts.METAHUB_URL + "/poster/medium/" + firstFile.imdb_id + "/img" : null
            });
        })), cb(null, {
            metas: metas
        });
    };
}, function(module, exports, __webpack_require__) {
    const fetch = __webpack_require__(33), indexer = __webpack_require__(467), mapEntryToMeta = __webpack_require__(468), consts = __webpack_require__(79);
    function mapFile(entry, uxTime, file, index) {
        const stream = entry.ih ? {
            infoHash: entry.ih,
            fileIdx: file.idx,
            title: entry.ih + "/" + file.idx,
            sources: entry.sources
        } : {
            title: file.path,
            url: "file://" + file.path,
            subtitle: consts.STREAM_LOCALFILE_SUBTITLE
        }, videoId = [ file.imdb_id, file.season, file.episode ].filter((x => x)).join(":"), thumbnail = file.season && file.episode ? `${consts.METAHUB_EPISODES_URL}/${file.imdb_id}/${file.season}/${file.episode}/w780.jpg` : `${consts.METAHUB_URL}/background/medium/${file.imdb_id}/img`;
        return {
            id: videoId || stream.title,
            title: file.name,
            publishedAt: entry.dateModified || new Date,
            released: new Date(uxTime - 6e4 * index),
            stream: stream,
            season: file.season,
            episode: file.episode,
            thumbnail: file.imdb_id ? thumbnail : null
        };
    }
    module.exports = function(storage, metaStorage, engineUrl, args, cb) {
        let entry = storage.getAggrEntry("itemId", args.id, [ "files" ]);
        if (!entry && args.id.startsWith(consts.PREFIX_BT) && (entry = (function(engineUrl, ih) {
            return fetch(engineUrl + "/" + ih + "/create", {
                method: "POST"
            }).then((function(resp) {
                return resp.json();
            })).then((function(torrent) {
                return new Promise((function(resolve, reject) {
                    indexer.indexParsedTorrent(torrent, (function(err, entry) {
                        return err ? reject(err) : entry ? void resolve(entry) : reject(new Error("internal err: no entry from indexParsedTorrent"));
                    }));
                }));
            }));
        })(engineUrl, args.id.slice(consts.PREFIX_BT.length))), !entry) return cb(null, null);
        Promise.resolve(entry).then((function(entry) {
            const videos = entry.files.sort((function(a, b) {
                try {
                    return a.season - b.season || a.episode - b.episode;
                } catch (e) {}
                return 0;
            })).map(mapFile.bind(null, entry, (new Date).getTime()));
            return Promise.resolve(metaStorage.indexes.primaryKey.get(entry.itemId)).then((function(meta) {
                return meta || mapEntryToMeta(entry);
            })).then((function(meta) {
                meta.videos = videos, cb(null, {
                    meta: meta
                });
            }));
        })).catch((function(err) {
            console.log(err), cb(null, null);
        }));
    };
}, function(module, exports, __webpack_require__) {
    const bencode = __webpack_require__(1003), blobToBuffer = __webpack_require__(1006), fs = __webpack_require__(2), get = __webpack_require__(376), magnet = __webpack_require__(1007), path = __webpack_require__(4), sha1 = __webpack_require__(165), uniq = __webpack_require__(114);
    function parseTorrent(torrentId) {
        if ("string" == typeof torrentId && /^(stream-)?magnet:/.test(torrentId)) return magnet(torrentId);
        if ("string" == typeof torrentId && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) return magnet(`magnet:?xt=urn:btih:${torrentId}`);
        if (Buffer.isBuffer(torrentId) && 20 === torrentId.length) return magnet(`magnet:?xt=urn:btih:${torrentId.toString("hex")}`);
        if (Buffer.isBuffer(torrentId)) return (function(torrent) {
            Buffer.isBuffer(torrent) && (torrent = bencode.decode(torrent)), ensure(torrent.info, "info"), 
            ensure(torrent.info["name.utf-8"] || torrent.info.name, "info.name"), ensure(torrent.info["piece length"], "info['piece length']"), 
            ensure(torrent.info.pieces, "info.pieces"), torrent.info.files ? torrent.info.files.forEach((file => {
                ensure("number" == typeof file.length, "info.files[0].length"), ensure(file["path.utf-8"] || file.path, "info.files[0].path");
            })) : ensure("number" == typeof torrent.info.length, "info.length");
            const result = {
                info: torrent.info,
                infoBuffer: bencode.encode(torrent.info),
                name: (torrent.info["name.utf-8"] || torrent.info.name).toString(),
                announce: []
            };
            result.infoHash = sha1.sync(result.infoBuffer), result.infoHashBuffer = Buffer.from(result.infoHash, "hex"), 
            void 0 !== torrent.info.private && (result.private = !!torrent.info.private), torrent["creation date"] && (result.created = new Date(1e3 * torrent["creation date"])), 
            torrent["created by"] && (result.createdBy = torrent["created by"].toString()), 
            Buffer.isBuffer(torrent.comment) && (result.comment = torrent.comment.toString()), 
            Array.isArray(torrent["announce-list"]) && torrent["announce-list"].length > 0 ? torrent["announce-list"].forEach((urls => {
                urls.forEach((url => {
                    result.announce.push(url.toString());
                }));
            })) : torrent.announce && result.announce.push(torrent.announce.toString()), Buffer.isBuffer(torrent["url-list"]) && (torrent["url-list"] = torrent["url-list"].length > 0 ? [ torrent["url-list"] ] : []), 
            result.urlList = (torrent["url-list"] || []).map((url => url.toString())), uniq(result.announce), 
            uniq(result.urlList);
            const files = torrent.info.files || [ torrent.info ];
            result.files = files.map(((file, i) => {
                const parts = [].concat(result.name, file["path.utf-8"] || file.path || []).map((p => p.toString()));
                return {
                    path: path.join.apply(null, [ path.sep ].concat(parts)).slice(1),
                    name: parts[parts.length - 1],
                    length: file.length,
                    offset: files.slice(0, i).reduce(sumLength, 0)
                };
            })), result.length = files.reduce(sumLength, 0);
            const lastFile = result.files[result.files.length - 1];
            return result.pieceLength = torrent.info["piece length"], result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength, 
            result.pieces = (function(buf) {
                const pieces = [];
                for (let i = 0; i < buf.length; i += 20) pieces.push(buf.slice(i, i + 20).toString("hex"));
                return pieces;
            })(torrent.info.pieces), result;
        })(torrentId);
        if (torrentId && torrentId.infoHash) return torrentId.infoHash = torrentId.infoHash.toLowerCase(), 
        torrentId.announce || (torrentId.announce = []), "string" == typeof torrentId.announce && (torrentId.announce = [ torrentId.announce ]), 
        torrentId.urlList || (torrentId.urlList = []), torrentId;
        throw new Error("Invalid torrent identifier");
    }
    function sumLength(sum, file) {
        return sum + file.length;
    }
    function ensure(bool, fieldName) {
        if (!bool) throw new Error(`Torrent is missing required field: ${fieldName}`);
    }
    module.exports = parseTorrent, module.exports.remote = function(torrentId, cb) {
        let parsedTorrent;
        if ("function" != typeof cb) throw new Error("second argument must be a Function");
        try {
            parsedTorrent = parseTorrent(torrentId);
        } catch (err) {}
        function parseOrThrow(torrentBuf) {
            try {
                parsedTorrent = parseTorrent(torrentBuf);
            } catch (err) {
                return cb(err);
            }
            parsedTorrent && parsedTorrent.infoHash ? cb(null, parsedTorrent) : cb(new Error("Invalid torrent identifier"));
        }
        parsedTorrent && parsedTorrent.infoHash ? process.nextTick((() => {
            cb(null, parsedTorrent);
        })) : "undefined" != typeof Blob && torrentId instanceof Blob ? blobToBuffer(torrentId, ((err, torrentBuf) => {
            if (err) return cb(new Error(`Error converting Blob: ${err.message}`));
            parseOrThrow(torrentBuf);
        })) : "function" == typeof get && /^https?:/.test(torrentId) ? get.concat({
            url: torrentId,
            timeout: 3e4,
            headers: {
                "user-agent": "WebTorrent (https://webtorrent.io)"
            }
        }, ((err, res, torrentBuf) => {
            if (err) return cb(new Error(`Error downloading torrent: ${err.message}`));
            parseOrThrow(torrentBuf);
        })) : "function" == typeof fs.readFile && "string" == typeof torrentId ? fs.readFile(torrentId, ((err, torrentBuf) => {
            if (err) return cb(new Error("Invalid torrent identifier"));
            parseOrThrow(torrentBuf);
        })) : process.nextTick((() => {
            cb(new Error("Invalid torrent identifier"));
        }));
    }, module.exports.toMagnetURI = magnet.encode, module.exports.toTorrentFile = function(parsed) {
        const torrent = {
            info: parsed.info
        };
        return torrent["announce-list"] = (parsed.announce || []).map((url => (torrent.announce || (torrent.announce = url), 
        [ url = Buffer.from(url, "utf8") ]))), torrent["url-list"] = parsed.urlList || [], 
        void 0 !== parsed.private && (torrent.private = Number(parsed.private)), parsed.created && (torrent["creation date"] = parsed.created.getTime() / 1e3 | 0), 
        parsed.createdBy && (torrent["created by"] = parsed.createdBy), parsed.comment && (torrent.comment = parsed.comment), 
        bencode.encode(torrent);
    }, Buffer.alloc(0);
}, function(module, exports, __webpack_require__) {
    var bencode = module.exports;
    bencode.encode = __webpack_require__(1004), bencode.decode = __webpack_require__(1005), 
    bencode.byteLength = bencode.encodingLength = function(value) {
        return bencode.encode(value).length;
    };
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(90).Buffer;
    function encode(data, buffer, offset) {
        var buffers = [], result = null;
        return encode._encode(buffers, data), result = Buffer.concat(buffers), encode.bytes = result.length, 
        Buffer.isBuffer(buffer) ? (result.copy(buffer, offset), buffer) : result;
    }
    encode.bytes = -1, encode._floatConversionDetected = !1, encode.getType = function(value) {
        return Buffer.isBuffer(value) ? "buffer" : Array.isArray(value) ? "array" : ArrayBuffer.isView(value) ? "arraybufferview" : value instanceof Number ? "number" : value instanceof Boolean ? "boolean" : value instanceof ArrayBuffer ? "arraybuffer" : typeof value;
    }, encode._encode = function(buffers, data) {
        if (null != data) switch (encode.getType(data)) {
          case "buffer":
            encode.buffer(buffers, data);
            break;

          case "object":
            encode.dict(buffers, data);
            break;

          case "array":
            encode.list(buffers, data);
            break;

          case "string":
            encode.string(buffers, data);
            break;

          case "number":
          case "boolean":
            encode.number(buffers, data);
            break;

          case "arraybufferview":
            encode.buffer(buffers, Buffer.from(data.buffer, data.byteOffset, data.byteLength));
            break;

          case "arraybuffer":
            encode.buffer(buffers, Buffer.from(data));
        }
    };
    var buffE = Buffer.from("e"), buffD = Buffer.from("d"), buffL = Buffer.from("l");
    encode.buffer = function(buffers, data) {
        buffers.push(Buffer.from(data.length + ":"), data);
    }, encode.string = function(buffers, data) {
        buffers.push(Buffer.from(Buffer.byteLength(data) + ":" + data));
    }, encode.number = function(buffers, data) {
        var val = 2147483648 * (data / 2147483648 << 0) + (data % 2147483648 << 0);
        buffers.push(Buffer.from("i" + val + "e")), val === data || encode._floatConversionDetected || (encode._floatConversionDetected = !0, 
        console.warn('WARNING: Possible data corruption detected with value "' + data + '":', 'Bencoding only defines support for integers, value was converted to "' + val + '"'), 
        console.trace());
    }, encode.dict = function(buffers, data) {
        buffers.push(buffD);
        for (var k, j = 0, keys = Object.keys(data).sort(), kl = keys.length; j < kl; j++) null != data[k = keys[j]] && (encode.string(buffers, k), 
        encode._encode(buffers, data[k]));
        buffers.push(buffE);
    }, encode.list = function(buffers, data) {
        var i = 0, c = data.length;
        for (buffers.push(buffL); i < c; i++) null != data[i] && encode._encode(buffers, data[i]);
        buffers.push(buffE);
    }, module.exports = encode;
}, function(module, exports, __webpack_require__) {
    var Buffer = __webpack_require__(90).Buffer;
    function getIntFromBuffer(buffer, start, end) {
        for (var sum = 0, sign = 1, i = start; i < end; i++) {
            var num = buffer[i];
            if (num < 58 && num >= 48) sum = 10 * sum + (num - 48); else if (i !== start || 43 !== num) {
                if (i !== start || 45 !== num) {
                    if (46 === num) break;
                    throw new Error("not a number: buffer[" + i + "] = " + num);
                }
                sign = -1;
            }
        }
        return sum * sign;
    }
    function decode(data, start, end, encoding) {
        return null == data || 0 === data.length ? null : ("number" != typeof start && null == encoding && (encoding = start, 
        start = void 0), "number" != typeof end && null == encoding && (encoding = end, 
        end = void 0), decode.position = 0, decode.encoding = encoding || null, decode.data = Buffer.isBuffer(data) ? data.slice(start, end) : Buffer.from(data), 
        decode.bytes = decode.data.length, decode.next());
    }
    decode.bytes = 0, decode.position = 0, decode.data = null, decode.encoding = null, 
    decode.next = function() {
        switch (decode.data[decode.position]) {
          case 100:
            return decode.dictionary();

          case 108:
            return decode.list();

          case 105:
            return decode.integer();

          default:
            return decode.buffer();
        }
    }, decode.find = function(chr) {
        for (var i = decode.position, c = decode.data.length, d = decode.data; i < c; ) {
            if (d[i] === chr) return i;
            i++;
        }
        throw new Error('Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]");
    }, decode.dictionary = function() {
        decode.position++;
        for (var dict = {}; 101 !== decode.data[decode.position]; ) dict[decode.buffer()] = decode.next();
        return decode.position++, dict;
    }, decode.list = function() {
        decode.position++;
        for (var lst = []; 101 !== decode.data[decode.position]; ) lst.push(decode.next());
        return decode.position++, lst;
    }, decode.integer = function() {
        var end = decode.find(101), number = getIntFromBuffer(decode.data, decode.position + 1, end);
        return decode.position += end + 1 - decode.position, number;
    }, decode.buffer = function() {
        var sep = decode.find(58), length = getIntFromBuffer(decode.data, decode.position, sep), end = ++sep + length;
        return decode.position = end, decode.encoding ? decode.data.toString(decode.encoding, sep, end) : decode.data.slice(sep, end);
    }, module.exports = decode;
}, function(module, exports) {
    module.exports = function(blob, cb) {
        if ("undefined" == typeof Blob || !(blob instanceof Blob)) throw new Error("first argument must be a Blob");
        if ("function" != typeof cb) throw new Error("second argument must be a function");
        var reader = new FileReader;
        reader.addEventListener("loadend", (function onLoadEnd(e) {
            reader.removeEventListener("loadend", onLoadEnd, !1), e.error ? cb(e.error) : cb(null, Buffer.from(reader.result));
        }), !1), reader.readAsArrayBuffer(blob);
    };
}, function(module, exports, __webpack_require__) {
    module.exports = magnetURIDecode, module.exports.decode = magnetURIDecode, module.exports.encode = function(obj) {
        (obj = Object.assign({}, obj)).infoHashBuffer && (obj.xt = `urn:btih:${obj.infoHashBuffer.toString("hex")}`), 
        obj.infoHash && (obj.xt = `urn:btih:${obj.infoHash}`), obj.name && (obj.dn = obj.name), 
        obj.keywords && (obj.kt = obj.keywords), obj.announce && (obj.tr = obj.announce), 
        obj.urlList && (obj.ws = obj.urlList, delete obj.as);
        let result = "magnet:?";
        return Object.keys(obj).filter((key => 2 === key.length)).forEach(((key, i) => {
            (Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]).forEach(((val, j) => {
                !(i > 0 || j > 0) || "kt" === key && 0 !== j || (result += "&"), "dn" === key && (val = encodeURIComponent(val).replace(/%20/g, "+")), 
                "tr" !== key && "xs" !== key && "as" !== key && "ws" !== key || (val = encodeURIComponent(val)), 
                "kt" === key && (val = encodeURIComponent(val)), result += "kt" === key && j > 0 ? `+${val}` : `${key}=${val}`;
            }));
        })), result;
    };
    const base32 = __webpack_require__(1008), uniq = __webpack_require__(114);
    function magnetURIDecode(uri) {
        const result = {}, data = uri.split("magnet:?")[1];
        let m;
        return (data && data.length >= 0 ? data.split("&") : []).forEach((param => {
            const keyval = param.split("=");
            if (2 !== keyval.length) return;
            const key = keyval[0];
            let val = keyval[1];
            if ("dn" === key && (val = decodeURIComponent(val).replace(/\+/g, " ")), "tr" !== key && "xs" !== key && "as" !== key && "ws" !== key || (val = decodeURIComponent(val)), 
            "kt" === key && (val = decodeURIComponent(val).split("+")), "ix" === key && (val = Number(val)), 
            result[key]) if (Array.isArray(result[key])) result[key].push(val); else {
                const old = result[key];
                result[key] = [ old, val ];
            } else result[key] = val;
        })), result.xt && (Array.isArray(result.xt) ? result.xt : [ result.xt ]).forEach((xt => {
            if (m = xt.match(/^urn:btih:(.{40})/)) result.infoHash = m[1].toLowerCase(); else if (m = xt.match(/^urn:btih:(.{32})/)) {
                const decodedStr = base32.decode(m[1]);
                result.infoHash = Buffer.from(decodedStr, "binary").toString("hex");
            }
        })), result.infoHash && (result.infoHashBuffer = Buffer.from(result.infoHash, "hex")), 
        result.dn && (result.name = result.dn), result.kt && (result.keywords = result.kt), 
        "string" == typeof result.tr ? result.announce = [ result.tr ] : Array.isArray(result.tr) ? result.announce = result.tr : result.announce = [], 
        result.urlList = [], ("string" == typeof result.as || Array.isArray(result.as)) && (result.urlList = result.urlList.concat(result.as)), 
        ("string" == typeof result.ws || Array.isArray(result.ws)) && (result.urlList = result.urlList.concat(result.ws)), 
        uniq(result.announce), uniq(result.urlList), result;
    }
}, function(module, exports, __webpack_require__) {
    var base32 = __webpack_require__(1009);
    exports.encode = base32.encode, exports.decode = base32.decode;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var byteTable = [ 255, 255, 26, 27, 28, 29, 30, 31, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255 ];
    exports.encode = function(plain) {
        Buffer.isBuffer(plain) || (plain = new Buffer(plain));
        for (var buff, quintets, i = 0, j = 0, shiftIndex = 0, digit = 0, encoded = new Buffer(8 * (buff = plain, 
        quintets = Math.floor(buff.length / 5), buff.length % 5 == 0 ? quintets : quintets + 1)); i < plain.length; ) {
            var current = plain[i];
            shiftIndex > 3 ? (digit = (digit = current & 255 >> shiftIndex) << (shiftIndex = (shiftIndex + 5) % 8) | (i + 1 < plain.length ? plain[i + 1] : 0) >> 8 - shiftIndex, 
            i++) : (digit = current >> 8 - (shiftIndex + 5) & 31, 0 == (shiftIndex = (shiftIndex + 5) % 8) && i++), 
            encoded[j] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".charCodeAt(digit), j++;
        }
        for (i = j; i < encoded.length; i++) encoded[i] = 61;
        return encoded;
    }, exports.decode = function(encoded) {
        var plainChar, shiftIndex = 0, plainDigit = 0, plainPos = 0;
        Buffer.isBuffer(encoded) || (encoded = new Buffer(encoded));
        for (var decoded = new Buffer(Math.ceil(5 * encoded.length / 8)), i = 0; i < encoded.length && 61 !== encoded[i]; i++) {
            var encodedByte = encoded[i] - 48;
            if (!(encodedByte < byteTable.length)) throw new Error("Invalid input - it is not base32 encoded string");
            plainDigit = byteTable[encodedByte], shiftIndex <= 3 ? 0 == (shiftIndex = (shiftIndex + 5) % 8) ? (plainChar |= plainDigit, 
            decoded[plainPos] = plainChar, plainPos++, plainChar = 0) : plainChar |= 255 & plainDigit << 8 - shiftIndex : (plainChar |= 255 & plainDigit >>> (shiftIndex = (shiftIndex + 5) % 8), 
            decoded[plainPos] = plainChar, plainPos++, plainChar = 255 & plainDigit << 8 - shiftIndex);
        }
        return decoded.slice(0, plainPos);
    };
}, function(module, exports, __webpack_require__) {
    const namedQueue = __webpack_require__(270), helpers = __webpack_require__(226);
    var providers = {
        metadata: __webpack_require__(1012),
        imdbFind: __webpack_require__(1013)
    }, defaultProviders = [ "metadata", "imdbFind" ], cache = {}, cacheLastSet = {}, queue = new namedQueue((function(task, cb) {
        var prov = [].concat(task.providers);
        !(function nextProv() {
            var n = prov.shift();
            if (!n) return cb(null, null);
            var provider = providers[n];
            if (!provider) return cb(new Error("unknown provider: " + n));
            provider(task.q, (function(err, res) {
                return err ? cb(err) : res ? cb(null, res, {
                    match: n
                }) : void nextProv();
            }));
        })();
    }), 3);
    module.exports = function(args, cb) {
        args = "string" == typeof args ? {
            name: args
        } : args;
        var q = {
            name: helpers.parseSearchTerm(args.name)
        };
        if (args.year && (q.year = args.year), args.type && (q.type = args.type), !q.name) return cb(new Error("empty name"));
        if (q.year && "string" == typeof q.year && (q.year = parseInt(q.year.split("-")[0])), 
        q.year && isNaN(q.year)) return cb(new Error("invalid year"));
        if (q.type && "movie" != q.type && "series" != q.type) return cb(null, null);
        var key = new Buffer.from(args.hintUrl || Object.values(q).join(":")).toString("ascii");
        if (cache.hasOwnProperty(key) && Date.now() - cacheLastSet[key] < 432e5) return cb(null, cache[key][0], {
            match: cache[key][1].match,
            isCached: !0
        });
        queue.push({
            id: key,
            q: q,
            providers: args.providers || defaultProviders
        }, (function(err, res, match) {
            if (err) return cb(err);
            res && res.id && (cache[key] = [ res.id, match ], cacheLastSet[key] = Date.now()), 
            cb(null, (res || {}).id, {
                ...match,
                meta: res
            });
        }));
    };
}, function(module, exports) {
    exports.remove = function(str) {
        return str.replace(/[^\u0000-\u007e]/g, (function(c) {
            return diacriticsMap[c] || c;
        }));
    };
    for (var replacementList = [ {
        base: " ",
        chars: " "
    }, {
        base: "0",
        chars: "߀"
    }, {
        base: "A",
        chars: "ⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
    }, {
        base: "AA",
        chars: "Ꜳ"
    }, {
        base: "AE",
        chars: "ÆǼǢ"
    }, {
        base: "AO",
        chars: "Ꜵ"
    }, {
        base: "AU",
        chars: "Ꜷ"
    }, {
        base: "AV",
        chars: "ꜸꜺ"
    }, {
        base: "AY",
        chars: "Ꜽ"
    }, {
        base: "B",
        chars: "ⒷＢḂḄḆɃƁ"
    }, {
        base: "C",
        chars: "ⒸＣꜾḈĆCĈĊČÇƇȻ"
    }, {
        base: "D",
        chars: "ⒹＤḊĎḌḐḒḎĐƊƉᴅꝹ"
    }, {
        base: "Dh",
        chars: "Ð"
    }, {
        base: "DZ",
        chars: "ǱǄ"
    }, {
        base: "Dz",
        chars: "ǲǅ"
    }, {
        base: "E",
        chars: "ɛⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎᴇ"
    }, {
        base: "F",
        chars: "ꝼⒻＦḞƑꝻ"
    }, {
        base: "G",
        chars: "ⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾɢ"
    }, {
        base: "H",
        chars: "ⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
    }, {
        base: "I",
        chars: "ⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
    }, {
        base: "J",
        chars: "ⒿＪĴɈȷ"
    }, {
        base: "K",
        chars: "ⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
    }, {
        base: "L",
        chars: "ⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
    }, {
        base: "LJ",
        chars: "Ǉ"
    }, {
        base: "Lj",
        chars: "ǈ"
    }, {
        base: "M",
        chars: "ⓂＭḾṀṂⱮƜϻ"
    }, {
        base: "N",
        chars: "ꞤȠⓃＮǸŃÑṄŇṆŅṊṈƝꞐᴎ"
    }, {
        base: "NJ",
        chars: "Ǌ"
    }, {
        base: "Nj",
        chars: "ǋ"
    }, {
        base: "O",
        chars: "ⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
    }, {
        base: "OE",
        chars: "Œ"
    }, {
        base: "OI",
        chars: "Ƣ"
    }, {
        base: "OO",
        chars: "Ꝏ"
    }, {
        base: "OU",
        chars: "Ȣ"
    }, {
        base: "P",
        chars: "ⓅＰṔṖƤⱣꝐꝒꝔ"
    }, {
        base: "Q",
        chars: "ⓆＱꝖꝘɊ"
    }, {
        base: "R",
        chars: "ⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
    }, {
        base: "S",
        chars: "ⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
    }, {
        base: "T",
        chars: "ⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
    }, {
        base: "Th",
        chars: "Þ"
    }, {
        base: "TZ",
        chars: "Ꜩ"
    }, {
        base: "U",
        chars: "ⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
    }, {
        base: "V",
        chars: "ⓋＶṼṾƲꝞɅ"
    }, {
        base: "VY",
        chars: "Ꝡ"
    }, {
        base: "W",
        chars: "ⓌＷẀẂŴẆẄẈⱲ"
    }, {
        base: "X",
        chars: "ⓍＸẊẌ"
    }, {
        base: "Y",
        chars: "ⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
    }, {
        base: "Z",
        chars: "ⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
    }, {
        base: "a",
        chars: "ⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑ"
    }, {
        base: "aa",
        chars: "ꜳ"
    }, {
        base: "ae",
        chars: "æǽǣ"
    }, {
        base: "ao",
        chars: "ꜵ"
    }, {
        base: "au",
        chars: "ꜷ"
    }, {
        base: "av",
        chars: "ꜹꜻ"
    }, {
        base: "ay",
        chars: "ꜽ"
    }, {
        base: "b",
        chars: "ⓑｂḃḅḇƀƃɓƂ"
    }, {
        base: "c",
        chars: "ｃⓒćĉċčçḉƈȼꜿↄ"
    }, {
        base: "d",
        chars: "ⓓｄḋďḍḑḓḏđƌɖɗƋᏧԁꞪ"
    }, {
        base: "dh",
        chars: "ð"
    }, {
        base: "dz",
        chars: "ǳǆ"
    }, {
        base: "e",
        chars: "ⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇǝ"
    }, {
        base: "f",
        chars: "ⓕｆḟƒ"
    }, {
        base: "ff",
        chars: "ﬀ"
    }, {
        base: "fi",
        chars: "ﬁ"
    }, {
        base: "fl",
        chars: "ﬂ"
    }, {
        base: "ffi",
        chars: "ﬃ"
    }, {
        base: "ffl",
        chars: "ﬄ"
    }, {
        base: "g",
        chars: "ⓖｇǵĝḡğġǧģǥɠꞡꝿᵹ"
    }, {
        base: "h",
        chars: "ⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
    }, {
        base: "hv",
        chars: "ƕ"
    }, {
        base: "i",
        chars: "ⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
    }, {
        base: "j",
        chars: "ⓙｊĵǰɉ"
    }, {
        base: "k",
        chars: "ⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
    }, {
        base: "l",
        chars: "ⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇɭ"
    }, {
        base: "lj",
        chars: "ǉ"
    }, {
        base: "m",
        chars: "ⓜｍḿṁṃɱɯ"
    }, {
        base: "n",
        chars: "ⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥлԉ"
    }, {
        base: "nj",
        chars: "ǌ"
    }, {
        base: "o",
        chars: "ⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿꝋꝍɵɔᴑ"
    }, {
        base: "oe",
        chars: "œ"
    }, {
        base: "oi",
        chars: "ƣ"
    }, {
        base: "oo",
        chars: "ꝏ"
    }, {
        base: "ou",
        chars: "ȣ"
    }, {
        base: "p",
        chars: "ⓟｐṕṗƥᵽꝑꝓꝕρ"
    }, {
        base: "q",
        chars: "ⓠｑɋꝗꝙ"
    }, {
        base: "r",
        chars: "ⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
    }, {
        base: "s",
        chars: "ⓢｓśṥŝṡšṧṣṩșşȿꞩꞅẛʂ"
    }, {
        base: "ss",
        chars: "ß"
    }, {
        base: "t",
        chars: "ⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
    }, {
        base: "th",
        chars: "þ"
    }, {
        base: "tz",
        chars: "ꜩ"
    }, {
        base: "u",
        chars: "ⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
    }, {
        base: "v",
        chars: "ⓥｖṽṿʋꝟʌ"
    }, {
        base: "vy",
        chars: "ꝡ"
    }, {
        base: "w",
        chars: "ⓦｗẁẃŵẇẅẘẉⱳ"
    }, {
        base: "x",
        chars: "ⓧｘẋẍ"
    }, {
        base: "y",
        chars: "ⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
    }, {
        base: "z",
        chars: "ⓩｚźẑżžẓẕƶȥɀⱬꝣ"
    } ], diacriticsMap = {}, i = 0; i < replacementList.length; i += 1) for (var chars = replacementList[i].chars, j = 0; j < chars.length; j += 1) diacriticsMap[chars[j]] = replacementList[i].base;
    exports.replacementList = replacementList, exports.diacriticsMap = diacriticsMap;
}, function(module, exports, __webpack_require__) {
    var fetch = __webpack_require__(33), helpers = __webpack_require__(226), cinemetaUrls = {
        movie: "https://cinemeta.strem.io/stremioget/stremio/v1/q.json?b=eyJwYXJhbXMiOltudWxsLHt9XSwibWV0aG9kIjoibmFtZXMubW92aWUiLCJpZCI6MSwianNvbnJwYyI6IjIuMCJ9",
        series: "https://cinemeta.strem.io/stremioget/stremio/v1/q.json?b=eyJwYXJhbXMiOltudWxsLHt9XSwibWV0aG9kIjoibmFtZXMuc2VyaWVzIiwiaWQiOjEsImpzb25ycGMiOiIyLjAifQ=="
    };
    function indexEntry(entry) {
        entry.year && (entry.year = parseInt(entry.year.toString().split("-")[0]));
        var n = helpers.simplifyName(entry);
        meta[n] || (meta[n] = []), meta[n].push(entry), byImdb[entry.imdb_id] = entry;
    }
    var pulled = {
        movie: !1,
        series: !1
    }, meta = {}, byImdb = {};
    module.exports = function(query, cb) {
        function match() {
            var name = helpers.simplifyName(query);
            if (!name) return cb(null, null);
            var m = (meta[name] || []).find((function(match) {
                return match.type === query.type && ("movie" !== query.type || !query.hasOwnProperty("year") || helpers.yearSimilar(query.year, match.year));
            })), res = !!m && {
                id: m.imdb_id,
                name: m.name,
                year: m.year,
                type: m.type,
                yearRange: void 0,
                image: void 0,
                starring: void 0,
                similarity: void 0
            };
            return cb(null, res);
        }
        query.type && !pulled[query.type] && cinemetaUrls[query.type] ? fetch(cinemetaUrls[query.type]).then((function(resp) {
            return resp.json();
        })).then((function(resp) {
            return resp.result;
        })).then((function(res) {
            res.forEach(indexEntry), pulled[query.type] = 1;
        })).catch((function(e) {
            console.error(e);
        })).then((function() {
            match();
        })) : process.nextTick(match);
    };
}, function(module, exports, __webpack_require__) {
    var needle = __webpack_require__(1014), helpers = __webpack_require__(226);
    module.exports = function imdbFind(task, cb, loose) {
        var shouldRetry = !loose && task.year, retry = function() {
            return shouldRetry ? imdbFind(task, cb, !0) : void cb(null, null);
        };
        !(function(searchTerm, cb) {
            var url = "https://sg.media-imdb.com/suggests/" + searchTerm.charAt(0).toLowerCase() + "/" + encodeURIComponent(searchTerm) + ".json";
            needle.get(url, (function(err, res) {
                if (!err && 200 == res.statusCode && res.body) {
                    var results = JSON.parse(res.body.toString().match(/{.*}/g)).d;
                    cb(!(!results || !results.length) && results, url);
                } else cb(!1);
            }));
        })(shouldRetry ? task.name + " " + task.year : task.name, (function(results, url) {
            results ? matchSimilar(results, (function(result) {
                result ? cb(null, result, {
                    match: url
                }) : retry();
            })) : retry();
        }));
        var matchSimilar = function(results, callback) {
            var pick, secondBest, firstResult;
            results.forEach((function(result) {
                if ((result || {}).id && result.id.match(/tt\d{7,8}/g)) {
                    var res = {
                        id: result.id,
                        name: result.l,
                        year: result.y,
                        type: result.q,
                        yearRange: result.yr,
                        image: result.i ? {
                            src: result.i[0],
                            width: result.i[1],
                            height: result.i[2]
                        } : void 0,
                        starring: result.s
                    }, movieMatch = "movie" == task.type && [ "feature", "TV special" ].indexOf(res.type) > -1, seriesMatch = "series" == task.type && [ "TV series", "TV mini-series" ].indexOf(res.type) > -1;
                    if ((!task.type || movieMatch || seriesMatch) && helpers.yearSimilar(task.year, res.year)) {
                        var similarity = helpers.nameSimilar(task.name, res.name);
                        similarity > .6 && (!pick || pick && similarity > pick.similarity) && ((pick = res).similarity = similarity), 
                        !secondBest && helpers.nameAlmostSimilar(task.name, res.name) && (secondBest = res), 
                        firstResult || task.strict || (firstResult = res);
                    }
                }
            })), secondBest && pick && (helpers.nameAlmostSimilar(task.name, pick.name) || (pick = secondBest)), 
            callback(pick || secondBest || firstResult || null);
        };
    };
}, function(module, exports, __webpack_require__) {
    var fs = __webpack_require__(2), http = __webpack_require__(11), https = __webpack_require__(22), url = __webpack_require__(7), stream = __webpack_require__(3), debug = __webpack_require__(8)("needle"), stringify = __webpack_require__(1015).build, multipart = __webpack_require__(1016), auth = __webpack_require__(1017), cookies = __webpack_require__(1018), parsers = __webpack_require__(1019), decoder = __webpack_require__(1020), version = __webpack_require__(1021).version, user_agent = "Needle/" + version;
    user_agent += " (Node.js " + process.version + "; " + process.platform + " " + process.arch + ")";
    var close_by_default = !http.Agent || http.Agent.defaultMaxSockets != 1 / 0, extend = Object.assign ? Object.assign : __webpack_require__(0)._extend, redirect_codes = [ 301, 302, 303, 307 ], decompressors = {};
    try {
        var zlib = __webpack_require__(45);
        decompressors["x-deflate"] = zlib.Inflate, decompressors.deflate = zlib.Inflate, 
        decompressors["x-gzip"] = zlib.Gunzip, decompressors.gzip = zlib.Gunzip;
        var zlib_options = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
        };
    } catch (e) {}
    var defaults = {
        boundary: "--------------------NODENEEDLEHTTPCLIENT",
        encoding: "utf8",
        parse_response: "all",
        proxy: null,
        accept: "*/*",
        user_agent: user_agent,
        open_timeout: 1e4,
        read_timeout: 0,
        follow_max: 0,
        stream_length: -1,
        decode_response: !0,
        parse_cookies: !0,
        follow_set_cookies: !1,
        follow_set_referer: !1,
        follow_keep_method: !1,
        follow_if_same_host: !1,
        follow_if_same_protocol: !1
    }, aliased = {
        options: {
            decode: "decode_response",
            parse: "parse_response",
            timeout: "open_timeout",
            follow: "follow_max"
        },
        inverted: {}
    };
    function keys_by_type(type) {
        return Object.keys(defaults).map((function(el) {
            if (null !== defaults[el] && defaults[el].constructor == type) return el;
        })).filter((function(el) {
            return el;
        }));
    }
    function is_stream(obj) {
        return "function" == typeof obj.pipe;
    }
    function Needle(method, uri, data, options, callback) {
        if ("string" != typeof uri) throw new TypeError("URL must be a string, not " + uri);
        this.method = method, this.uri = uri, this.data = data, "function" == typeof options ? (this.callback = options, 
        this.options = {}) : (this.callback = callback, this.options = options);
    }
    Object.keys(aliased.options).map((function(k) {
        var value = aliased.options[k];
        aliased.inverted[value] = k;
    })), Needle.prototype.setup = function(uri, options) {
        function get_option(key, fallback) {
            return void 0 !== options[key] ? options[key] : void 0 !== options[aliased.inverted[key]] ? options[aliased.inverted[key]] : fallback;
        }
        function check_value(expected, key) {
            var value = get_option(key), type = typeof value;
            if ("undefined" != type && type != expected) throw new TypeError(type + " received for " + key + ", but expected a " + expected);
            return type == expected ? value : defaults[key];
        }
        var config = {
            http_opts: {},
            output: options.output,
            proxy: get_option("proxy", defaults.proxy),
            parser: get_option("parse_response", defaults.parse_response),
            encoding: options.encoding || (options.multipart ? "binary" : defaults.encoding)
        };
        if (keys_by_type(Boolean).forEach((function(key) {
            config[key] = check_value("boolean", key);
        })), keys_by_type(Number).forEach((function(key) {
            config[key] = check_value("number", key);
        })), "agent pfx key passphrase cert ca ciphers rejectUnauthorized secureProtocol checkServerIdentity".split(" ").forEach((function(key) {
            void 0 !== options[key] && (config.http_opts[key] = options[key], void 0 === options.agent && (config.http_opts.agent = !1));
        })), config.headers = {
            accept: options.accept || defaults.accept,
            "user-agent": options.user_agent || defaults.user_agent
        }, options.content_type && (config.headers["content-type"] = options.content_type), 
        (options.connection || close_by_default) && (config.headers.connection = options.connection || "close"), 
        (options.compressed || defaults.compressed) && void 0 !== zlib && (config.headers["accept-encoding"] = "gzip,deflate"), 
        options.cookies && (config.headers.cookie = cookies.write(options.cookies)), -1 !== uri.indexOf("@")) {
            var parts = (url.parse(uri).auth || "").split(":");
            options.username = parts[0], options.password = parts[1];
        }
        if (options.username && (!options.auth || "auto" != options.auth && "digest" != options.auth ? config.headers.authorization = auth.basic(options.username, options.password) : config.credentials = [ options.username, options.password ]), 
        config.proxy) {
            if (-1 === config.proxy.indexOf("http") && (config.proxy = "http://" + config.proxy), 
            -1 !== config.proxy.indexOf("@")) {
                var proxy = (url.parse(config.proxy).auth || "").split(":");
                options.proxy_user = proxy[0], options.proxy_pass = proxy[1];
            }
            options.proxy_user && (config.headers["proxy-authorization"] = auth.basic(options.proxy_user, options.proxy_pass));
        }
        for (var h in options.headers) config.headers[h.toLowerCase()] = options.headers[h];
        return config;
    }, Needle.prototype.start = function() {
        var out = new stream.PassThrough({
            objectMode: !1
        }), uri = this.uri, data = this.data, method = this.method, callback = "function" == typeof this.options ? this.options : this.callback, options = this.options || {};
        -1 === uri.indexOf("http") && (uri = uri.replace(/^(\/\/)?/, "http://"));
        var body, self = this, waiting = !1, config = this.setup(uri, options), json = options.json || !1 !== options.json && "application/json" == config.headers["content-type"];
        if (data) if (options.multipart) {
            var boundary = options.boundary || defaults.boundary;
            waiting = !0, multipart.build(data, boundary, (function(err, parts) {
                if (err) throw err;
                config.headers["content-type"] = "multipart/form-data; boundary=" + boundary, next(parts);
            }));
        } else if (is_stream(data)) {
            if ("GET" == method.toUpperCase()) throw new Error("Refusing to pipe() a stream via GET. Did you mean .post?");
            config.stream_length > 0 || 0 === config.stream_length && data.path ? (waiting = !0, 
            (function(stream, given_length, cb) {
                given_length > 0 ? cb(given_length) : void 0 !== stream.end && stream.end !== 1 / 0 && void 0 !== stream.start ? cb(stream.end + 1 - (stream.start || 0)) : fs.stat(stream.path, (function(err, stat) {
                    cb(stat ? stat.size - (stream.start || 0) : null);
                }));
            })(data, config.stream_length, (function(length) {
                data.length = length, next(data);
            }))) : body = data;
        } else Buffer.isBuffer(data) ? body = data : "GET" != method.toUpperCase() || json ? (body = "string" == typeof data ? data : json ? JSON.stringify(data) : stringify(data), 
        body = new Buffer(body, config.encoding)) : uri = uri.replace(/\?.*|$/, "?" + stringify(data));
        function next(body) {
            body && (body.length && (config.headers["content-length"] = body.length), config.headers["content-type"] || (config.headers["content-type"] = json ? "application/json; charset=utf-8" : "application/x-www-form-urlencoded")), 
            !options.json || options.accept || (options.headers || {}).accept || (config.headers.accept = "application/json"), 
            self.send_request(1, method, uri, config, body, out, callback);
        }
        return waiting || next(body), out;
    }, Needle.prototype.get_request_opts = function(method, uri, config) {
        var opts = config.http_opts, proxy = config.proxy, remote = proxy ? url.parse(proxy) : url.parse(uri);
        if (opts.protocol = remote.protocol, opts.host = remote.hostname, opts.port = remote.port || ("https:" == remote.protocol ? 443 : 80), 
        opts.path = proxy ? uri : remote.pathname + (remote.search || ""), opts.method = method, 
        opts.headers = config.headers, !opts.headers.host) {
            var target = proxy ? url.parse(uri) : remote;
            opts.headers.host = target.hostname, target.port && -1 === [ 80, 443 ].indexOf(target.port) && (opts.headers.host += ":" + target.port);
        }
        return opts;
    }, Needle.prototype.should_follow = function(location, config, original) {
        if (!location) return !1;
        function matches(property) {
            return property = original[property], -1 !== location.indexOf(property);
        }
        return !(location === original || config.follow_if_same_host && !matches("host") || config.follow_if_same_protocol && !matches("protocol"));
    }, Needle.prototype.send_request = function(count, method, uri, config, post_data, out, callback) {
        var timer, returned = 0, self = this, request_opts = this.get_request_opts(method, uri, config), protocol = "https:" == request_opts.protocol ? https : http;
        function done(err, resp) {
            return returned++ > 0 ? debug("Already finished, stopping here.") : (timer && clearTimeout(timer), 
            request.removeListener("error", had_error), callback ? callback(err, resp, resp ? resp.body : void 0) : void out.emit("done", err));
        }
        function had_error(err) {
            debug("Request error", err), out.emit("err", err), done(err || new Error("Unknown error when making request."));
        }
        function set_timeout(type, milisecs) {
            milisecs <= 0 || (timer = setTimeout((function() {
                out.emit("timeout", type), request.abort();
            }), milisecs));
        }
        function on_socket_end() {
            this.writable || !1 !== this.destroyed || (this.destroy(), had_error(new Error("Remote end closed socket abruptly.")));
        }
        debug("Making request #" + count, request_opts);
        var request = protocol.request(request_opts, (function(resp) {
            var headers = resp.headers;
            if (debug("Got response", resp.statusCode, headers), out.emit("response", resp), 
            timer && clearTimeout(timer), set_timeout("read", config.read_timeout), config.parse_cookies && (headers["set-cookie"] || config.stored_cookies) && (resp.cookies = extend(config.stored_cookies || {}, cookies.read(headers["set-cookie"])), 
            debug("Got cookies", resp.cookies)), -1 !== redirect_codes.indexOf(resp.statusCode) && self.should_follow(headers.location, config, uri)) {
                if (count <= config.follow_max) return out.emit("redirect", headers.location), config.follow_keep_method || (method = "GET", 
                post_data = null, delete config.headers["content-length"]), config.follow_set_cookies && resp.cookies && (config.stored_cookies = resp.cookies, 
                config.headers.cookie = cookies.write(resp.cookies)), config.follow_set_referer && (config.headers.referer = uri), 
                config.headers.host = null, debug("Redirecting to " + url.resolve(uri, headers.location)), 
                self.send_request(++count, method, url.resolve(uri, headers.location), config, post_data, out, callback);
                if (config.follow_max > 0) return done(new Error("Max redirects reached. Possible loop in: " + headers.location));
            }
            if (401 == resp.statusCode && headers["www-authenticate"] && config.credentials && !config.headers.authorization) {
                var auth_header = auth.header(headers["www-authenticate"], config.credentials, request_opts);
                if (auth_header) return config.headers.authorization = auth_header, self.send_request(count, method, uri, config, post_data, out, callback);
            }
            out.emit("header", resp.statusCode, headers), out.emit("headers", headers);
            var pipeline = [], mime = (function(header) {
                if (!header || "" === header) return {};
                var charset = "iso-8859-1", arr = header.split(";");
                try {
                    charset = arr[1].match(/charset=(.+)/)[1];
                } catch (e) {}
                return {
                    type: arr[0],
                    charset: charset
                };
            })(headers["content-type"]), text_response = mime.type && -1 != mime.type.indexOf("text/");
            if (headers["content-encoding"] && decompressors[headers["content-encoding"]]) {
                var decompressor = decompressors[headers["content-encoding"]](zlib_options);
                decompressor.on("error", had_error), pipeline.push(decompressor);
            }
            if (config.parser && parsers[mime.type]) {
                var parser_name = config.parser.toString().toLowerCase();
                -1 != [ "xml", "json" ].indexOf(parser_name) && parsers[mime.type].name != parser_name || (out.parser = parsers[mime.type].name, 
                pipeline.push(parsers[mime.type].fn()), out._writableState.objectMode = !0, out._readableState.objectMode = !0);
            } else text_response && config.decode_response && mime.charset && !mime.charset.match(/utf-?8$/i) && pipeline.push(decoder(mime.charset));
            pipeline.push(out);
            for (var tmp = resp; pipeline.length; ) tmp = tmp.pipe(pipeline.shift());
            if (config.output && 200 == resp.statusCode) {
                var file = fs.createWriteStream(config.output);
                file.on("error", had_error), out.on("end", (function() {
                    file.writable && file.end();
                })), file.on("close", (function() {
                    delete out.file;
                })), out.on("readable", (function() {
                    for (var chunk; null !== (chunk = this.read()); ) file.writable && file.write(chunk), 
                    resp.body && resp.body.push(chunk);
                })), out.file = file;
            }
            if (callback) {
                resp.raw = [], resp.body = [], resp.bytes = 0;
                var clean_pipe = new stream.PassThrough;
                resp.pipe(clean_pipe), clean_pipe.on("readable", (function() {
                    for (var chunk; null != (chunk = this.read()); ) resp.bytes += chunk.length, resp.raw.push(chunk);
                })), config.output && 200 == resp.statusCode || out.on("readable", (function() {
                    for (var chunk; null !== (chunk = this.read()); ) "string" == typeof chunk && (chunk = new Buffer(chunk)), 
                    resp.body.push(chunk);
                })), out.on("end", (function() {
                    resp.raw = Buffer.concat(resp.raw), void 0 === resp.body[0] || Buffer.isBuffer(resp.body[0]) ? (resp.body = Buffer.concat(resp.body), 
                    (text_response || out.parser) && (resp.body = resp.body.toString())) : (resp.body = resp.body[0], 
                    out.parser && (resp.parser = out.parser)), out.file ? out.file.on("close", (function() {
                        done(null, resp, resp.body);
                    })) : done(null, resp, resp.body);
                }));
            }
        }));
        return set_timeout("open", config.open_timeout), request.on("error", had_error), 
        request.once("socket", (function(socket) {
            socket.on_socket_end || (socket.on_socket_end = on_socket_end, socket.on("end", socket.on_socket_end));
        })), post_data ? is_stream(post_data) ? post_data.pipe(request) : (request.write(post_data, config.encoding), 
        request.end()) : request.end(), out.request = request, out;
    }, exports.version = version, exports.defaults = function(obj) {
        for (var key in obj) {
            var target_key = aliased.options[key] || key;
            if (defaults.hasOwnProperty(target_key) && void 0 !== obj[key]) {
                if ("parse_response" != target_key && "proxy" != target_key) {
                    var valid_type = defaults[target_key].constructor.name;
                    if (obj[key].constructor.name != valid_type) throw new TypeError("Invalid type for " + key + ", should be " + valid_type);
                }
                defaults[target_key] = obj[key];
            }
        }
        return defaults;
    }, "head get".split(" ").forEach((function(method) {
        exports[method] = function(uri, options, callback) {
            return new Needle(method, uri, null, options, callback).start();
        };
    })), "post put patch delete".split(" ").forEach((function(method) {
        exports[method] = function(uri, data, options, callback) {
            return new Needle(method, uri, data, options, callback).start();
        };
    })), exports.request = function(method, uri, data, opts, callback) {
        return new Needle(method, uri, data, opts, callback).start();
    };
}, function(module, exports) {
    var toString = Object.prototype.toString;
    exports.build = function stringify(obj, prefix) {
        if (prefix && null == obj) return prefix + "=";
        if ("[object Array]" == toString.call(obj)) return (function(arr, prefix) {
            for (var ret = [], i = 0, len = arr.length; i < len; i++) prefix ? ret.push(stringify(arr[i], prefix + "[" + i + "]")) : ret.push(stringify(arr[i]));
            return ret.join("&");
        })(obj, prefix);
        if ("[object Object]" == toString.call(obj)) return (function(obj, prefix) {
            var ret = [];
            return Object.keys(obj).forEach((function(key) {
                ret.push(stringify(obj[key], prefix ? prefix + "[" + encodeURIComponent(key) + "]" : encodeURIComponent(key)));
            })), ret.join("&");
        })(obj, prefix);
        if ("[object Date]" == toString.call(obj)) return obj.toISOString();
        if (prefix) return prefix + "=" + encodeURIComponent(String(obj));
        if (-1 !== String(obj).indexOf("=")) return String(obj);
        throw new TypeError("Cannot build a querystring out of: " + obj);
    };
}, function(module, exports, __webpack_require__) {
    var readFile = __webpack_require__(2).readFile, basename = __webpack_require__(4).basename;
    function generate_part(name, part, boundary, callback) {
        var return_part = "--" + boundary + "\r\n";
        function append(data, filename) {
            if (data) {
                var binary = -1 == part.content_type.indexOf("text");
                return_part += '; filename="' + encodeURIComponent(filename) + '"\r\n', binary && (return_part += "Content-Transfer-Encoding: binary\r\n"), 
                return_part += "Content-Type: " + part.content_type + "\r\n\r\n", return_part += binary ? data.toString("binary") : data.toString("utf8");
            }
            callback(null, return_part + "\r\n");
        }
        if (return_part += 'Content-Disposition: form-data; name="' + name + '"', (part.file || part.buffer) && part.content_type) {
            var filename = part.filename ? part.filename : part.file ? basename(part.file) : name;
            if (part.buffer) return append(part.buffer, filename);
            readFile(part.file, (function(err, data) {
                if (err) return callback(err);
                append(data, filename);
            }));
        } else {
            if ("object" == typeof part.value) return callback(new Error("Object received for " + name + ", expected string."));
            part.content_type && (return_part += "\r\n", return_part += "Content-Type: " + part.content_type), 
            return_part += "\r\n\r\n", return_part += new Buffer(String(part.value), "utf8").toString("binary"), 
            append();
        }
    }
    function flatten(object, into, prefix) {
        for (var key in into = into || {}, object) {
            var prefix_key = prefix ? prefix + "[" + key + "]" : key, prop = object[key];
            prop && "object" == typeof prop && !(prop.buffer || prop.file || prop.content_type) ? flatten(prop, into, prefix_key) : into[prefix_key] = prop;
        }
        return into;
    }
    exports.build = function(data, boundary, callback) {
        if ("object" != typeof data || "function" == typeof data.pipe) return callback(new Error("Multipart builder expects data as key/val object."));
        var body = "", object = flatten(data), count = Object.keys(object).length;
        if (0 === count) return callback(new Error("Empty multipart body. Invalid data."));
        function done(err, section) {
            if (err) return callback(err);
            section && (body += section), --count || callback(null, body + "--" + boundary + "--");
        }
        for (var key in object) {
            var value = object[key];
            null == value ? done() : generate_part(key, value.buffer || value.file || value.content_type ? value : {
                value: value
            }, boundary, done);
        }
    };
}, function(module, exports, __webpack_require__) {
    var createHash = __webpack_require__(9).createHash;
    function md5(string) {
        return createHash("md5").update(string).digest("hex");
    }
    function basic(user, pass) {
        var str = void 0 === pass ? user : [ user, pass ].join(":");
        return "Basic " + new Buffer(str).toString("base64");
    }
    var digest = {
        parse_header: function(header) {
            for (var challenge = {}, matches = header.match(/([a-z0-9_-]+)="?([a-z0-9=\/\.@\s-]+)"?/gi), i = 0, l = matches.length; i < l; i++) {
                var parts = matches[i].split("="), key = parts.shift(), val = parts.join("=").replace(/^"/, "").replace(/"$/, "");
                challenge[key] = val;
            }
            return challenge;
        },
        update_nc: function(nc) {
            return ++nc > 99999999 && (nc = 1), nc += "", (new Array(8).join("0") + "").substr(0, 8 - nc.length) + nc;
        },
        generate: function(header, user, pass, method, path) {
            var nc = 1, cnonce = null, challenge = digest.parse_header(header), ha1 = md5(user + ":" + challenge.realm + ":" + pass), ha2 = md5(method.toUpperCase() + ":" + path), resp = [ ha1, challenge.nonce ];
            "string" == typeof challenge.qop && (cnonce = md5(Math.random().toString(36)).substr(0, 8), 
            nc = digest.update_nc(nc), resp = resp.concat(nc, cnonce)), resp = resp.concat(challenge.qop, ha2);
            var params = {
                uri: path,
                realm: challenge.realm,
                nonce: challenge.nonce,
                username: user,
                response: md5(resp.join(":"))
            };
            for (var k in challenge.qop && (params.qop = challenge.qop), challenge.opaque && (params.opaque = challenge.opaque), 
            cnonce && (params.nc = nc, params.cnonce = cnonce), header = [], params) header.push(k + '="' + params[k] + '"');
            return "Digest " + header.join(", ");
        }
    };
    module.exports = {
        header: function(header, credentials, opts) {
            var type = header.split(" ")[0], user = credentials[0], pass = credentials[1];
            return "Digest" == type ? digest.generate(header, user, pass, opts.method, opts.path) : "Basic" == type ? basic(user, pass) : void 0;
        },
        basic: basic,
        digest: digest.generate
    };
}, function(module, exports, __webpack_require__) {
    var unescape = __webpack_require__(28).unescape;
    const COOKIE_PAIR = /^([^=\s]+)\s*=\s*("?)\s*(.*)\s*\2\s*$/, EXCLUDED_CHARS = /[\x00-\x1F\x7F\x3B\x3B\s\"\,\\"%]/g;
    function encodeCookieComponent(str) {
        return str.toString().replace(EXCLUDED_CHARS, encodeURIComponent);
    }
    exports.read = function(header) {
        return header ? (header = header instanceof Array ? header : [ header ]).reduce((function(res, str) {
            var cookie = (function(str) {
                str = (function(str) {
                    var index = str.indexOf(";");
                    return -1 === index ? str : str.substr(0, index);
                })(str = (function(str) {
                    return str.trim().replace(/\x3B+$/, "");
                })(str));
                var res = COOKIE_PAIR.exec(str);
                return res && res[3] ? {
                    name: unescape(res[1]),
                    value: unescape(res[3])
                } : null;
            })(str);
            return cookie && (res[cookie.name] = cookie.value), res;
        }), {}) : {};
    }, exports.write = function(obj) {
        return Object.keys(obj).reduce((function(str, name) {
            return str + (str ? "; " : "") + encodeCookieComponent(name) + "=" + encodeCookieComponent(obj[name]);
        }), "");
    };
}, function(module, exports, __webpack_require__) {
    var Transform = __webpack_require__(3).Transform;
    function parserFactory(name, fn) {
        return {
            fn: function() {
                var chunks = [], stream = new Transform({
                    objectMode: !0
                });
                return stream._transform = function(chunk, encoding, done) {
                    chunks.push(chunk), done();
                }, stream._flush = function(done) {
                    var self = this, data = Buffer.concat(chunks);
                    try {
                        fn(data, (function(err, result) {
                            if (err) throw err;
                            self.push(result);
                        }));
                    } catch (err) {
                        self.push(data);
                    } finally {
                        done();
                    }
                }, stream;
            },
            name: name
        };
    }
    var json = parserFactory("json", (function(buffer, cb) {
        var err, data;
        try {
            data = JSON.parse(buffer);
        } catch (e) {
            err = e;
        }
        cb(err, data);
    }));
    module.exports["application/json"] = json, module.exports["text/javascript"] = json;
    try {
        var xml = parserFactory("xml", new (__webpack_require__(172).Parser)({
            explicitRoot: !0,
            explicitArray: !1
        }).parseString);
        module.exports["text/xml"] = xml, module.exports["application/xml"] = xml, module.exports["application/rdf+xml"] = xml, 
        module.exports["application/rss+xml"] = xml, module.exports["application/atom+xml"] = xml;
    } catch (e) {}
}, function(module, exports, __webpack_require__) {
    var iconv, inherits = __webpack_require__(0).inherits, stream = __webpack_require__(3), regex = /(?:charset|encoding)\s*=\s*['"]? *([\w\-]+)/i;
    function StreamDecoder(charset) {
        if (!(this instanceof StreamDecoder)) return new StreamDecoder(charset);
        stream.Transform.call(this, charset), this.charset = charset, this.parsed_chunk = !1;
    }
    inherits(StreamDecoder, stream.Transform), StreamDecoder.prototype._transform = function(chunk, encoding, done) {
        var res, found;
        if ("iso-8859-1" == this.charset && !this.parsed_chunk) {
            this.parsed_chunk = !0;
            var matches = regex.exec(chunk.toString());
            matches && (found = matches[1].toLowerCase(), this.charset = "utf-8" == found ? "utf8" : found);
        }
        try {
            res = iconv.decode(chunk, this.charset);
        } catch (e) {
            res = chunk;
        }
        this.push(res), done();
    }, module.exports = function(charset) {
        try {
            iconv || (iconv = __webpack_require__(68));
        } catch (e) {}
        return iconv ? new StreamDecoder(charset) : new stream.PassThrough;
    };
}, function(module) {
    module.exports = {
        name: "needle",
        version: "1.6.0",
        description: "The leanest and most handsome HTTP client in the Nodelands.",
        keywords: [ "http", "https", "simple", "request", "client", "multipart", "upload", "proxy", "deflate", "timeout", "charset", "iconv", "cookie", "redirect" ],
        tags: [ "http", "https", "simple", "request", "client", "multipart", "upload", "proxy", "deflate", "timeout", "charset", "iconv", "cookie", "redirect" ],
        author: "Tomás Pollak <tomas@forkhq.com>",
        repository: {
            type: "git",
            url: "https://github.com/tomas/needle.git"
        },
        dependencies: {
            debug: "^2.1.2",
            "iconv-lite": "^0.4.4"
        },
        devDependencies: {
            mocha: "",
            sinon: "",
            should: "",
            xml2js: "",
            JSONStream: "",
            q: "",
            jschardet: ""
        },
        scripts: {
            test: "mocha test"
        },
        directories: {
            lib: "./lib"
        },
        main: "./lib/needle",
        bin: {
            needle: "./bin/needle"
        },
        license: "MIT",
        engines: {
            node: ">= 0.10.x"
        }
    };
}, function(module, exports) {
    var movieKeywords = [ "1080p", "720p", "480p", "blurayrip", "brrip", "divx", "dvdrip", "hdrip", "hdtv", "tvrip", "xvid", "camrip" ], excluded = {};
    movieKeywords.forEach((function(x) {
        excluded[x] = 1;
    }));
    var SEGMENTS_SPLIT = /\.| |-|;|_/g;
    module.exports = function(filePath, options) {
        options = options || {};
        var meta = {}, segments = filePath.replace(/\\/g, "/").split("/").reverse().filter((function(x) {
            return x;
        })).slice(0, 3), firstNameSplit = segments[0].split(/\.| |_/);
        function saneSeason() {
            return meta.hasOwnProperty("season") && !isNaN(meta.season);
        }
        function saneEpisode() {
            return Array.isArray(meta.episode) && meta.episode.length;
        }
        [ segments[0], segments[1] ].filter((function(x) {
            return x;
        })).forEach((function(seg) {
            for (var matches, regex = /\b\d{4}\b/g; matches = regex.exec(seg); ) {
                var number = parseInt(matches[0], 10);
                number >= 1900 && number <= 2030 && (meta.year = number);
            }
        }));
        var pad = function(x) {
            return ("00" + x).slice(-2);
        };
        [ segments[0], segments[1] ].filter((function(x) {
            return x;
        })).forEach((function(seg) {
            var aired = seg.match(/(\d\d\d\d)(\.|-| )(\d\d)(\.|-| )(\d\d)/);
            if (aired && aired[1]) {
                var year = parseInt(aired[1], 10);
                year >= 1900 && year <= 2030 && (meta.aired = [ year, pad(aired[3]), pad(aired[5]) ].join("-"));
            }
        })), [ segments[0], segments[1] ].forEach((function(seg) {
            seg && seg.split(/\.| |_/).forEach((function(x, i) {
                var seasonMatch = x.match(/S(\d{1,2})/i);
                seasonMatch && (meta.season = parseInt(seasonMatch[1], 10));
                var episodeMatch = x.match(/E(\d{2})/gi);
                episodeMatch && (meta.episode = episodeMatch.map((function(y) {
                    return parseInt(y.slice(1), 10);
                })));
                var xStampMatch = x.match(/(\d\d?)x(\d\d?)/i);
                xStampMatch && (meta.season = parseInt(xStampMatch[1], 10), meta.episode = [ parseInt(xStampMatch[2], 10) ]);
            }));
            var fullMatch = seg && seg.replace(/\.| |;|_/g, " ").match(/^([a-zA-Z0-9,-?!'& ]*) S(\d{1,2})E(\d{2})/i);
            !meta.name && meta.season && meta.episode && fullMatch && fullMatch[1] && (meta.name = fullMatch[1]);
        }));
        var dotStampMatch = segments[0].match(/[^\da-zA-Z](\d\d?)\.(\d\d?)[^\da-zA-Z]/i);
        if (saneSeason() && saneEpisode() || !dotStampMatch || meta.year || (meta.season = parseInt(dotStampMatch[1], 10), 
        meta.episode = [ parseInt(dotStampMatch[2], 10) ]), !(saneSeason() && saneEpisode() || options.strict)) {
            var stamp = firstNameSplit.reverse().map((function(x) {
                return x.match(new RegExp("\\d\\d\\d\\d?e")) && (x = x.slice(0, -1)), x.match(new RegExp("s\\d\\d\\d\\d?")) && (x = x.slice(1)), 
                x;
            })).filter((function(x) {
                return !isNaN(x) && (3 == x.length || !meta.year && 4 == x.length);
            }))[0];
            stamp && (!meta.year || meta.year && firstNameSplit.indexOf(stamp.toString()) < firstNameSplit.indexOf(meta.year.toString())) && (meta.episode = [ parseInt(stamp.slice(-2), 10) ], 
            meta.season = parseInt(stamp.slice(0, -2), 10));
        }
        if (!saneSeason()) {
            var seasonMatch = segments.join("/").match(/season(\.| )?(\d{1,2})/gi);
            seasonMatch && (meta.season = parseInt(seasonMatch[0].match(/\d/g).join(""), 10));
            var seasonEpMatch = segments.join("/").match(/Season (\d{1,2}) - (\d{1,2})/i);
            seasonEpMatch && (meta.season = parseInt(seasonEpMatch[1], 10), meta.episode = [ parseInt(seasonEpMatch[2], 10) ]);
        }
        if (!saneEpisode()) {
            var episodeMatch = segments.join("/").match(/ep(isode)?(\.| )?(\d+)/gi);
            episodeMatch && (meta.episode = [ parseInt(episodeMatch[0].match(/\d/g).join(""), 10) ]);
        }
        var isSample, canBeMovie, diskNumberMatch = segments[0].match(/[ _.-]*(?:cd|dvd|p(?:ar)?t|dis[ck]|d)[ _.-]*(\d)[^\d]/);
        return diskNumberMatch && (meta.diskNumber = parseInt(diskNumberMatch[1], 10)), 
        (options.fromInside ? segments : [].concat(segments).reverse()).forEach((function(seg, i) {
            if (seg == segments[0]) {
                var sourcePrefix = (seg = seg.split(".").slice(0, -1).join(".")).match(/^\[(.*?)\]/);
                sourcePrefix && (seg = seg.slice(sourcePrefix[0].length));
            }
            var squareBracket = seg.indexOf("[");
            squareBracket > -1 && (seg = seg.slice(0, squareBracket));
            var segSplit = seg.split(SEGMENTS_SPLIT), nameParts = [];
            isSample = isSample || seg.match(/^sample/i) || seg.match(/^etrg/i), meta.name || (segSplit.some((function(word, i) {
                if (!(word.match("^[a-zA-Z,?!'&]*$") || !isNaN(word) && word.length <= 2 || !isNaN(word) && 0 == i) || excluded[word.toLowerCase()] || [ "ep", "episode", "season" ].indexOf(word.toLowerCase()) > -1 && !isNaN(segSplit[i + 1])) return !0;
                nameParts.push(word);
            })), (1 != nameParts.length || isNaN(nameParts[0])) && (meta.name = nameParts.filter((function(x) {
                return x && x.length > 0;
            })).map((function(x) {
                return x[0].toUpperCase() + x.slice(1).toLowerCase();
            })).join(" ")));
        })), isSample = isSample || "sample" == (segments[1] || "").toLowerCase(), canBeMovie = options.strict ? meta.hasOwnProperty("year") : meta.hasOwnProperty("year") || meta.hasOwnProperty("diskNumber") || movieKeywords.some((function(keyword) {
            return segments.join("/").toLowerCase().search(keyword) > -1;
        })), meta.name && meta.aired && (meta.type = "series"), meta.name && saneSeason() && saneEpisode() ? meta.type = "series" : meta.name && canBeMovie ? meta.type = "movie" : "movie" != meta.type && meta.name && saneSeason() ? meta.type = "extras" : meta.type = "other", 
        options.fileLength && options.fileLength < 1024 * (meta.type.match(/movie/) ? 80 : 50) * 1024 && meta.type.match(/movie|series/) && !isSample && (meta.type = "other"), 
        ("series" != meta.type || meta.aired) && (delete meta.episode, delete meta.season), 
        "series" == meta.type && meta.year && (meta.aired = meta.aired || meta.year, delete meta.year), 
        meta.type += isSample ? "-sample" : "", meta.name = meta.name && meta.name.toLowerCase().trim().replace(/\([^\(]+\)$/, "").replace(/&/g, "and").replace(/[^0-9a-z ]+/g, " ").split(" ").filter((function(r) {
            return r;
        })).join(" "), options.hints && options.hints.imdb_id && (meta.imdb_id = options.hints.imdb_id), 
        meta.tag = [], filePath.match(/1080p/i) && (meta.tag.push("hd"), meta.tag.push("1080p")), 
        filePath.match(/720p/i) && meta.tag.push("720p"), filePath.match(/480p/i) && meta.tag.push("480p"), 
        isSample && meta.tag.push("sample"), meta;
    };
}, function(module, exports, __webpack_require__) {
    const path = __webpack_require__(4), consts = __webpack_require__(79), SUPPORTED_TYPES = [ "movie", "series" ];
    function getFileVideoId(f) {
        return (f.season && f.episode ? [ f.imdb_id, f.season, f.episode ] : [ f.imdb_id ]).join(":");
    }
    module.exports = function(storage, args, cb) {
        if (!args.id.startsWith(consts.PREFIX_IMDB) || !SUPPORTED_TYPES.includes(args.type)) return cb(null, {
            streams: []
        });
        const idSplit = args.id.split(":"), itemIdLocal = consts.PREFIX_LOCAL + idSplit[0], streams = [];
        if (storage.indexes.itemId.has(itemIdLocal)) {
            const entries = storage.indexes.itemId.get(itemIdLocal);
            for (var entry of entries.values()) {
                const f = entry.files[0];
                args.type === f.type && args.id === getFileVideoId(f) && streams.push({
                    id: "file://" + f.path,
                    url: "file://" + f.path,
                    subtitle: consts.STREAM_LOCALFILE_SUBTITLE,
                    title: path.basename(f.path)
                });
            }
        }
        for (let k of storage.indexes.itemId.keys()) if (k.startsWith(consts.PREFIX_BT)) {
            const entry = storage.indexes.itemId.get(k).values().next().value;
            entry.files.forEach((function(f, i) {
                args.type === f.type && args.id === getFileVideoId(f) && streams.push({
                    title: path.basename(f.path),
                    infoHash: entry.ih,
                    fileIdx: i,
                    id: entry.ih + "/" + i,
                    sources: entry.sources
                });
            }));
        }
        cb(null, {
            streams: streams
        });
    };
}, function(module, exports, __webpack_require__) {
    const pkg = __webpack_require__(466);
    var fs = __webpack_require__(2), byline = __webpack_require__(93), promisify = __webpack_require__(0).promisify;
    module.exports = function(opts) {
        var writeStream, self = this;
        function commitEntry(key, entry) {
            self.indexes.primaryKey.set(key, entry), self.opts.entryIndexes.forEach((function(property) {
                entry[property] && (self.indexes[property].has(entry[property]) || self.indexes[property].set(entry[property], new Map), 
                self.indexes[property].get(entry[property]).set(key, entry));
            }));
        }
        function persistEntry(key, entry, cb) {
            if (!writeStream) return cb(new Error("unable to persist, no fd"));
            writeStream.write(JSON.stringify({
                id: key,
                entry: entry,
                v: pkg.version
            }) + "\n", cb);
        }
        function onInternalErr(err) {
            console.error("storage", err);
        }
        this.opts = Object.assign({
            entryIndexes: [],
            validateRecord: null
        }, opts), this.indexes = {
            primaryKey: new Map
        }, this.opts.entryIndexes.forEach((function(key) {
            self.indexes[key] = new Map;
        })), this.load = function(dbPath) {
            var truncate = !1, open = promisify(fs.open), close = promisify(fs.close);
            return open(dbPath, "a+").then((function(fd) {
                return new Promise((function(resolve) {
                    fs.createReadStream(null, {
                        fd: fd,
                        autoClose: !1
                    }).on("error", onInternalErr).pipe(byline()).on("error", onInternalErr).on("data", (function(line) {
                        var record;
                        try {
                            if ((record = JSON.parse(line.toString())).v !== pkg.version) throw "Version missmatch";
                            self.opts.validateRecord && self.opts.validateRecord(record.id, record.entry), commitEntry(record.id, record.entry);
                        } catch (e) {
                            truncate = !0;
                        }
                    })).on("finish", (function() {
                        Promise.resolve().then((function() {
                            return truncate ? close(fd).then((function() {
                                return open(dbPath, "w");
                            })) : fd;
                        })).then((function(fd) {
                            (writeStream = fs.createWriteStream(null, {
                                fd: fd,
                                autoClose: !1
                            })).on("error", onInternalErr), truncate && self.indexes.primaryKey.forEach((function(entry, key) {
                                persistEntry(key, entry);
                            }));
                        })).catch(onInternalErr).then(resolve);
                    }));
                }));
            }));
        }, this.saveEntry = function(primaryKey, entry, cb) {
            if (self.indexes.primaryKey.has(primaryKey)) return cb();
            commitEntry(primaryKey, entry), persistEntry(primaryKey, entry, cb);
        }, this.getAggrEntry = function(index, key, groups) {
            const items = this.indexes[index].get(key);
            if (!items) return null;
            let entry;
            return items.forEach((function(item) {
                if (entry) for (let group of groups) {
                    if (void 0 === entry[group]) return;
                    Array.isArray(entry[group]) || (entry[group] = [ entry[group] ]), entry[group] = entry[group].concat(item[group]);
                } else entry = Object.assign({}, item);
            })), entry;
        };
    };
}, function(module, exports, __webpack_require__) {
    const os = __webpack_require__(21), findFilesWin = __webpack_require__(1026), findFilesDarwin = __webpack_require__(1027);
    let findFiles = __webpack_require__(1028);
    "win32" === os.platform() && (findFiles = findFilesWin), "darwin" === os.platform() && (findFiles = findFilesDarwin), 
    module.exports = findFiles;
}, function(module, exports, __webpack_require__) {
    const child = __webpack_require__(31), byline = __webpack_require__(93), events = __webpack_require__(5);
    module.exports = function() {
        const ev = new events.EventEmitter;
        var propsProc = child.spawn("powershell", [ "-command", "\n[console]::InputEncoding = [console]::OutputEncoding = New-Object System.Text.UTF8Encoding\n$sql = \"SELECT System.ItemUrl FROM SystemIndex WHERE scope='file:' AND (System.Kind IS Null OR System.Kind = 'Video') AND System.FileAttributes <> ALL BITWISE 0x2 AND NOT System.ItemUrl LIKE '%/Program Files%' AND NOT System.ItemUrl LIKE '%/SteamLibrary/%' AND NOT System.ItemUrl LIKE '%/node_modules/%' AND (System.fileExtension = '.torrent' OR System.FileExtension = '.mp4' OR System.FileExtension = '.mkv' OR System.FileExtension = '.avi')\"\n$connector = New-Object -ComObject ADODB.Connection\n$rs = New-Object -ComObject ADODB.Recordset\n$connector.Open(\"Provider=Search.CollatorDSO;Extended Properties='Application=Windows';DateTimeFormat=Ticks;\")\n$rs.Open($sql, $connector)\nWhile (-Not $rs.EOF) {\n    $pos = $rs.Fields.Item(\"System.ItemUrl\").Value.IndexOf(\":\")\n    $rs.Fields.Item(\"System.ItemUrl\").Value.Substring($pos + 1)\n    $rs.MoveNext()\n}\n" ]);
        return propsProc.on("error", (function(err) {
            ev.emit("err", err);
        })), propsProc.stdout.pipe(byline()).on("data", (function(line) {
            ev.emit("file", line.toString().trim());
        })), propsProc.stderr.on("data", (function(chunk) {
            console.log("powershell search: " + chunk.toString());
        })), propsProc.on("close", (function() {
            ev.emit("finished");
        })), ev;
    };
}, function(module, exports, __webpack_require__) {
    const child = __webpack_require__(31), byline = __webpack_require__(93), events = __webpack_require__(5);
    module.exports = function() {
        const ev = new events.EventEmitter;
        var p = child.exec("mdfind '(kMDItemFSName=*.avi || kMDItemFSName=*.mp4 || kMDItemFSName=*.mkv || kMDItemFSName=*.torrent)'");
        return p.on("error", (function(err) {
            ev.emit("err", err);
        })), p.stdout.pipe(byline()).on("data", (function(line) {
            ev.emit("file", line.toString().trim());
        })), ev;
    };
}, function(module, exports, __webpack_require__) {
    const child = __webpack_require__(31), events = __webpack_require__(5), byline = __webpack_require__(93), which = __webpack_require__(1029), cmdLine = [ "-L", process.env.HOME, "-maxdepth", "7", "-not", "-path", "*/\\.*", "-not", "-path", "*/node_modules/*", "-not", "-path", "*/bin/*", "-not", "-path", "*/src/*", "-not", "-path", "*/build/*", "-not", "-path", "*/dist/*", "-type", "f", "(", "-iname", "*.torrent", "-o", "-iname", "*.mp4", "-o", "-iname", "*.mkv", "-o", "-iname", "*.avi", ")" ];
    function startIndexing() {
        var ev = this;
        const findPath = which.sync("find");
        if (findPath) {
            var p = child.spawn(findPath, cmdLine);
            p.on("error", (function(err) {
                ev.emit("err", err);
            })), p.stdout.pipe(byline()).on("data", (function(line) {
                ev.emit("file", line.toString().trim());
            })).on("close", (function() {
                ev.emit("finished");
            }));
        } else ev.emit("err", "find executable not found in PATH");
    }
    module.exports = function() {
        const ev = new events.EventEmitter;
        return setImmediate(startIndexing.bind(ev)), ev;
    };
}, function(module, exports, __webpack_require__) {
    module.exports = which, which.sync = function(cmd, opt) {
        for (var info = getPathInfo(cmd, opt = opt || {}), pathEnv = info.env, pathExt = info.ext, pathExtExe = info.extExe, found = [], i = 0, l = pathEnv.length; i < l; i++) {
            var pathPart = pathEnv[i];
            '"' === pathPart.charAt(0) && '"' === pathPart.slice(-1) && (pathPart = pathPart.slice(1, -1));
            var p = path.join(pathPart, cmd);
            !pathPart && /^\.[\\\/]/.test(cmd) && (p = cmd.slice(0, 2) + p);
            for (var j = 0, ll = pathExt.length; j < ll; j++) {
                var cur = p + pathExt[j];
                try {
                    if (isexe.sync(cur, {
                        pathExt: pathExtExe
                    })) {
                        if (!opt.all) return cur;
                        found.push(cur);
                    }
                } catch (ex) {}
            }
        }
        if (opt.all && found.length) return found;
        if (opt.nothrow) return null;
        throw getNotFoundError(cmd);
    };
    var isWindows = "win32" === process.platform || "cygwin" === process.env.OSTYPE || "msys" === process.env.OSTYPE, path = __webpack_require__(4), COLON = isWindows ? ";" : ":", isexe = __webpack_require__(1030);
    function getNotFoundError(cmd) {
        var er = new Error("not found: " + cmd);
        return er.code = "ENOENT", er;
    }
    function getPathInfo(cmd, opt) {
        var colon = opt.colon || COLON, pathEnv = opt.path || process.env.PATH || "", pathExt = [ "" ];
        pathEnv = pathEnv.split(colon);
        var pathExtExe = "";
        return isWindows && (pathEnv.unshift(process.cwd()), pathExt = (pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(colon), 
        -1 !== cmd.indexOf(".") && "" !== pathExt[0] && pathExt.unshift("")), (cmd.match(/\//) || isWindows && cmd.match(/\\/)) && (pathEnv = [ "" ]), 
        {
            env: pathEnv,
            ext: pathExt,
            extExe: pathExtExe
        };
    }
    function which(cmd, opt, cb) {
        "function" == typeof opt && (cb = opt, opt = {});
        var info = getPathInfo(cmd, opt), pathEnv = info.env, pathExt = info.ext, pathExtExe = info.extExe, found = [];
        !(function F(i, l) {
            if (i === l) return opt.all && found.length ? cb(null, found) : cb(getNotFoundError(cmd));
            var pathPart = pathEnv[i];
            '"' === pathPart.charAt(0) && '"' === pathPart.slice(-1) && (pathPart = pathPart.slice(1, -1));
            var p = path.join(pathPart, cmd);
            !pathPart && /^\.[\\\/]/.test(cmd) && (p = cmd.slice(0, 2) + p), (function E(ii, ll) {
                if (ii === ll) return F(i + 1, l);
                var ext = pathExt[ii];
                isexe(p + ext, {
                    pathExt: pathExtExe
                }, (function(er, is) {
                    if (!er && is) {
                        if (!opt.all) return cb(null, p + ext);
                        found.push(p + ext);
                    }
                    return E(ii + 1, ll);
                }));
            })(0, pathExt.length);
        })(0, pathEnv.length);
    }
}, function(module, exports, __webpack_require__) {
    var core;
    function isexe(path, options, cb) {
        if ("function" == typeof options && (cb = options, options = {}), !cb) {
            if ("function" != typeof Promise) throw new TypeError("callback not provided");
            return new Promise((function(resolve, reject) {
                isexe(path, options || {}, (function(er, is) {
                    er ? reject(er) : resolve(is);
                }));
            }));
        }
        core(path, options || {}, (function(er, is) {
            er && ("EACCES" === er.code || options && options.ignoreErrors) && (er = null, is = !1), 
            cb(er, is);
        }));
    }
    __webpack_require__(2), core = "win32" === process.platform || global.TESTING_WINDOWS ? __webpack_require__(1031) : __webpack_require__(1032), 
    module.exports = isexe, isexe.sync = function(path, options) {
        try {
            return core.sync(path, options || {});
        } catch (er) {
            if (options && options.ignoreErrors || "EACCES" === er.code) return !1;
            throw er;
        }
    };
}, function(module, exports, __webpack_require__) {
    module.exports = isexe, isexe.sync = function(path, options) {
        return checkStat(fs.statSync(path), path, options);
    };
    var fs = __webpack_require__(2);
    function checkStat(stat, path, options) {
        return !(!stat.isSymbolicLink() && !stat.isFile()) && (function(path, options) {
            var pathext = void 0 !== options.pathExt ? options.pathExt : process.env.PATHEXT;
            if (!pathext) return !0;
            if (-1 !== (pathext = pathext.split(";")).indexOf("")) return !0;
            for (var i = 0; i < pathext.length; i++) {
                var p = pathext[i].toLowerCase();
                if (p && path.substr(-p.length).toLowerCase() === p) return !0;
            }
            return !1;
        })(path, options);
    }
    function isexe(path, options, cb) {
        fs.stat(path, (function(er, stat) {
            cb(er, !er && checkStat(stat, path, options));
        }));
    }
}, function(module, exports, __webpack_require__) {
    module.exports = isexe, isexe.sync = function(path, options) {
        return checkStat(fs.statSync(path), options);
    };
    var fs = __webpack_require__(2);
    function isexe(path, options, cb) {
        fs.stat(path, (function(er, stat) {
            cb(er, !er && checkStat(stat, options));
        }));
    }
    function checkStat(stat, options) {
        return stat.isFile() && (function(stat, options) {
            var mod = stat.mode, uid = stat.uid, gid = stat.gid, myUid = void 0 !== options.uid ? options.uid : process.getuid && process.getuid(), myGid = void 0 !== options.gid ? options.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8);
            return mod & parseInt("001", 8) || mod & g && gid === myGid || mod & u && uid === myUid || mod & (u | g) && 0 === myUid;
        })(stat, options);
    }
}, function(module, exports, __webpack_require__) {
    (function(__dirname) {
        var exec = __webpack_require__(31).exec, path = __webpack_require__(4);
        function escape(s) {
            return s.replace(/"/g, '\\"');
        }
        module.exports = function(target, appName, callback) {
            var opener;
            switch ("function" == typeof appName && (callback = appName, appName = null), process.platform) {
              case "darwin":
                opener = appName ? 'open -a "' + escape(appName) + '"' : "open";
                break;

              case "win32":
                opener = appName ? 'start "" "' + escape(appName) + '"' : 'start ""';
                break;

              default:
                opener = appName ? escape(appName) : path.join(__dirname, "../vendor/xdg-open");
            }
            return process.env.SUDO_USER && (opener = "sudo -u " + process.env.SUDO_USER + " " + opener), 
            exec(opener + ' "' + escape(target) + '"', callback);
        };
    }).call(this, "/");
}, function(module, exports, __webpack_require__) {
    const store = __webpack_require__(227), getRouter = __webpack_require__(1035), getRarStream = __webpack_require__(472);
    module.exports = {
        router: getRouter,
        create: rarUrls => {
            if (!rarUrls || !Array.isArray(rarUrls)) throw Error('"rarUrls" is undefined or not an array');
            return store.set(rarUrls);
        },
        file: async (key, opts) => {
            if (!key) throw Error('Missing "key"');
            return await getRarStream({
                url: key,
                query: {
                    o: JSON.stringify(opts || {}),
                    key: key
                }
            });
        }
    };
}, function(module, exports, __webpack_require__) {
    const Router = __webpack_require__(469), bodyParser = __webpack_require__(106), getRarStream = __webpack_require__(472), getContentType = __webpack_require__(1145), store = __webpack_require__(227);
    module.exports = function() {
        const router = Router();
        return router.use(bodyParser.json()), router.post("/create", ((req, res) => {
            Array.isArray(req.body) || res.status(500).send("Cannot parse JSON data");
            const key = store.set(req.body);
            res.setHeader("Content-Length", JSON.stringify({
                key: key
            }).length + ""), res.setHeader("Content-Type", "application/json"), res.end(JSON.stringify({
                key: key
            }));
        })), router.get("/stream", (async (req, res) => {
            let rarInnerFile;
            try {
                rarInnerFile = await getRarStream(req);
            } catch (e) {
                return console.error(e), res.statusCode = 500, void res.end();
            }
            if ("HEAD" === req.method) return res.statusCode = 204, res.setHeader("Accept-Ranges", "bytes"), 
            res.setHeader("Content-Length", rarInnerFile.length + ""), res.setHeader("Content-Type", getContentType(rarInnerFile)), 
            void res.end();
            const fileSize = rarInnerFile.length, range = req.headers.range;
            let start = 0, end = fileSize - 1;
            if (res.setHeader("Accept-Ranges", "bytes"), res.setHeader("Content-Type", getContentType(rarInnerFile)), 
            Object.values(range || {}).length) {
                const parts = range.replace(/bytes=/, "").split("-");
                start = parseInt(parts[0], 10) || 0, end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1, 
                res.statusCode = 206, res.setHeader("Content-Range", `bytes ${start}-${end}/${fileSize}`);
                const chunksize = end - start + 1;
                res.setHeader("Content-Length", chunksize + "");
            } else res.statusCode = 200, res.setHeader("Content-Length", fileSize + "");
            rarInnerFile.createReadStream({
                start: start,
                end: end
            }).pipe(res);
        })), router;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var debug = __webpack_require__(8)("router:route"), flatten = __webpack_require__(470).flatten, Layer = __webpack_require__(471), methods = __webpack_require__(61), slice = Array.prototype.slice, defer = "function" == typeof setImmediate ? setImmediate : function(fn) {
        process.nextTick(fn.bind.apply(fn, arguments));
    };
    function Route(path) {
        debug("new %o", path), this.path = path, this.stack = [], this.methods = Object.create(null);
    }
    module.exports = Route, Route.prototype._handles_method = function(method) {
        if (this.methods._all) return !0;
        var name = "string" == typeof method ? method.toLowerCase() : method;
        return "head" !== name || this.methods.head || (name = "get"), Boolean(this.methods[name]);
    }, Route.prototype._methods = function() {
        var methods = Object.keys(this.methods);
        this.methods.get && !this.methods.head && methods.push("head");
        for (var i = 0; i < methods.length; i++) methods[i] = methods[i].toUpperCase();
        return methods;
    }, Route.prototype.dispatch = function(req, res, done) {
        var idx = 0, stack = this.stack, sync = 0;
        if (0 === stack.length) return done();
        var method = "string" == typeof req.method ? req.method.toLowerCase() : req.method;
        "head" !== method || this.methods.head || (method = "get"), req.route = this, (function next(err) {
            if (err && "route" === err) return done();
            if (err && "router" === err) return done(err);
            if (idx >= stack.length) return done(err);
            if (++sync > 100) return defer(next, err);
            for (var layer, match; !0 !== match && idx < stack.length; ) match = !(layer = stack[idx++]).method || layer.method === method;
            if (!0 !== match) return done(err);
            err ? layer.handle_error(err, req, res, next) : layer.handle_request(req, res, next), 
            sync = 0;
        })();
    }, Route.prototype.all = function(handler) {
        var callbacks = flatten(slice.call(arguments));
        if (0 === callbacks.length) throw new TypeError("argument handler is required");
        for (var i = 0; i < callbacks.length; i++) {
            var fn = callbacks[i];
            if ("function" != typeof fn) throw new TypeError("argument handler must be a function");
            var layer = Layer("/", {}, fn);
            layer.method = void 0, this.methods._all = !0, this.stack.push(layer);
        }
        return this;
    }, methods.forEach((function(method) {
        Route.prototype[method] = function(handler) {
            var callbacks = flatten(slice.call(arguments));
            if (0 === callbacks.length) throw new TypeError("argument handler is required");
            for (var i = 0; i < callbacks.length; i++) {
                var fn = callbacks[i];
                if ("function" != typeof fn) throw new TypeError("argument handler must be a function");
                debug("%s %s", method, this.path);
                var layer = Layer("/", {}, fn);
                layer.method = method, this.methods[method] = !0, this.stack.push(layer);
            }
            return this;
        };
    }));
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = Object.setPrototypeOf || ({
        __proto__: []
    } instanceof Array ? function(obj, proto) {
        return obj.__proto__ = proto, obj;
    } : function(obj, proto) {
        for (var prop in proto) Object.prototype.hasOwnProperty.call(obj, prop) || (obj[prop] = proto[prop]);
        return obj;
    });
}, function(module, exports, __webpack_require__) {
    "use strict";
    function _optionalChain(ops) {
        let lastAccessLHS, value = ops[0], i = 1;
        for (;i < ops.length; ) {
            const op = ops[i], fn = ops[i + 1];
            if (i += 2, ("optionalAccess" === op || "optionalCall" === op) && null == value) return;
            "access" === op || "optionalAccess" === op ? (lastAccessLHS = value, value = fn(value)) : "call" !== op && "optionalCall" !== op || (value = fn(((...args) => value.call(lastAccessLHS, ...args))), 
            lastAccessLHS = void 0);
        }
        return value;
    }
    var _class, _class2, _class3, _class4;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    var _events = __webpack_require__(5), RXX_EXTENSION = /\.R(\d\d)$|.RAR$/i, RAR_EXTENSION = /.RAR$/i, PARTXX_RAR_EXTENSION = /.PART(\d\d).RAR/i, makeRarFileBundle = (fileMedias = []) => ((fileMedias = []) => fileMedias.filter((file => file.name && file.name.match(PARTXX_RAR_EXTENSION))).length > 0)(fileMedias) ? new class {
        constructor(fileMedias = []) {
            this.fileMedias = fileMedias, this.fileMedias.length > 0 && (this.filter(), this.sort());
        }
        filter() {
            this.fileMedias = this.fileMedias.filter((file => file.name.match(PARTXX_RAR_EXTENSION)));
        }
        sort() {
            this.fileMedias.sort(((first, second) => {
                const firstMatch = first.name.match(PARTXX_RAR_EXTENSION), secondMatch = second.name.match(PARTXX_RAR_EXTENSION);
                return +(firstMatch && firstMatch[1] || 0) - +(secondMatch && secondMatch[1] || 0);
            }));
        }
        get length() {
            return this.fileMedias.length;
        }
        get fileNames() {
            return this.fileMedias.map((file => file.name));
        }
        get files() {
            return this.fileMedias;
        }
    }(fileMedias) : new class {
        constructor(fileMedias = []) {
            this.fileMedias = fileMedias, this.fileMedias.length > 0 && (this.filter(), this.sort());
        }
        filter() {
            this.fileMedias = this.fileMedias.filter((file => file.name && file.name.match(RXX_EXTENSION)));
        }
        sort() {
            this.fileMedias.sort(((first, second) => {
                if (first.name.match(RAR_EXTENSION)) return -1;
                if (second.name.match(RAR_EXTENSION)) return 1;
                {
                    const firstMatch = first.name.match(RXX_EXTENSION), secondMatch = second.name.match(RXX_EXTENSION);
                    return +(firstMatch && firstMatch[1] || 0) - +(secondMatch && secondMatch[1] || 0);
                }
            }));
        }
        get length() {
            return this.fileMedias.length;
        }
        get fileNames() {
            return this.fileMedias.map((file => file.name));
        }
        get files() {
            return this.fileMedias;
        }
    }(fileMedias), RarFileChunk = class _RarFileChunk {
        constructor(fileMedia, startOffset, endOffset) {
            this.fileMedia = fileMedia, this.startOffset = startOffset, this.endOffset = endOffset;
        }
        padEnd(endPadding) {
            return new _RarFileChunk(this.fileMedia, this.startOffset, this.endOffset - endPadding);
        }
        padStart(startPadding) {
            return new _RarFileChunk(this.fileMedia, this.startOffset + startPadding, this.endOffset);
        }
        get length() {
            return Math.max(0, this.endOffset - this.startOffset);
        }
        getStream() {
            return this.fileMedia.createReadStream({
                start: this.startOffset,
                end: this.endOffset
            });
        }
    }, _stream = __webpack_require__(3), InnerFileStream = class extends _stream.Readable {
        constructor(rarFileChunks, options) {
            super(options), this.rarFileChunks = rarFileChunks;
        }
        pushData(data) {
            this.push(data) || _optionalChain([ this, "access", _ => _.stream, "optionalAccess", _2 => _2.pause, "call", _3 => _3() ]);
        }
        get isStarted() {
            return !!this.stream;
        }
        next() {
            const chunk = this.rarFileChunks.shift();
            chunk ? (this.stream = chunk.getStream(), _optionalChain([ this, "access", _4 => _4.stream, "optionalAccess", _5 => _5.on, "call", _6 => _6("data", (data => this.pushData(data))) ]), 
            _optionalChain([ this, "access", _7 => _7.stream, "optionalAccess", _8 => _8.on, "call", _9 => _9("end", (() => this.next())) ])) : this.push(null);
        }
        _read() {
            this.isStarted ? _optionalChain([ this, "access", _10 => _10.stream, "optionalAccess", _11 => _11.resume, "call", _12 => _12() ]) : this.next();
        }
    }, streamToBuffer = async stream => new Promise(((resolve, reject) => {
        const buffers = [];
        stream.on("error", reject), stream.on("data", (data => buffers.push(data))), stream.on("end", (() => resolve(Buffer.concat(buffers))));
    })), MarkerHeaderParser = ((_class = class {
        constructor(headerBuffer) {
            this.headerBuffer = headerBuffer;
        }
        static __initStatic() {
            this.HEADER_SIZE = 11;
        }
        parse() {
            const crc = this.headerBuffer.readUInt16LE(0), type = this.headerBuffer.readUInt8(2), flags = this.headerBuffer.readUInt16LE(3);
            let size = this.headerBuffer.readUInt16LE(5);
            return 0 != (32768 & flags) && (size += this.headerBuffer.readUint32LE(7) || 0), 
            {
                crc: crc,
                type: type,
                flags: flags,
                size: size
            };
        }
    }).__initStatic(), _class), ArchiveHeaderParser = ((_class2 = class {
        constructor(buffer) {
            this.buffer = buffer;
        }
        static __initStatic2() {
            this.HEADER_SIZE = 13;
        }
        parse() {
            let vars = {
                crc: this.buffer.readUInt16LE(0),
                type: this.buffer.readUInt8(2),
                flags: this.buffer.readUInt16LE(3),
                size: this.buffer.readUInt16LE(5),
                reserved1: this.buffer.readUInt16LE(7),
                reserved2: this.buffer.readUInt32LE(9)
            };
            return Object.assign({
                hasVolumeAttributes: 0 != (1 & (parsedVars = vars).flags),
                hasComment: 0 != (2 & parsedVars.flags),
                isLocked: 0 != (4 & parsedVars.flags),
                hasSolidAttributes: 0 != (8 & parsedVars.flags),
                isNewNameScheme: 0 != (16 & parsedVars.flags),
                hasAuthInfo: 0 != (32 & parsedVars.flags),
                hasRecovery: 0 != (64 & parsedVars.flags),
                isBlockEncoded: 0 != (128 & parsedVars.flags),
                isFirstVolume: 0 != (256 & parsedVars.flags)
            }, vars);
            var parsedVars;
        }
    }).__initStatic2(), _class2), FileHeaderParser = ((_class3 = class {
        constructor(buffer) {
            _class3.prototype.__init.call(this), this.buffer = buffer;
        }
        static __initStatic3() {
            this.HEADER_SIZE = 280;
        }
        __init() {
            this.offset = 0;
        }
        handleHighFileSize(parsedVars) {
            if (parsedVars.hasHighSize) {
                const highPackSize = this.buffer.readInt32LE(this.offset);
                this.offset += 4;
                const highUnpackSize = this.buffer.readInt32LE(this.offset);
                this.offset += 4, parsedVars.size = 4294967296 * highPackSize + parsedVars.size, 
                parsedVars.unpackedSize = 4294967296 * highUnpackSize + parsedVars.unpackedSize;
            }
        }
        parseFileName(parsedVars) {
            let nameBuffer = this.buffer.subarray(this.offset, this.offset + parsedVars.nameSize);
            nameBuffer = Buffer.isBuffer(nameBuffer) ? nameBuffer : Buffer.from(nameBuffer), 
            parsedVars.name = nameBuffer.toString("utf8");
        }
        parseFlags(parsedVars) {
            return {
                continuesFromPrevious: 0 != (1 & parsedVars.flags),
                continuesInNext: 0 != (2 & parsedVars.flags),
                isEncrypted: 0 != (4 & parsedVars.flags),
                hasComment: 0 != (8 & parsedVars.flags),
                hasInfoFromPrevious: 0 != (16 & parsedVars.flags),
                hasHighSize: 0 != (256 & parsedVars.flags),
                hasSpecialName: 0 != (512 & parsedVars.flags),
                hasSalt: 0 != (1024 & parsedVars.flags),
                isOldVersion: 0 != (2048 & parsedVars.flags),
                hasExtendedTime: 0 != (4096 & parsedVars.flags)
            };
        }
        parse() {
            const crc = this.buffer.readUInt16LE(this.offset);
            this.offset += 2;
            const type = this.buffer.readUInt8(this.offset);
            this.offset += 1;
            const flags = this.buffer.readUInt16LE(this.offset);
            this.offset += 2;
            const headSize = this.buffer.readUInt16LE(this.offset);
            this.offset += 2;
            const size = this.buffer.readUInt32LE(this.offset);
            this.offset += 4;
            const unpackedSize = this.buffer.readUInt32LE(this.offset);
            this.offset += 4;
            const host = this.buffer.readUInt8(this.offset);
            this.offset += 1;
            const fileCrc = this.buffer.readUInt32LE(this.offset);
            this.offset += 4;
            const timestamp = this.buffer.readUInt32LE(this.offset);
            this.offset += 4;
            const version = this.buffer.readUInt8(this.offset);
            this.offset += 1;
            const method = this.buffer.readUInt8(this.offset);
            this.offset += 1;
            const nameSize = this.buffer.readUInt16LE(this.offset);
            this.offset += 2;
            const attributes = this.buffer.readUInt32LE(this.offset);
            this.offset += 4;
            let vars = {
                crc: crc,
                type: type,
                flags: flags,
                headSize: headSize,
                size: size,
                unpackedSize: unpackedSize,
                host: host,
                fileCrc: fileCrc,
                timestamp: timestamp,
                version: version,
                method: method,
                nameSize: nameSize,
                attributes: attributes,
                name: ""
            };
            const boolFlags = this.parseFlags(vars), header = Object.assign(vars, boolFlags);
            return this.handleHighFileSize(header), this.parseFileName(header), this.offset = 0, 
            header;
        }
    }).__initStatic3(), _class3), TerminatorHeaderParser = ((_class4 = class {
        constructor(headerBuffer) {
            this.headerBuffer = headerBuffer;
        }
        static __initStatic4() {
            this.HEADER_SIZE = 27;
        }
        parse() {
            return {
                crc: this.headerBuffer.readUInt16LE(0),
                type: this.headerBuffer.readUInt8(2),
                flags: this.headerBuffer.readUInt16LE(3),
                size: this.headerBuffer.readUInt16LE(5)
            };
        }
    }).__initStatic4(), _class4);
    function flatten(ary) {
        let ret = [];
        for (let i = 0; i < ary.length; i++) Array.isArray(ary[i]) ? ret = ret.concat(flatten(ary[i])) : ret.push(ary[i]);
        return ret;
    }
    var parseHeader = async (Parser, fileMedia, offset = 0) => {
        const stream = fileMedia.createReadStream({
            start: offset,
            end: offset + Parser.HEADER_SIZE
        });
        return new Parser(await streamToBuffer(stream)).parse();
    }, RarFilesPackage = class extends _events.EventEmitter {
        constructor(fileMedias) {
            super(), this.rarFileBundle = makeRarFileBundle(fileMedias);
        }
        async parseFile(rarFile, opts) {
            const fileChunks = [];
            let fileOffset = 0;
            const markerHead = await parseHeader(MarkerHeaderParser, rarFile);
            fileOffset += markerHead.size;
            const archiveHeader = await parseHeader(ArchiveHeaderParser, rarFile, fileOffset);
            fileOffset += archiveHeader.size;
            let countFiles = 0, retrievedFiles = 0;
            for (;fileOffset < rarFile.length - TerminatorHeaderParser.HEADER_SIZE; ) {
                let getFileChunk2 = function() {
                    if (48 !== fileHead.method) throw new Error("Decompression is not implemented");
                    return {
                        name: fileHead.name,
                        fileHead: fileHead,
                        chunk: new RarFileChunk(rarFile, fileOffset, fileOffset + fileHead.size - 1)
                    };
                };
                const fileHead = await parseHeader(FileHeaderParser, rarFile, fileOffset);
                if (116 !== fileHead.type) break;
                if (fileOffset += fileHead.headSize, opts.filter) {
                    if (opts.filter(fileHead.name, countFiles) && (fileChunks.push(getFileChunk2()), 
                    retrievedFiles++, opts.hasOwnProperty("maxFiles") && retrievedFiles === opts.maxFiles)) break;
                } else fileChunks.push(getFileChunk2());
                fileOffset += fileHead.size, countFiles++;
            }
            return this.emit("file-parsed", rarFile), fileChunks;
        }
        async parse(opts) {
            opts = opts || {}, this.emit("parsing-start", this.rarFileBundle);
            const parsedFileChunks = [], {files: files} = this.rarFileBundle;
            for (let i = 0; i < files.length; ++i) {
                const file = files[i], chunks = await this.parseFile(file, opts);
                if (!chunks.length) return this.emit("parsing-complete", []), [];
                const {fileHead: fileHead, chunk: chunk} = chunks[chunks.length - 1], chunkSize = Math.abs(chunk.endOffset - chunk.startOffset);
                let innerFileSize = fileHead.unpackedSize;
                if (parsedFileChunks.push(chunks), fileHead.continuesInNext) for (;Math.abs(innerFileSize - chunkSize) >= chunkSize; ) {
                    const nextFile = files[++i];
                    parsedFileChunks.push([ {
                        name: fileHead.name,
                        chunk: new RarFileChunk(nextFile, chunk.startOffset, chunk.endOffset)
                    } ]), this.emit("file-parsed", nextFile), innerFileSize -= chunkSize;
                }
            }
            const fileChunks = flatten(parsedFileChunks), grouped = (fn = f => f.name, object = fileChunks.reduce(((prev, curr) => {
                const groupKey = fn(curr), group = prev[groupKey] || [];
                return group.push(curr), Object.assign(prev, {
                    [groupKey]: group
                });
            }), {}), mapper = value => value.map((v => v.chunk)), Object.fromEntries(Object.entries(object).map((([key, value]) => [ key, mapper(value) ]))));
            var object, mapper, fn;
            const innerFiles = Object.entries(grouped).map((([name, chunks]) => new class {
                constructor(name, rarFileChunks) {
                    this.name = name, this.rarFileChunks = rarFileChunks, this.length = rarFileChunks.map((c => c.length)).reduce(((s, n) => s + n)), 
                    this.chunkMap = this.calculateChunkMap(rarFileChunks), this.name = name;
                }
                readToEnd() {
                    return streamToBuffer(this.createReadStream({
                        start: 0,
                        end: this.length - 1
                    }));
                }
                getChunksToStream(fileStart, fileEnd) {
                    const {index: startIndex, start: startOffset} = this.findMappedChunk(fileStart);
                    let {index: endIndex, end: endOffset} = this.findMappedChunk(fileEnd);
                    const chunksToStream = this.rarFileChunks.slice(startIndex, endIndex + 1), last = chunksToStream.length - 1;
                    chunksToStream[0] = chunksToStream[0].padStart(Math.abs(startOffset - fileStart));
                    let diff = Math.abs(endOffset - fileEnd);
                    return diff === this.rarFileChunks.length && (diff = 0), 0 !== diff && (chunksToStream[last] = chunksToStream[last].padEnd(diff)), 
                    chunksToStream;
                }
                createReadStream(interval) {
                    interval || (interval = {
                        start: 0,
                        end: this.length - 1
                    });
                    let {start: start, end: end} = interval;
                    if (start < 0 || end >= this.length) throw Error("Illegal start/end offset");
                    return new InnerFileStream(this.getChunksToStream(start, end));
                }
                calculateChunkMap(rarFileChunks) {
                    const chunkMap = [];
                    let index = 0, fileOffset = 0;
                    for (const chunk of rarFileChunks) {
                        const start = fileOffset, end = fileOffset + chunk.length;
                        fileOffset = end + 1, chunkMap.push({
                            index: index,
                            start: start,
                            end: end,
                            chunk: chunk
                        }), index++;
                    }
                    return chunkMap;
                }
                findMappedChunk(offset) {
                    let selectedMap = this.chunkMap[0];
                    for (const chunkMapping of this.chunkMap) if (offset >= chunkMapping.start && offset <= chunkMapping.end) {
                        selectedMap = chunkMapping;
                        break;
                    }
                    return selectedMap;
                }
            }(name, chunks)));
            return this.emit("parsing-complete", innerFiles), innerFiles;
        }
    }, _path = __webpack_require__(4), _fs = __webpack_require__(2);
    exports.LocalFileMedia = class {
        constructor(path) {
            this.path = path, this.name = _path.basename.call(void 0, path), this.length = _fs.statSync.call(void 0, path).size;
        }
        createReadStream(interval) {
            return _fs.createReadStream.call(void 0, this.path, interval);
        }
    }, exports.RarFilesPackage = RarFilesPackage;
}, function(module, exports, __webpack_require__) {
    const request = __webpack_require__(228), getContentLength = __webpack_require__(1144);
    module.exports = async function(url) {
        return new Promise((async (resolve, reject) => {
            let contentLength = !1;
            try {
                contentLength = await getContentLength(url);
            } catch (e) {
                return console.error(e), void reject(e);
            }
            let fileName = url.split("/").pop();
            (fileName || "").includes(".") ? (fileName = decodeURIComponent(fileName), fileName.includes("?") && (fileName = fileName.split("?")[0])) : fileName = "archive.rar", 
            resolve({
                length: parseInt(contentLength),
                name: fileName,
                createReadStream: range => {
                    const opts = {
                        url: url,
                        followRedirect: !0,
                        maxRedirects: 5,
                        strictSSL: !1
                    };
                    return Object.values(range).length && (range.start = range.start || 0, range.end = range.end || 0, 
                    (range.end > contentLength - 1 || 0 === range.end) && (range.end = ""), opts.headers = {
                        range: `bytes=${range.start}-${range.end}`
                    }), request(opts);
                }
            });
        }));
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var punycode, net = __webpack_require__(42), urlParse = __webpack_require__(7).parse, util = __webpack_require__(0), pubsuffix = __webpack_require__(474), Store = __webpack_require__(476).Store, MemoryCookieStore = __webpack_require__(1043).MemoryCookieStore, pathMatch = __webpack_require__(478).pathMatch, VERSION = __webpack_require__(1044).version;
    try {
        punycode = __webpack_require__(475);
    } catch (e) {
        console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
    }
    var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/, CONTROL_CHARS = /[\x00-\x1F]/, TERMINATORS = [ "\n", "\r", "\0" ], PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/, DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/, MONTH_TO_NUM = {
        jan: 0,
        feb: 1,
        mar: 2,
        apr: 3,
        may: 4,
        jun: 5,
        jul: 6,
        aug: 7,
        sep: 8,
        oct: 9,
        nov: 10,
        dec: 11
    }, NUM_TO_MONTH = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], NUM_TO_DAY = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];
    function parseDigits(token, minDigits, maxDigits, trailingOK) {
        for (var count = 0; count < token.length; ) {
            var c = token.charCodeAt(count);
            if (c <= 47 || c >= 58) break;
            count++;
        }
        return count < minDigits || count > maxDigits ? null : trailingOK || count == token.length ? parseInt(token.substr(0, count), 10) : null;
    }
    function parseTime(token) {
        var parts = token.split(":"), result = [ 0, 0, 0 ];
        if (3 !== parts.length) return null;
        for (var i = 0; i < 3; i++) {
            var trailingOK = 2 == i, num = parseDigits(parts[i], 1, 2, trailingOK);
            if (null === num) return null;
            result[i] = num;
        }
        return result;
    }
    function parseMonth(token) {
        token = String(token).substr(0, 3).toLowerCase();
        var num = MONTH_TO_NUM[token];
        return num >= 0 ? num : null;
    }
    function parseDate(str) {
        if (str) {
            var tokens = str.split(DATE_DELIM);
            if (tokens) {
                for (var hour = null, minute = null, second = null, dayOfMonth = null, month = null, year = null, i = 0; i < tokens.length; i++) {
                    var result, token = tokens[i].trim();
                    token.length && (null === second && (result = parseTime(token)) ? (hour = result[0], 
                    minute = result[1], second = result[2]) : null !== dayOfMonth || null === (result = parseDigits(token, 1, 2, !0)) ? null !== month || null === (result = parseMonth(token)) ? null === year && null !== (result = parseDigits(token, 2, 4, !0)) && ((year = result) >= 70 && year <= 99 ? year += 1900 : year >= 0 && year <= 69 && (year += 2e3)) : month = result : dayOfMonth = result);
                }
                if (!(null === dayOfMonth || null === month || null === year || null === second || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59)) return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
            }
        }
    }
    function formatDate(date) {
        var d = date.getUTCDate();
        d = d >= 10 ? d : "0" + d;
        var h = date.getUTCHours();
        h = h >= 10 ? h : "0" + h;
        var m = date.getUTCMinutes();
        m = m >= 10 ? m : "0" + m;
        var s = date.getUTCSeconds();
        return s = s >= 10 ? s : "0" + s, NUM_TO_DAY[date.getUTCDay()] + ", " + d + " " + NUM_TO_MONTH[date.getUTCMonth()] + " " + date.getUTCFullYear() + " " + h + ":" + m + ":" + s + " GMT";
    }
    function canonicalDomain(str) {
        return null == str ? null : (str = str.trim().replace(/^\./, ""), punycode && /[^\u0001-\u007f]/.test(str) && (str = punycode.toASCII(str)), 
        str.toLowerCase());
    }
    function domainMatch(str, domStr, canonicalize) {
        if (null == str || null == domStr) return null;
        if (!1 !== canonicalize && (str = canonicalDomain(str), domStr = canonicalDomain(domStr)), 
        str == domStr) return !0;
        if (net.isIP(str)) return !1;
        var idx = str.indexOf(domStr);
        return !(idx <= 0) && str.length === domStr.length + idx && "." === str.substr(idx - 1, 1);
    }
    function defaultPath(path) {
        if (!path || "/" !== path.substr(0, 1)) return "/";
        if ("/" === path) return path;
        var rightSlash = path.lastIndexOf("/");
        return 0 === rightSlash ? "/" : path.slice(0, rightSlash);
    }
    function parse(str, options) {
        options && "object" == typeof options || (options = {});
        var firstSemi = (str = str.trim()).indexOf(";"), c = (function(cookiePair, looseMode) {
            var cookieName, cookieValue, firstEq = (cookiePair = (function(str) {
                for (var t = 0; t < TERMINATORS.length; t++) {
                    var terminatorIdx = str.indexOf(TERMINATORS[t]);
                    -1 !== terminatorIdx && (str = str.substr(0, terminatorIdx));
                }
                return str;
            })(cookiePair)).indexOf("=");
            if (looseMode) 0 === firstEq && (firstEq = (cookiePair = cookiePair.substr(1)).indexOf("=")); else if (firstEq <= 0) return;
            if (firstEq <= 0 ? (cookieName = "", cookieValue = cookiePair.trim()) : (cookieName = cookiePair.substr(0, firstEq).trim(), 
            cookieValue = cookiePair.substr(firstEq + 1).trim()), !CONTROL_CHARS.test(cookieName) && !CONTROL_CHARS.test(cookieValue)) {
                var c = new Cookie;
                return c.key = cookieName, c.value = cookieValue, c;
            }
        })(-1 === firstSemi ? str : str.substr(0, firstSemi), !!options.loose);
        if (c) {
            if (-1 === firstSemi) return c;
            var unparsed = str.slice(firstSemi + 1).trim();
            if (0 === unparsed.length) return c;
            for (var cookie_avs = unparsed.split(";"); cookie_avs.length; ) {
                var av = cookie_avs.shift().trim();
                if (0 !== av.length) {
                    var av_key, av_value, av_sep = av.indexOf("=");
                    switch (-1 === av_sep ? (av_key = av, av_value = null) : (av_key = av.substr(0, av_sep), 
                    av_value = av.substr(av_sep + 1)), av_key = av_key.trim().toLowerCase(), av_value && (av_value = av_value.trim()), 
                    av_key) {
                      case "expires":
                        if (av_value) {
                            var exp = parseDate(av_value);
                            exp && (c.expires = exp);
                        }
                        break;

                      case "max-age":
                        if (av_value && /^-?[0-9]+$/.test(av_value)) {
                            var delta = parseInt(av_value, 10);
                            c.setMaxAge(delta);
                        }
                        break;

                      case "domain":
                        if (av_value) {
                            var domain = av_value.trim().replace(/^\./, "");
                            domain && (c.domain = domain.toLowerCase());
                        }
                        break;

                      case "path":
                        c.path = av_value && "/" === av_value[0] ? av_value : null;
                        break;

                      case "secure":
                        c.secure = !0;
                        break;

                      case "httponly":
                        c.httpOnly = !0;
                        break;

                      default:
                        c.extensions = c.extensions || [], c.extensions.push(av);
                    }
                }
            }
            return c;
        }
    }
    function jsonParse(str) {
        var obj;
        try {
            obj = JSON.parse(str);
        } catch (e) {
            return e;
        }
        return obj;
    }
    function fromJSON(str) {
        if (!str) return null;
        var obj;
        if ("string" == typeof str) {
            if ((obj = jsonParse(str)) instanceof Error) return null;
        } else obj = str;
        for (var c = new Cookie, i = 0; i < Cookie.serializableProperties.length; i++) {
            var prop = Cookie.serializableProperties[i];
            void 0 !== obj[prop] && obj[prop] !== Cookie.prototype[prop] && ("expires" === prop || "creation" === prop || "lastAccessed" === prop ? null === obj[prop] ? c[prop] = null : c[prop] = "Infinity" == obj[prop] ? "Infinity" : new Date(obj[prop]) : c[prop] = obj[prop]);
        }
        return c;
    }
    function cookieCompare(a, b) {
        var cmp = 0, aPathLen = a.path ? a.path.length : 0;
        return 0 != (cmp = (b.path ? b.path.length : 0) - aPathLen) || 0 != (cmp = (a.creation ? a.creation.getTime() : 2147483647e3) - (b.creation ? b.creation.getTime() : 2147483647e3)) ? cmp : cmp = a.creationIndex - b.creationIndex;
    }
    function getCookieContext(url) {
        if (url instanceof Object) return url;
        try {
            url = decodeURI(url);
        } catch (err) {}
        return urlParse(url);
    }
    function Cookie(options) {
        options = options || {}, Object.keys(options).forEach((function(prop) {
            Cookie.prototype.hasOwnProperty(prop) && Cookie.prototype[prop] !== options[prop] && "_" !== prop.substr(0, 1) && (this[prop] = options[prop]);
        }), this), this.creation = this.creation || new Date, Object.defineProperty(this, "creationIndex", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: ++Cookie.cookiesCreated
        });
    }
    function CookieJar(store, options) {
        "boolean" == typeof options ? options = {
            rejectPublicSuffixes: options
        } : null == options && (options = {}), null != options.rejectPublicSuffixes && (this.rejectPublicSuffixes = options.rejectPublicSuffixes), 
        null != options.looseMode && (this.enableLooseMode = options.looseMode), store || (store = new MemoryCookieStore), 
        this.store = store;
    }
    Cookie.cookiesCreated = 0, Cookie.parse = parse, Cookie.fromJSON = fromJSON, Cookie.prototype.key = "", 
    Cookie.prototype.value = "", Cookie.prototype.expires = "Infinity", Cookie.prototype.maxAge = null, 
    Cookie.prototype.domain = null, Cookie.prototype.path = null, Cookie.prototype.secure = !1, 
    Cookie.prototype.httpOnly = !1, Cookie.prototype.extensions = null, Cookie.prototype.hostOnly = null, 
    Cookie.prototype.pathIsDefault = null, Cookie.prototype.creation = null, Cookie.prototype.lastAccessed = null, 
    Object.defineProperty(Cookie.prototype, "creationIndex", {
        configurable: !0,
        enumerable: !1,
        writable: !0,
        value: 0
    }), Cookie.serializableProperties = Object.keys(Cookie.prototype).filter((function(prop) {
        return !(Cookie.prototype[prop] instanceof Function || "creationIndex" === prop || "_" === prop.substr(0, 1));
    })), Cookie.prototype.inspect = function() {
        var now = Date.now();
        return 'Cookie="' + this.toString() + "; hostOnly=" + (null != this.hostOnly ? this.hostOnly : "?") + "; aAge=" + (this.lastAccessed ? now - this.lastAccessed.getTime() + "ms" : "?") + "; cAge=" + (this.creation ? now - this.creation.getTime() + "ms" : "?") + '"';
    }, util.inspect.custom && (Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect), 
    Cookie.prototype.toJSON = function() {
        for (var obj = {}, props = Cookie.serializableProperties, i = 0; i < props.length; i++) {
            var prop = props[i];
            this[prop] !== Cookie.prototype[prop] && ("expires" === prop || "creation" === prop || "lastAccessed" === prop ? null === this[prop] ? obj[prop] = null : obj[prop] = "Infinity" == this[prop] ? "Infinity" : this[prop].toISOString() : "maxAge" === prop ? null !== this[prop] && (obj[prop] = this[prop] == 1 / 0 || this[prop] == -1 / 0 ? this[prop].toString() : this[prop]) : this[prop] !== Cookie.prototype[prop] && (obj[prop] = this[prop]));
        }
        return obj;
    }, Cookie.prototype.clone = function() {
        return fromJSON(this.toJSON());
    }, Cookie.prototype.validate = function() {
        if (!COOKIE_OCTETS.test(this.value)) return !1;
        if (!(this.expires == 1 / 0 || this.expires instanceof Date || parseDate(this.expires))) return !1;
        if (null != this.maxAge && this.maxAge <= 0) return !1;
        if (null != this.path && !PATH_VALUE.test(this.path)) return !1;
        var cdomain = this.cdomain();
        if (cdomain) {
            if (cdomain.match(/\.$/)) return !1;
            if (null == pubsuffix.getPublicSuffix(cdomain)) return !1;
        }
        return !0;
    }, Cookie.prototype.setExpires = function(exp) {
        exp instanceof Date ? this.expires = exp : this.expires = parseDate(exp) || "Infinity";
    }, Cookie.prototype.setMaxAge = function(age) {
        this.maxAge = age === 1 / 0 || age === -1 / 0 ? age.toString() : age;
    }, Cookie.prototype.cookieString = function() {
        var val = this.value;
        return null == val && (val = ""), "" === this.key ? val : this.key + "=" + val;
    }, Cookie.prototype.toString = function() {
        var str = this.cookieString();
        return this.expires != 1 / 0 && (this.expires instanceof Date ? str += "; Expires=" + formatDate(this.expires) : str += "; Expires=" + this.expires), 
        null != this.maxAge && this.maxAge != 1 / 0 && (str += "; Max-Age=" + this.maxAge), 
        this.domain && !this.hostOnly && (str += "; Domain=" + this.domain), this.path && (str += "; Path=" + this.path), 
        this.secure && (str += "; Secure"), this.httpOnly && (str += "; HttpOnly"), this.extensions && this.extensions.forEach((function(ext) {
            str += "; " + ext;
        })), str;
    }, Cookie.prototype.TTL = function(now) {
        if (null != this.maxAge) return this.maxAge <= 0 ? 0 : 1e3 * this.maxAge;
        var expires = this.expires;
        return expires != 1 / 0 ? (expires instanceof Date || (expires = parseDate(expires) || 1 / 0), 
        expires == 1 / 0 ? 1 / 0 : expires.getTime() - (now || Date.now())) : 1 / 0;
    }, Cookie.prototype.expiryTime = function(now) {
        if (null != this.maxAge) {
            var relativeTo = now || this.creation || new Date, age = this.maxAge <= 0 ? -1 / 0 : 1e3 * this.maxAge;
            return relativeTo.getTime() + age;
        }
        return this.expires == 1 / 0 ? 1 / 0 : this.expires.getTime();
    }, Cookie.prototype.expiryDate = function(now) {
        var millisec = this.expiryTime(now);
        return millisec == 1 / 0 ? new Date(2147483647e3) : millisec == -1 / 0 ? new Date(0) : new Date(millisec);
    }, Cookie.prototype.isPersistent = function() {
        return null != this.maxAge || this.expires != 1 / 0;
    }, Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function() {
        return null == this.domain ? null : canonicalDomain(this.domain);
    }, CookieJar.prototype.store = null, CookieJar.prototype.rejectPublicSuffixes = !0, 
    CookieJar.prototype.enableLooseMode = !1;
    var CAN_BE_SYNC = [];
    CAN_BE_SYNC.push("setCookie"), CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
        var err, context = getCookieContext(url);
        options instanceof Function && (cb = options, options = {});
        var host = canonicalDomain(context.hostname), loose = this.enableLooseMode;
        if (null != options.loose && (loose = options.loose), cookie instanceof Cookie || (cookie = Cookie.parse(cookie, {
            loose: loose
        })), !cookie) return err = new Error("Cookie failed to parse"), cb(options.ignoreError ? null : err);
        var now = options.now || new Date;
        if (this.rejectPublicSuffixes && cookie.domain && null == pubsuffix.getPublicSuffix(cookie.cdomain())) return err = new Error("Cookie has domain set to a public suffix"), 
        cb(options.ignoreError ? null : err);
        if (cookie.domain) {
            if (!domainMatch(host, cookie.cdomain(), !1)) return err = new Error("Cookie not in this host's domain. Cookie:" + cookie.cdomain() + " Request:" + host), 
            cb(options.ignoreError ? null : err);
            null == cookie.hostOnly && (cookie.hostOnly = !1);
        } else cookie.hostOnly = !0, cookie.domain = host;
        if (cookie.path && "/" === cookie.path[0] || (cookie.path = defaultPath(context.pathname), 
        cookie.pathIsDefault = !0), !1 === options.http && cookie.httpOnly) return err = new Error("Cookie is HttpOnly and this isn't an HTTP API"), 
        cb(options.ignoreError ? null : err);
        var store = this.store;
        store.updateCookie || (store.updateCookie = function(oldCookie, newCookie, cb) {
            this.putCookie(newCookie, cb);
        }), store.findCookie(cookie.domain, cookie.path, cookie.key, (function(err, oldCookie) {
            if (err) return cb(err);
            var next = function(err) {
                if (err) return cb(err);
                cb(null, cookie);
            };
            if (oldCookie) {
                if (!1 === options.http && oldCookie.httpOnly) return err = new Error("old Cookie is HttpOnly and this isn't an HTTP API"), 
                cb(options.ignoreError ? null : err);
                cookie.creation = oldCookie.creation, cookie.creationIndex = oldCookie.creationIndex, 
                cookie.lastAccessed = now, store.updateCookie(oldCookie, cookie, next);
            } else cookie.creation = cookie.lastAccessed = now, store.putCookie(cookie, next);
        }));
    }, CAN_BE_SYNC.push("getCookies"), CookieJar.prototype.getCookies = function(url, options, cb) {
        var context = getCookieContext(url);
        options instanceof Function && (cb = options, options = {});
        var host = canonicalDomain(context.hostname), path = context.pathname || "/", secure = options.secure;
        null != secure || !context.protocol || "https:" != context.protocol && "wss:" != context.protocol || (secure = !0);
        var http = options.http;
        null == http && (http = !0);
        var now = options.now || Date.now(), expireCheck = !1 !== options.expire, allPaths = !!options.allPaths, store = this.store;
        function matchingCookie(c) {
            if (c.hostOnly) {
                if (c.domain != host) return !1;
            } else if (!domainMatch(host, c.domain, !1)) return !1;
            return !(!allPaths && !pathMatch(path, c.path) || c.secure && !secure || c.httpOnly && !http || expireCheck && c.expiryTime() <= now && (store.removeCookie(c.domain, c.path, c.key, (function() {})), 
            1));
        }
        store.findCookies(host, allPaths ? null : path, (function(err, cookies) {
            if (err) return cb(err);
            cookies = cookies.filter(matchingCookie), !1 !== options.sort && (cookies = cookies.sort(cookieCompare));
            var now = new Date;
            cookies.forEach((function(c) {
                c.lastAccessed = now;
            })), cb(null, cookies);
        }));
    }, CAN_BE_SYNC.push("getCookieString"), CookieJar.prototype.getCookieString = function() {
        var args = Array.prototype.slice.call(arguments, 0), cb = args.pop(), next = function(err, cookies) {
            err ? cb(err) : cb(null, cookies.sort(cookieCompare).map((function(c) {
                return c.cookieString();
            })).join("; "));
        };
        args.push(next), this.getCookies.apply(this, args);
    }, CAN_BE_SYNC.push("getSetCookieStrings"), CookieJar.prototype.getSetCookieStrings = function() {
        var args = Array.prototype.slice.call(arguments, 0), cb = args.pop(), next = function(err, cookies) {
            err ? cb(err) : cb(null, cookies.map((function(c) {
                return c.toString();
            })));
        };
        args.push(next), this.getCookies.apply(this, args);
    }, CAN_BE_SYNC.push("serialize"), CookieJar.prototype.serialize = function(cb) {
        var type = this.store.constructor.name;
        "Object" === type && (type = null);
        var serialized = {
            version: "tough-cookie@" + VERSION,
            storeType: type,
            rejectPublicSuffixes: !!this.rejectPublicSuffixes,
            cookies: []
        };
        if (!this.store.getAllCookies || "function" != typeof this.store.getAllCookies) return cb(new Error("store does not support getAllCookies and cannot be serialized"));
        this.store.getAllCookies((function(err, cookies) {
            return err ? cb(err) : (serialized.cookies = cookies.map((function(cookie) {
                return delete (cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie).creationIndex, 
                cookie;
            })), cb(null, serialized));
        }));
    }, CookieJar.prototype.toJSON = function() {
        return this.serializeSync();
    }, CAN_BE_SYNC.push("_importCookies"), CookieJar.prototype._importCookies = function(serialized, cb) {
        var jar = this, cookies = serialized.cookies;
        if (!cookies || !Array.isArray(cookies)) return cb(new Error("serialized jar has no cookies array"));
        cookies = cookies.slice(), (function putNext(err) {
            if (err) return cb(err);
            if (!cookies.length) return cb(err, jar);
            var cookie;
            try {
                cookie = fromJSON(cookies.shift());
            } catch (e) {
                return cb(e);
            }
            if (null === cookie) return putNext(null);
            jar.store.putCookie(cookie, putNext);
        })();
    }, CookieJar.deserialize = function(strOrObj, store, cb) {
        var serialized;
        if (3 !== arguments.length && (cb = store, store = null), "string" == typeof strOrObj) {
            if ((serialized = jsonParse(strOrObj)) instanceof Error) return cb(serialized);
        } else serialized = strOrObj;
        var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
        jar._importCookies(serialized, (function(err) {
            if (err) return cb(err);
            cb(null, jar);
        }));
    }, CookieJar.deserializeSync = function(strOrObj, store) {
        var serialized = "string" == typeof strOrObj ? JSON.parse(strOrObj) : strOrObj, jar = new CookieJar(store, serialized.rejectPublicSuffixes);
        if (!jar.store.synchronous) throw new Error("CookieJar store is not synchronous; use async API instead.");
        return jar._importCookiesSync(serialized), jar;
    }, CookieJar.fromJSON = CookieJar.deserializeSync, CAN_BE_SYNC.push("clone"), CookieJar.prototype.clone = function(newStore, cb) {
        1 === arguments.length && (cb = newStore, newStore = null), this.serialize((function(err, serialized) {
            if (err) return cb(err);
            CookieJar.deserialize(newStore, serialized, cb);
        }));
    }, CAN_BE_SYNC.forEach((function(method) {
        CookieJar.prototype[method + "Sync"] = (function(method) {
            return function() {
                if (!this.store.synchronous) throw new Error("CookieJar store is not synchronous; use async API instead.");
                var syncErr, syncResult, args = Array.prototype.slice.call(arguments);
                if (args.push((function(err, result) {
                    syncErr = err, syncResult = result;
                })), this[method].apply(this, args), syncErr) throw syncErr;
                return syncResult;
            };
        })(method);
    })), exports.CookieJar = CookieJar, exports.Cookie = Cookie, exports.Store = Store, 
    exports.MemoryCookieStore = MemoryCookieStore, exports.parseDate = parseDate, exports.formatDate = formatDate, 
    exports.parse = parse, exports.fromJSON = fromJSON, exports.domainMatch = domainMatch, 
    exports.defaultPath = defaultPath, exports.pathMatch = pathMatch, exports.getPublicSuffix = pubsuffix.getPublicSuffix, 
    exports.cookieCompare = cookieCompare, exports.permuteDomain = __webpack_require__(477).permuteDomain, 
    exports.permutePath = function(path) {
        if ("/" === path) return [ "/" ];
        path.lastIndexOf("/") === path.length - 1 && (path = path.substr(0, path.length - 1));
        for (var permutations = [ path ]; path.length > 1; ) {
            var lindex = path.lastIndexOf("/");
            if (0 === lindex) break;
            path = path.substr(0, lindex), permutations.push(path);
        }
        return permutations.push("/"), permutations;
    }, exports.canonicalDomain = canonicalDomain;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Punycode = __webpack_require__(475), internals = {};
    internals.rules = __webpack_require__(1042).map((function(rule) {
        return {
            rule: rule,
            suffix: rule.replace(/^(\*\.|\!)/, ""),
            punySuffix: -1,
            wildcard: "*" === rule.charAt(0),
            exception: "!" === rule.charAt(0)
        };
    })), internals.endsWith = function(str, suffix) {
        return -1 !== str.indexOf(suffix, str.length - suffix.length);
    }, internals.findRule = function(domain) {
        var punyDomain = Punycode.toASCII(domain);
        return internals.rules.reduce((function(memo, rule) {
            return -1 === rule.punySuffix && (rule.punySuffix = Punycode.toASCII(rule.suffix)), 
            internals.endsWith(punyDomain, "." + rule.punySuffix) || punyDomain === rule.punySuffix ? rule : memo;
        }), null);
    }, exports.errorCodes = {
        DOMAIN_TOO_SHORT: "Domain name too short.",
        DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
        LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
        LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
        LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
        LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
        LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
    }, internals.validate = function(input) {
        var ascii = Punycode.toASCII(input);
        if (ascii.length < 1) return "DOMAIN_TOO_SHORT";
        if (ascii.length > 255) return "DOMAIN_TOO_LONG";
        for (var label, labels = ascii.split("."), i = 0; i < labels.length; ++i) {
            if (!(label = labels[i]).length) return "LABEL_TOO_SHORT";
            if (label.length > 63) return "LABEL_TOO_LONG";
            if ("-" === label.charAt(0)) return "LABEL_STARTS_WITH_DASH";
            if ("-" === label.charAt(label.length - 1)) return "LABEL_ENDS_WITH_DASH";
            if (!/^[a-z0-9\-]+$/.test(label)) return "LABEL_INVALID_CHARS";
        }
    }, exports.parse = function(input) {
        if ("string" != typeof input) throw new TypeError("Domain name must be a string.");
        var domain = input.slice(0).toLowerCase();
        "." === domain.charAt(domain.length - 1) && (domain = domain.slice(0, domain.length - 1));
        var error = internals.validate(domain);
        if (error) return {
            input: input,
            error: {
                message: exports.errorCodes[error],
                code: error
            }
        };
        var parsed = {
            input: input,
            tld: null,
            sld: null,
            domain: null,
            subdomain: null,
            listed: !1
        }, domainParts = domain.split(".");
        if ("local" === domainParts[domainParts.length - 1]) return parsed;
        var handlePunycode = function() {
            return /xn--/.test(domain) ? (parsed.domain && (parsed.domain = Punycode.toASCII(parsed.domain)), 
            parsed.subdomain && (parsed.subdomain = Punycode.toASCII(parsed.subdomain)), parsed) : parsed;
        }, rule = internals.findRule(domain);
        if (!rule) return domainParts.length < 2 ? parsed : (parsed.tld = domainParts.pop(), 
        parsed.sld = domainParts.pop(), parsed.domain = [ parsed.sld, parsed.tld ].join("."), 
        domainParts.length && (parsed.subdomain = domainParts.pop()), handlePunycode());
        parsed.listed = !0;
        var tldParts = rule.suffix.split("."), privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
        return rule.exception && privateParts.push(tldParts.shift()), parsed.tld = tldParts.join("."), 
        privateParts.length ? (rule.wildcard && (tldParts.unshift(privateParts.pop()), parsed.tld = tldParts.join(".")), 
        privateParts.length ? (parsed.sld = privateParts.pop(), parsed.domain = [ parsed.sld, parsed.tld ].join("."), 
        privateParts.length && (parsed.subdomain = privateParts.join(".")), handlePunycode()) : handlePunycode()) : handlePunycode();
    }, exports.get = function(domain) {
        return domain && exports.parse(domain).domain || null;
    }, exports.isValid = function(domain) {
        var parsed = exports.parse(domain);
        return Boolean(parsed.domain && parsed.listed);
    };
}, function(module) {
    module.exports = [ "ac", "com.ac", "edu.ac", "gov.ac", "net.ac", "mil.ac", "org.ac", "ad", "nom.ad", "ae", "co.ae", "net.ae", "org.ae", "sch.ae", "ac.ae", "gov.ae", "mil.ae", "aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "aircraft.aero", "airline.aero", "airport.aero", "air-surveillance.aero", "airtraffic.aero", "air-traffic-control.aero", "ambulance.aero", "amusement.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "gov.af", "com.af", "org.af", "net.af", "edu.af", "ag", "com.ag", "org.ag", "net.ag", "co.ag", "nom.ag", "ai", "off.ai", "com.ai", "net.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "ed.ao", "gv.ao", "og.ao", "co.ao", "pb.ao", "it.ao", "aq", "ar", "com.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "net.ar", "org.ar", "tur.ar", "arpa", "e164.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "co.at", "gv.at", "or.at", "au", "com.au", "net.au", "org.au", "edu.au", "gov.au", "asn.au", "id.au", "info.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "aw", "com.aw", "ax", "az", "com.az", "net.az", "int.az", "gov.az", "org.az", "edu.az", "info.az", "pp.az", "mil.az", "name.az", "pro.az", "biz.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "bh", "com.bh", "edu.bh", "net.bh", "org.bh", "gov.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "asso.bj", "barreau.bj", "gouv.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "org.bo", "net.bo", "mil.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "politica.bo", "profesional.bo", "plurinacional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bhz.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "ecn.br", "eco.br", "edu.br", "emp.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "lel.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "net.bs", "org.bs", "edu.bs", "gov.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "com.bz", "net.bz", "org.bz", "edu.bz", "gov.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "org.ci", "or.ci", "com.ci", "co.ci", "edu.ci", "ed.ci", "ac.ci", "net.ci", "go.ci", "asso.ci", "aéroport.ci", "int.ci", "presse.ci", "md.ci", "gouv.ci", "*.ck", "!www.ck", "cl", "gov.cl", "gob.cl", "co.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "net.cn", "org.cn", "mil.cn", "公司.cn", "网络.cn", "網絡.cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gz.cn", "gx.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "hk.cn", "mo.cn", "tw.cn", "co", "arts.co", "com.co", "edu.co", "firm.co", "gov.co", "info.co", "int.co", "mil.co", "net.co", "nom.co", "org.co", "rec.co", "web.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "org.cu", "net.cu", "gov.cu", "inf.cu", "cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "name.cy", "net.cy", "org.cy", "parliament.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "com.dm", "net.dm", "org.dm", "edu.dm", "gov.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "com.dz", "org.dz", "net.dz", "gov.dz", "edu.dz", "asso.dz", "pol.dz", "art.dz", "ec", "com.ec", "info.ec", "net.ec", "fin.ec", "k12.ec", "med.ec", "pro.ec", "org.ec", "edu.ec", "gov.ec", "gob.ec", "mil.ec", "edu", "ee", "edu.ee", "gov.ee", "riik.ee", "lib.ee", "med.ee", "com.ee", "pri.ee", "aip.ee", "org.ee", "fie.ee", "eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "*.er", "es", "com.es", "nom.es", "org.es", "gob.es", "edu.es", "et", "com.et", "gov.et", "org.et", "edu.et", "biz.et", "name.et", "info.et", "net.et", "eu", "fi", "aland.fi", "*.fj", "*.fk", "fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "aeroport.fr", "avocat.fr", "avoues.fr", "cci.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "geometre-expert.fr", "greta.fr", "huissier-justice.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "ga", "gb", "gd", "ge", "com.ge", "edu.ge", "gov.ge", "org.ge", "mil.ge", "net.ge", "pvt.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "org.gh", "mil.gh", "gi", "com.gi", "ltd.gi", "gov.gi", "mod.gi", "edu.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "org.gn", "net.gn", "gov", "gp", "com.gp", "net.gp", "mobi.gp", "edu.gp", "org.gp", "asso.gp", "gq", "gr", "com.gr", "edu.gr", "net.gr", "org.gr", "gov.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", "公司.hk", "教育.hk", "敎育.hk", "政府.hk", "個人.hk", "个人.hk", "箇人.hk", "網络.hk", "网络.hk", "组織.hk", "網絡.hk", "网絡.hk", "组织.hk", "組織.hk", "組织.hk", "hm", "hn", "com.hn", "edu.hn", "org.hn", "net.hn", "mil.hn", "gob.hn", "hr", "iz.hr", "from.hr", "name.hr", "com.hr", "ht", "com.ht", "shop.ht", "firm.ht", "info.ht", "adult.ht", "net.ht", "pro.ht", "org.ht", "med.ht", "art.ht", "coop.ht", "pol.ht", "asso.ht", "edu.ht", "rel.ht", "gouv.ht", "perso.ht", "hu", "co.hu", "info.hu", "org.hu", "priv.hu", "sport.hu", "tm.hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "reklam.hu", "sex.hu", "shop.hu", "suli.hu", "szex.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "im", "ac.im", "co.im", "com.im", "ltd.co.im", "net.im", "org.im", "plc.co.im", "tt.im", "tv.im", "in", "co.in", "firm.in", "net.in", "org.in", "gen.in", "ind.in", "nic.in", "ac.in", "edu.in", "res.in", "gov.in", "mil.in", "info", "int", "eu.int", "io", "com.io", "iq", "gov.iq", "edu.iq", "mil.iq", "com.iq", "org.iq", "net.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", "ایران.ir", "ايران.ir", "is", "net.is", "com.is", "edu.is", "gov.is", "org.is", "int.is", "it", "gov.it", "edu.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-süd-tirol.it", "trentin-sudtirol.it", "trentin-südtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-süd-tirol.it", "trentino-sudtirol.it", "trentino-südtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentino.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosüd-tirol.it", "trentinosudtirol.it", "trentinosüdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsüd-tirol.it", "trentinsudtirol.it", "trentinsüdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "vallée-aoste.it", "vallee-d-aoste.it", "vallée-d-aoste.it", "valleeaoste.it", "valléeaoste.it", "valleedaoste.it", "valléedaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan-sudtirol.it", "balsan-südtirol.it", "balsan-suedtirol.it", "balsan.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano-altoadige.it", "bolzano.it", "bozen-sudtirol.it", "bozen-südtirol.it", "bozen-suedtirol.it", "bozen.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan-sudtirol.it", "bulsan-südtirol.it", "bulsan-suedtirol.it", "bulsan.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forlì.it", "cesenaforli.it", "cesenaforlì.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forlì-cesena.it", "forlicesena.it", "forlìcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza-brianza.it", "monza-e-della-brianza.it", "monza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "suedtirol.it", "südtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "com.jo", "org.jo", "net.jo", "edu.jo", "sch.jo", "gov.jo", "mil.jo", "name.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", "栃木.jp", "愛知.jp", "愛媛.jp", "兵庫.jp", "熊本.jp", "茨城.jp", "北海道.jp", "千葉.jp", "和歌山.jp", "長崎.jp", "長野.jp", "新潟.jp", "青森.jp", "静岡.jp", "東京.jp", "石川.jp", "埼玉.jp", "三重.jp", "京都.jp", "佐賀.jp", "大分.jp", "大阪.jp", "奈良.jp", "宮城.jp", "宮崎.jp", "富山.jp", "山口.jp", "山形.jp", "山梨.jp", "岩手.jp", "岐阜.jp", "岡山.jp", "島根.jp", "広島.jp", "徳島.jp", "沖縄.jp", "滋賀.jp", "神奈川.jp", "福井.jp", "福岡.jp", "福島.jp", "秋田.jp", "群馬.jp", "香川.jp", "高知.jp", "鳥取.jp", "鹿児島.jp", "*.kawasaki.jp", "*.kitakyushu.jp", "*.kobe.jp", "*.nagoya.jp", "*.sapporo.jp", "*.sendai.jp", "*.yokohama.jp", "!city.kawasaki.jp", "!city.kitakyushu.jp", "!city.kobe.jp", "!city.nagoya.jp", "!city.sapporo.jp", "!city.sendai.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "org.kg", "net.kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "*.kh", "ki", "edu.ki", "biz.ki", "net.ki", "org.ki", "gov.ki", "info.ki", "com.ki", "km", "org.km", "nom.km", "gov.km", "prd.km", "tm.km", "edu.km", "mil.km", "ass.km", "com.km", "coop.km", "asso.km", "presse.km", "medecin.km", "notaires.km", "pharmaciens.km", "veterinaire.km", "gouv.km", "kn", "net.kn", "org.kn", "edu.kn", "gov.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "edu.ky", "gov.ky", "com.ky", "org.ky", "net.ky", "kz", "org.kz", "edu.kz", "net.kz", "gov.kz", "mil.kz", "com.kz", "la", "int.la", "net.la", "info.la", "edu.la", "gov.la", "per.la", "com.la", "org.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "com.lc", "net.lc", "co.lc", "org.lc", "edu.lc", "gov.lc", "li", "lk", "gov.lk", "sch.lk", "net.lk", "int.lk", "com.lk", "org.lk", "edu.lk", "ngo.lk", "soc.lk", "web.lk", "ltd.lk", "assn.lk", "grp.lk", "hotel.lk", "ac.lk", "lr", "com.lr", "edu.lr", "gov.lr", "org.lr", "net.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "com.lv", "edu.lv", "gov.lv", "org.lv", "mil.lv", "id.lv", "net.lv", "asn.lv", "conf.lv", "ly", "com.ly", "net.ly", "gov.ly", "plc.ly", "edu.ly", "sch.ly", "med.ly", "org.ly", "id.ly", "ma", "co.ma", "net.ma", "gov.ma", "org.ma", "ac.ma", "press.ma", "mc", "tm.mc", "asso.mc", "md", "me", "co.me", "net.me", "org.me", "edu.me", "ac.me", "gov.me", "its.me", "priv.me", "mg", "org.mg", "nom.mg", "gov.mg", "prd.mg", "tm.mg", "edu.mg", "mil.mg", "com.mg", "co.mg", "mh", "mil", "mk", "com.mk", "org.mk", "net.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "gov.mn", "edu.mn", "org.mn", "mo", "com.mo", "net.mo", "org.mo", "edu.mo", "gov.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "com.mu", "net.mu", "org.mu", "gov.mu", "ac.mu", "co.mu", "or.mu", "museum", "academy.museum", "agriculture.museum", "air.museum", "airguard.museum", "alabama.museum", "alaska.museum", "amber.museum", "ambulance.museum", "american.museum", "americana.museum", "americanantiques.museum", "americanart.museum", "amsterdam.museum", "and.museum", "annefrank.museum", "anthro.museum", "anthropology.museum", "antiques.museum", "aquarium.museum", "arboretum.museum", "archaeological.museum", "archaeology.museum", "architecture.museum", "art.museum", "artanddesign.museum", "artcenter.museum", "artdeco.museum", "arteducation.museum", "artgallery.museum", "arts.museum", "artsandcrafts.museum", "asmatart.museum", "assassination.museum", "assisi.museum", "association.museum", "astronomy.museum", "atlanta.museum", "austin.museum", "australia.museum", "automotive.museum", "aviation.museum", "axis.museum", "badajoz.museum", "baghdad.museum", "bahn.museum", "bale.museum", "baltimore.museum", "barcelona.museum", "baseball.museum", "basel.museum", "baths.museum", "bauern.museum", "beauxarts.museum", "beeldengeluid.museum", "bellevue.museum", "bergbau.museum", "berkeley.museum", "berlin.museum", "bern.museum", "bible.museum", "bilbao.museum", "bill.museum", "birdart.museum", "birthplace.museum", "bonn.museum", "boston.museum", "botanical.museum", "botanicalgarden.museum", "botanicgarden.museum", "botany.museum", "brandywinevalley.museum", "brasil.museum", "bristol.museum", "british.museum", "britishcolumbia.museum", "broadcast.museum", "brunel.museum", "brussel.museum", "brussels.museum", "bruxelles.museum", "building.museum", "burghof.museum", "bus.museum", "bushey.museum", "cadaques.museum", "california.museum", "cambridge.museum", "can.museum", "canada.museum", "capebreton.museum", "carrier.museum", "cartoonart.museum", "casadelamoneda.museum", "castle.museum", "castres.museum", "celtic.museum", "center.museum", "chattanooga.museum", "cheltenham.museum", "chesapeakebay.museum", "chicago.museum", "children.museum", "childrens.museum", "childrensgarden.museum", "chiropractic.museum", "chocolate.museum", "christiansburg.museum", "cincinnati.museum", "cinema.museum", "circus.museum", "civilisation.museum", "civilization.museum", "civilwar.museum", "clinton.museum", "clock.museum", "coal.museum", "coastaldefence.museum", "cody.museum", "coldwar.museum", "collection.museum", "colonialwilliamsburg.museum", "coloradoplateau.museum", "columbia.museum", "columbus.museum", "communication.museum", "communications.museum", "community.museum", "computer.museum", "computerhistory.museum", "comunicações.museum", "contemporary.museum", "contemporaryart.museum", "convent.museum", "copenhagen.museum", "corporation.museum", "correios-e-telecomunicações.museum", "corvette.museum", "costume.museum", "countryestate.museum", "county.museum", "crafts.museum", "cranbrook.museum", "creation.museum", "cultural.museum", "culturalcenter.museum", "culture.museum", "cyber.museum", "cymru.museum", "dali.museum", "dallas.museum", "database.museum", "ddr.museum", "decorativearts.museum", "delaware.museum", "delmenhorst.museum", "denmark.museum", "depot.museum", "design.museum", "detroit.museum", "dinosaur.museum", "discovery.museum", "dolls.museum", "donostia.museum", "durham.museum", "eastafrica.museum", "eastcoast.museum", "education.museum", "educational.museum", "egyptian.museum", "eisenbahn.museum", "elburg.museum", "elvendrell.museum", "embroidery.museum", "encyclopedic.museum", "england.museum", "entomology.museum", "environment.museum", "environmentalconservation.museum", "epilepsy.museum", "essex.museum", "estate.museum", "ethnology.museum", "exeter.museum", "exhibition.museum", "family.museum", "farm.museum", "farmequipment.museum", "farmers.museum", "farmstead.museum", "field.museum", "figueres.museum", "filatelia.museum", "film.museum", "fineart.museum", "finearts.museum", "finland.museum", "flanders.museum", "florida.museum", "force.museum", "fortmissoula.museum", "fortworth.museum", "foundation.museum", "francaise.museum", "frankfurt.museum", "franziskaner.museum", "freemasonry.museum", "freiburg.museum", "fribourg.museum", "frog.museum", "fundacio.museum", "furniture.museum", "gallery.museum", "garden.museum", "gateway.museum", "geelvinck.museum", "gemological.museum", "geology.museum", "georgia.museum", "giessen.museum", "glas.museum", "glass.museum", "gorge.museum", "grandrapids.museum", "graz.museum", "guernsey.museum", "halloffame.museum", "hamburg.museum", "handson.museum", "harvestcelebration.museum", "hawaii.museum", "health.museum", "heimatunduhren.museum", "hellas.museum", "helsinki.museum", "hembygdsforbund.museum", "heritage.museum", "histoire.museum", "historical.museum", "historicalsociety.museum", "historichouses.museum", "historisch.museum", "historisches.museum", "history.museum", "historyofscience.museum", "horology.museum", "house.museum", "humanities.museum", "illustration.museum", "imageandsound.museum", "indian.museum", "indiana.museum", "indianapolis.museum", "indianmarket.museum", "intelligence.museum", "interactive.museum", "iraq.museum", "iron.museum", "isleofman.museum", "jamison.museum", "jefferson.museum", "jerusalem.museum", "jewelry.museum", "jewish.museum", "jewishart.museum", "jfk.museum", "journalism.museum", "judaica.museum", "judygarland.museum", "juedisches.museum", "juif.museum", "karate.museum", "karikatur.museum", "kids.museum", "koebenhavn.museum", "koeln.museum", "kunst.museum", "kunstsammlung.museum", "kunstunddesign.museum", "labor.museum", "labour.museum", "lajolla.museum", "lancashire.museum", "landes.museum", "lans.museum", "läns.museum", "larsson.museum", "lewismiller.museum", "lincoln.museum", "linz.museum", "living.museum", "livinghistory.museum", "localhistory.museum", "london.museum", "losangeles.museum", "louvre.museum", "loyalist.museum", "lucerne.museum", "luxembourg.museum", "luzern.museum", "mad.museum", "madrid.museum", "mallorca.museum", "manchester.museum", "mansion.museum", "mansions.museum", "manx.museum", "marburg.museum", "maritime.museum", "maritimo.museum", "maryland.museum", "marylhurst.museum", "media.museum", "medical.museum", "medizinhistorisches.museum", "meeres.museum", "memorial.museum", "mesaverde.museum", "michigan.museum", "midatlantic.museum", "military.museum", "mill.museum", "miners.museum", "mining.museum", "minnesota.museum", "missile.museum", "missoula.museum", "modern.museum", "moma.museum", "money.museum", "monmouth.museum", "monticello.museum", "montreal.museum", "moscow.museum", "motorcycle.museum", "muenchen.museum", "muenster.museum", "mulhouse.museum", "muncie.museum", "museet.museum", "museumcenter.museum", "museumvereniging.museum", "music.museum", "national.museum", "nationalfirearms.museum", "nationalheritage.museum", "nativeamerican.museum", "naturalhistory.museum", "naturalhistorymuseum.museum", "naturalsciences.museum", "nature.museum", "naturhistorisches.museum", "natuurwetenschappen.museum", "naumburg.museum", "naval.museum", "nebraska.museum", "neues.museum", "newhampshire.museum", "newjersey.museum", "newmexico.museum", "newport.museum", "newspaper.museum", "newyork.museum", "niepce.museum", "norfolk.museum", "north.museum", "nrw.museum", "nuernberg.museum", "nuremberg.museum", "nyc.museum", "nyny.museum", "oceanographic.museum", "oceanographique.museum", "omaha.museum", "online.museum", "ontario.museum", "openair.museum", "oregon.museum", "oregontrail.museum", "otago.museum", "oxford.museum", "pacific.museum", "paderborn.museum", "palace.museum", "paleo.museum", "palmsprings.museum", "panama.museum", "paris.museum", "pasadena.museum", "pharmacy.museum", "philadelphia.museum", "philadelphiaarea.museum", "philately.museum", "phoenix.museum", "photography.museum", "pilots.museum", "pittsburgh.museum", "planetarium.museum", "plantation.museum", "plants.museum", "plaza.museum", "portal.museum", "portland.museum", "portlligat.museum", "posts-and-telecommunications.museum", "preservation.museum", "presidio.museum", "press.museum", "project.museum", "public.museum", "pubol.museum", "quebec.museum", "railroad.museum", "railway.museum", "research.museum", "resistance.museum", "riodejaneiro.museum", "rochester.museum", "rockart.museum", "roma.museum", "russia.museum", "saintlouis.museum", "salem.museum", "salvadordali.museum", "salzburg.museum", "sandiego.museum", "sanfrancisco.museum", "santabarbara.museum", "santacruz.museum", "santafe.museum", "saskatchewan.museum", "satx.museum", "savannahga.museum", "schlesisches.museum", "schoenbrunn.museum", "schokoladen.museum", "school.museum", "schweiz.museum", "science.museum", "scienceandhistory.museum", "scienceandindustry.museum", "sciencecenter.museum", "sciencecenters.museum", "science-fiction.museum", "sciencehistory.museum", "sciences.museum", "sciencesnaturelles.museum", "scotland.museum", "seaport.museum", "settlement.museum", "settlers.museum", "shell.museum", "sherbrooke.museum", "sibenik.museum", "silk.museum", "ski.museum", "skole.museum", "society.museum", "sologne.museum", "soundandvision.museum", "southcarolina.museum", "southwest.museum", "space.museum", "spy.museum", "square.museum", "stadt.museum", "stalbans.museum", "starnberg.museum", "state.museum", "stateofdelaware.museum", "station.museum", "steam.museum", "steiermark.museum", "stjohn.museum", "stockholm.museum", "stpetersburg.museum", "stuttgart.museum", "suisse.museum", "surgeonshall.museum", "surrey.museum", "svizzera.museum", "sweden.museum", "sydney.museum", "tank.museum", "tcm.museum", "technology.museum", "telekommunikation.museum", "television.museum", "texas.museum", "textile.museum", "theater.museum", "time.museum", "timekeeping.museum", "topology.museum", "torino.museum", "touch.museum", "town.museum", "transport.museum", "tree.museum", "trolley.museum", "trust.museum", "trustee.museum", "uhren.museum", "ulm.museum", "undersea.museum", "university.museum", "usa.museum", "usantiques.museum", "usarts.museum", "uscountryestate.museum", "usculture.museum", "usdecorativearts.museum", "usgarden.museum", "ushistory.museum", "ushuaia.museum", "uslivinghistory.museum", "utah.museum", "uvic.museum", "valley.museum", "vantaa.museum", "versailles.museum", "viking.museum", "village.museum", "virginia.museum", "virtual.museum", "virtuel.museum", "vlaanderen.museum", "volkenkunde.museum", "wales.museum", "wallonie.museum", "war.museum", "washingtondc.museum", "watchandclock.museum", "watch-and-clock.museum", "western.museum", "westfalen.museum", "whaling.museum", "wildlife.museum", "williamsburg.museum", "windmill.museum", "workshop.museum", "york.museum", "yorkshire.museum", "yosemite.museum", "youth.museum", "zoological.museum", "zoology.museum", "ירושלים.museum", "иком.museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "museum.mw", "net.mw", "org.mw", "mx", "com.mx", "org.mx", "gob.mx", "edu.mx", "net.mx", "my", "com.my", "net.my", "org.my", "gov.my", "edu.my", "mil.my", "name.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "info.na", "pro.na", "name.na", "school.na", "or.na", "dr.na", "us.na", "mx.na", "ca.na", "in.na", "cc.na", "tv.na", "ws.na", "mobi.na", "co.na", "com.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "com.nf", "net.nf", "per.nf", "rec.nf", "web.nf", "arts.nf", "firm.nf", "info.nf", "other.nf", "store.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "vgs.no", "fylkesbibl.no", "folkebibl.no", "museum.no", "idrett.no", "priv.no", "mil.no", "stat.no", "dep.no", "kommune.no", "herad.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "åkrehamn.no", "algard.no", "ålgård.no", "arna.no", "brumunddal.no", "bryne.no", "bronnoysund.no", "brønnøysund.no", "drobak.no", "drøbak.no", "egersund.no", "fetsund.no", "floro.no", "florø.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hønefoss.no", "jessheim.no", "jorpeland.no", "jørpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevåg.no", "leirvik.no", "mjondalen.no", "mjøndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjøen.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osøyro.no", "raholt.no", "råholt.no", "sandnessjoen.no", "sandnessjøen.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjørdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "afjord.no", "åfjord.no", "agdenes.no", "al.no", "ål.no", "alesund.no", "ålesund.no", "alstahaug.no", "alta.no", "áltá.no", "alaheadju.no", "álaheadju.no", "alvdal.no", "amli.no", "åmli.no", "amot.no", "åmot.no", "andebu.no", "andoy.no", "andøy.no", "andasuolo.no", "ardal.no", "årdal.no", "aremark.no", "arendal.no", "ås.no", "aseral.no", "åseral.no", "asker.no", "askim.no", "askvoll.no", "askoy.no", "askøy.no", "asnes.no", "åsnes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-høland.no", "austevoll.no", "austrheim.no", "averoy.no", "averøy.no", "balestrand.no", "ballangen.no", "balat.no", "bálát.no", "balsfjord.no", "bahccavuotna.no", "báhccavuotna.no", "bamble.no", "bardu.no", "beardu.no", "beiarn.no", "bajddar.no", "bájddar.no", "baidar.no", "báidár.no", "berg.no", "bergen.no", "berlevag.no", "berlevåg.no", "bearalvahki.no", "bearalváhki.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarkøy.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bodø.no", "badaddja.no", "bådåddjå.no", "budejju.no", "bokn.no", "bremanger.no", "bronnoy.no", "brønnøy.no", "bygland.no", "bykle.no", "barum.no", "bærum.no", "bo.telemark.no", "bø.telemark.no", "bo.nordland.no", "bø.nordland.no", "bievat.no", "bievát.no", "bomlo.no", "bømlo.no", "batsfjord.no", "båtsfjord.no", "bahcavuotna.no", "báhcavuotna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyrøy.no", "donna.no", "dønna.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenes.no", "evenassi.no", "evenášši.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fuossko.no", "fuoisku.no", "fedje.no", "fet.no", "finnoy.no", "finnøy.no", "fitjar.no", "fjaler.no", "fjell.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "fla.no", "flå.no", "folldal.no", "forsand.no", "fosnes.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "frana.no", "fræna.no", "froya.no", "frøya.no", "fusa.no", "fyresdal.no", "forde.no", "førde.no", "gamvik.no", "gangaviika.no", "gáŋgaviika.no", "gaular.no", "gausdal.no", "gildeskal.no", "gildeskål.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjøvik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "kraanghke.no", "kråanghke.no", "grue.no", "gulen.no", "hadsel.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "habmer.no", "hábmer.no", "hapmir.no", "hápmir.no", "hammerfest.no", "hammarfeasta.no", "hámmárfeasta.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "aknoluokta.no", "ákŋoluokta.no", "hattfjelldal.no", "aarborte.no", "haugesund.no", "hemne.no", "hemnes.no", "hemsedal.no", "heroy.more-og-romsdal.no", "herøy.møre-og-romsdal.no", "heroy.nordland.no", "herøy.nordland.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobøl.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtålen.no", "hornindal.no", "horten.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "hagebostad.no", "hægebostad.no", "hoyanger.no", "høyanger.no", "hoylandet.no", "høylandet.no", "ha.no", "hå.no", "ibestad.no", "inderoy.no", "inderøy.no", "iveland.no", "jevnaker.no", "jondal.no", "jolster.no", "jølster.no", "karasjok.no", "karasjohka.no", "kárášjohka.no", "karlsoy.no", "galsa.no", "gálsá.no", "karmoy.no", "karmøy.no", "kautokeino.no", "guovdageaidnu.no", "klepp.no", "klabu.no", "klæbu.no", "kongsberg.no", "kongsvinger.no", "kragero.no", "kragerø.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krødsherad.no", "kvalsund.no", "rahkkeravju.no", "ráhkkerávju.no", "kvam.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsøy.no", "kvafjord.no", "kvæfjord.no", "giehtavuoatna.no", "kvanangen.no", "kvænangen.no", "navuotna.no", "návuotna.no", "kafjord.no", "kåfjord.no", "gaivuotna.no", "gáivuotna.no", "larvik.no", "lavangen.no", "lavagis.no", "loabat.no", "loabát.no", "lebesby.no", "davvesiida.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "leangaviika.no", "leaŋgaviika.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindesnes.no", "lindas.no", "lindås.no", "lom.no", "loppa.no", "lahppi.no", "láhppi.no", "lund.no", "lunner.no", "luroy.no", "lurøy.no", "luster.no", "lyngdal.no", "lyngen.no", "ivgu.no", "lardal.no", "lerdal.no", "lærdal.no", "lodingen.no", "lødingen.no", "lorenskog.no", "lørenskog.no", "loten.no", "løten.no", "malvik.no", "masoy.no", "måsøy.no", "muosat.no", "muosát.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "meløy.no", "meraker.no", "meråker.no", "moareke.no", "moåreke.no", "midsund.no", "midtre-gauldal.no", "modalen.no", "modum.no", "molde.no", "moskenes.no", "moss.no", "mosvik.no", "malselv.no", "målselv.no", "malatvuopmi.no", "málatvuopmi.no", "namdalseid.no", "aejrie.no", "namsos.no", "namsskogan.no", "naamesjevuemie.no", "nååmesjevuemie.no", "laakesvuemie.no", "nannestad.no", "narvik.no", "narviika.no", "naustdal.no", "nedre-eiker.no", "nes.akershus.no", "nes.buskerud.no", "nesna.no", "nesodden.no", "nesseby.no", "unjarga.no", "unjárga.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "davvenjarga.no", "davvenjárga.no", "nordre-land.no", "nordreisa.no", "raisa.no", "ráisa.no", "nore-og-uvdal.no", "notodden.no", "naroy.no", "nærøy.no", "notteroy.no", "nøtterøy.no", "odda.no", "oksnes.no", "øksnes.no", "oppdal.no", "oppegard.no", "oppegård.no", "orkdal.no", "orland.no", "ørland.no", "orskog.no", "ørskog.no", "orsta.no", "ørsta.no", "os.hedmark.no", "os.hordaland.no", "osen.no", "osteroy.no", "osterøy.no", "ostre-toten.no", "østre-toten.no", "overhalla.no", "ovre-eiker.no", "øvre-eiker.no", "oyer.no", "øyer.no", "oygarden.no", "øygarden.no", "oystre-slidre.no", "øystre-slidre.no", "porsanger.no", "porsangu.no", "porsáŋgu.no", "porsgrunn.no", "radoy.no", "radøy.no", "rakkestad.no", "rana.no", "ruovat.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesøy.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "rissa.no", "risor.no", "risør.no", "roan.no", "rollag.no", "rygge.no", "ralingen.no", "rælingen.no", "rodoy.no", "rødøy.no", "romskog.no", "rømskog.no", "roros.no", "røros.no", "rost.no", "røst.no", "royken.no", "røyken.no", "royrvik.no", "røyrvik.no", "rade.no", "råde.no", "salangen.no", "siellak.no", "saltdal.no", "salat.no", "sálát.no", "sálat.no", "samnanger.no", "sande.more-og-romsdal.no", "sande.møre-og-romsdal.no", "sande.vestfold.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandøy.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "sigdal.no", "siljan.no", "sirdal.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skiptvet.no", "skjervoy.no", "skjervøy.no", "skierva.no", "skiervá.no", "skjak.no", "skjåk.no", "skodje.no", "skanland.no", "skånland.no", "skanit.no", "skánit.no", "smola.no", "smøla.no", "snillfjord.no", "snasa.no", "snåsa.no", "snoasa.no", "snaase.no", "snåase.no", "sogndal.no", "sokndal.no", "sola.no", "solund.no", "songdalen.no", "sortland.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjørdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "omasvuotna.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "sogne.no", "søgne.no", "somna.no", "sømna.no", "sondre-land.no", "søndre-land.no", "sor-aurdal.no", "sør-aurdal.no", "sor-fron.no", "sør-fron.no", "sor-odal.no", "sør-odal.no", "sor-varanger.no", "sør-varanger.no", "matta-varjjat.no", "mátta-várjjat.no", "sorfold.no", "sørfold.no", "sorreisa.no", "sørreisa.no", "sorum.no", "sørum.no", "tana.no", "deatnu.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "dielddanuorri.no", "tjome.no", "tjøme.no", "tokke.no", "tolga.no", "torsken.no", "tranoy.no", "tranøy.no", "tromso.no", "tromsø.no", "tromsa.no", "romsa.no", "trondheim.no", "troandin.no", "trysil.no", "trana.no", "træna.no", "trogstad.no", "trøgstad.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "divtasvuodna.no", "divttasvuotna.no", "tysnes.no", "tysvar.no", "tysvær.no", "tonsberg.no", "tønsberg.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "utsira.no", "vadso.no", "vadsø.no", "cahcesuolo.no", "čáhcesuolo.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vardø.no", "varggat.no", "várggát.no", "vefsn.no", "vaapste.no", "vega.no", "vegarshei.no", "vegårshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvågøy.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "volda.no", "voss.no", "varoy.no", "værøy.no", "vagan.no", "vågan.no", "voagat.no", "vagsoy.no", "vågsøy.no", "vaga.no", "vågå.no", "valer.ostfold.no", "våler.østfold.no", "valer.hedmark.no", "våler.hedmark.no", "*.np", "nr", "biz.nr", "info.nr", "gov.nr", "edu.nr", "org.nr", "net.nr", "com.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "mil.nz", "māori.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "ac.pa", "gob.pa", "com.pa", "org.pa", "sld.pa", "edu.pa", "net.pa", "ing.pa", "abo.pa", "med.pa", "nom.pa", "pe", "edu.pe", "gob.pe", "nom.pe", "mil.pe", "org.pe", "com.pe", "net.pe", "pf", "com.pf", "org.pf", "edu.pf", "*.pg", "ph", "com.ph", "net.ph", "org.ph", "gov.ph", "edu.ph", "ngo.ph", "mil.ph", "i.ph", "pk", "com.pk", "net.pk", "edu.pk", "org.pk", "fam.pk", "biz.pk", "web.pk", "gov.pk", "gob.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "info.pk", "pl", "com.pl", "net.pl", "org.pl", "aid.pl", "agro.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "miasta.pl", "media.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "ic.gov.pl", "is.gov.pl", "us.gov.pl", "kmpsp.gov.pl", "kppsp.gov.pl", "kwpsp.gov.pl", "psp.gov.pl", "wskr.gov.pl", "kwp.gov.pl", "mw.gov.pl", "ug.gov.pl", "um.gov.pl", "umig.gov.pl", "ugim.gov.pl", "upow.gov.pl", "uw.gov.pl", "starostwo.gov.pl", "pa.gov.pl", "po.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "so.gov.pl", "sr.gov.pl", "wsa.gov.pl", "sko.gov.pl", "uzs.gov.pl", "wiih.gov.pl", "winb.gov.pl", "pinb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wzmiuw.gov.pl", "piw.gov.pl", "wiw.gov.pl", "griw.gov.pl", "wif.gov.pl", "oum.gov.pl", "sdn.gov.pl", "zp.gov.pl", "uppo.gov.pl", "mup.gov.pl", "wuoz.gov.pl", "konsulat.gov.pl", "oirm.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "kazimierz-dolny.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorze.pl", "pomorskie.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "skoczow.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "gov.pn", "co.pn", "org.pn", "edu.pn", "net.pn", "post", "pr", "com.pr", "net.pr", "org.pr", "gov.pr", "edu.pr", "isla.pr", "pro.pr", "biz.pr", "info.pr", "name.pr", "est.pr", "prof.pr", "ac.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "edu.ps", "gov.ps", "sec.ps", "plo.ps", "com.ps", "org.ps", "net.ps", "pt", "net.pt", "gov.pt", "org.pt", "edu.pt", "int.pt", "publ.pt", "com.pt", "nome.pt", "pw", "co.pw", "ne.pw", "or.pw", "ed.pw", "go.pw", "belau.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "nom.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "net.sa", "org.sa", "gov.sa", "med.sa", "pub.sa", "edu.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "gov.sc", "net.sc", "org.sc", "edu.sc", "sd", "com.sd", "net.sd", "org.sd", "edu.sd", "med.sd", "tv.sd", "gov.sd", "info.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "net.sg", "org.sg", "gov.sg", "edu.sg", "per.sg", "sh", "com.sh", "net.sh", "gov.sh", "org.sh", "mil.sh", "si", "sj", "sk", "sl", "com.sl", "net.sl", "edu.sl", "gov.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "net.so", "org.so", "sr", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "gov.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "edu.sy", "gov.sy", "net.sy", "mil.sy", "com.sy", "org.sy", "sz", "co.sz", "ac.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "com.tm", "co.tm", "org.tm", "net.tm", "nom.tm", "gov.tm", "mil.tm", "edu.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "intl.tn", "nat.tn", "net.tn", "org.tn", "info.tn", "perso.tn", "tourism.tn", "edunet.tn", "rnrt.tn", "rns.tn", "rnu.tn", "mincom.tn", "agrinet.tn", "defense.tn", "turen.tn", "to", "com.to", "gov.to", "net.to", "org.to", "edu.to", "mil.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "mil.tr", "k12.tr", "kep.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "co.tt", "com.tt", "org.tt", "net.tt", "biz.tt", "info.tt", "pro.tt", "int.tt", "coop.tt", "jobs.tt", "mobi.tt", "travel.tt", "museum.tt", "aero.tt", "name.tt", "gov.tt", "edu.tt", "tv", "tw", "edu.tw", "gov.tw", "mil.tw", "com.tw", "net.tw", "org.tw", "idv.tw", "game.tw", "ebiz.tw", "club.tw", "網路.tw", "組織.tw", "商業.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "dominic.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "co.ug", "or.ug", "ac.ug", "sc.ug", "go.ug", "ne.ug", "com.ug", "org.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "vi.us", "vt.us", "va.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.de.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.ri.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.vi.us", "k12.vt.us", "k12.va.us", "k12.wa.us", "k12.wi.us", "k12.wy.us", "cc.ak.us", "cc.al.us", "cc.ar.us", "cc.as.us", "cc.az.us", "cc.ca.us", "cc.co.us", "cc.ct.us", "cc.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.vi.us", "cc.vt.us", "cc.va.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "lib.ak.us", "lib.al.us", "lib.ar.us", "lib.as.us", "lib.az.us", "lib.ca.us", "lib.co.us", "lib.ct.us", "lib.dc.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.vi.us", "lib.vt.us", "lib.va.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "pvt.k12.ma.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "net.vc", "org.vc", "gov.vc", "mil.vc", "edu.vc", "ve", "arts.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "org.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "com.vn", "net.vn", "org.vn", "edu.vn", "gov.vn", "int.vn", "ac.vn", "biz.vn", "info.vn", "name.vn", "pro.vn", "health.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "net.ws", "org.ws", "gov.ws", "edu.ws", "yt", "امارات", "հայ", "বাংলা", "бг", "бел", "中国", "中國", "الجزائر", "مصر", "ею", "გე", "ελ", "香港", "公司.香港", "教育.香港", "政府.香港", "個人.香港", "網絡.香港", "組織.香港", "ಭಾರತ", "ଭାରତ", "ভাৰত", "भारतम्", "भारोत", "ڀارت", "ഭാരതം", "भारत", "بارت", "بھارت", "భారత్", "ભારત", "ਭਾਰਤ", "ভারত", "இந்தியா", "ایران", "ايران", "عراق", "الاردن", "한국", "қаз", "ලංකා", "இலங்கை", "المغرب", "мкд", "мон", "澳門", "澳门", "مليسيا", "عمان", "پاکستان", "پاكستان", "فلسطين", "срб", "пр.срб", "орг.срб", "обр.срб", "од.срб", "упр.срб", "ак.срб", "рф", "قطر", "السعودية", "السعودیة", "السعودیۃ", "السعوديه", "سودان", "新加坡", "சிங்கப்பூர்", "سورية", "سوريا", "ไทย", "ศึกษา.ไทย", "ธุรกิจ.ไทย", "รัฐบาล.ไทย", "ทหาร.ไทย", "เน็ต.ไทย", "องค์กร.ไทย", "تونس", "台灣", "台湾", "臺灣", "укр", "اليمن", "xxx", "*.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abarth", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "adac", "ads", "adult", "aeg", "aetna", "afamilycompany", "afl", "africa", "agakhan", "agency", "aig", "aigo", "airbus", "airforce", "airtel", "akdn", "alfaromeo", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "avianca", "aws", "axa", "azure", "baby", "baidu", "banamex", "bananarepublic", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnl", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "budapest", "bugatti", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "cancerresearch", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "cartier", "casa", "case", "caseih", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "cbs", "ceb", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "chrysler", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "cityeats", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "comcast", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cookingchannel", "cool", "corsica", "country", "coupon", "coupons", "courses", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "csc", "cuisinella", "cymru", "cyou", "dabur", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dodge", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "duck", "dunlop", "duns", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "esurance", "etisalat", "eurovision", "eus", "events", "everbank", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fiat", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "foodnetwork", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontdoor", "frontier", "ftr", "fujitsu", "fujixerox", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glade", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "guardian", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hgtv", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "honeywell", "horse", "hospital", "host", "hosting", "hot", "hoteles", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "intel", "international", "intuit", "investments", "ipiranga", "irish", "iselect", "ismaili", "ist", "istanbul", "itau", "itv", "iveco", "jaguar", "java", "jcb", "jcp", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kim", "kinder", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "ladbrokes", "lamborghini", "lamer", "lancaster", "lancia", "lancome", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "liaison", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "linde", "link", "lipsy", "live", "living", "lixil", "llc", "loan", "loans", "locker", "locus", "loft", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "lupin", "luxe", "luxury", "macys", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "maserati", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merckmsd", "metlife", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "mobily", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mopar", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "movistar", "msd", "mtn", "mtr", "mutual", "nab", "nadex", "nagoya", "nationwide", "natura", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "newholland", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "northwesternmutual", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "off", "office", "okinawa", "olayan", "olayangroup", "oldnavy", "ollo", "omega", "one", "ong", "onl", "online", "onyourside", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "passagens", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "piaget", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "qvc", "racing", "radio", "raid", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "rightathome", "ril", "rio", "rip", "rmit", "rocher", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "sca", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scjohnson", "scor", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "ses", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shaw", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "showtime", "shriram", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "space", "sport", "spot", "spreadbetting", "srl", "srt", "stada", "staples", "star", "starhub", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiftcover", "swiss", "sydney", "symantec", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "telefonica", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tiffany", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelchannel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "uconnect", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "vistaprint", "viva", "vivo", "vlaanderen", "vodka", "volkswagen", "volvo", "vote", "voting", "voto", "voyage", "vuelos", "wales", "walmart", "walter", "wang", "wanggou", "warman", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xfinity", "xihuan", "xin", "कॉम", "セール", "佛山", "慈善", "集团", "在线", "大众汽车", "点看", "คอม", "八卦", "موقع", "公益", "公司", "香格里拉", "网站", "移动", "我爱你", "москва", "католик", "онлайн", "сайт", "联通", "קום", "时尚", "微博", "淡马锡", "ファッション", "орг", "नेट", "ストア", "삼성", "商标", "商店", "商城", "дети", "ポイント", "新闻", "工行", "家電", "كوم", "中文网", "中信", "娱乐", "谷歌", "電訊盈科", "购物", "クラウド", "通販", "网店", "संगठन", "餐厅", "网络", "ком", "诺基亚", "食品", "飞利浦", "手表", "手机", "ارامكو", "العليان", "اتصالات", "بازار", "موبايلي", "ابوظبي", "كاثوليك", "همراه", "닷컴", "政府", "شبكة", "بيتك", "عرب", "机构", "组织机构", "健康", "招聘", "рус", "珠宝", "大拿", "みんな", "グーグル", "世界", "書籍", "网址", "닷넷", "コム", "天主教", "游戏", "vermögensberater", "vermögensberatung", "企业", "信息", "嘉里大酒店", "嘉里", "广东", "政务", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "cc.ua", "inf.ua", "ltd.ua", "beep.pl", "barsy.ca", "*.compute.estate", "*.alces.network", "alwaysdata.net", "cloudfront.net", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "*.compute.amazonaws.com.cn", "us-east-1.amazonaws.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com", "*.elb.amazonaws.com.cn", "s3.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3.cn-north-1.amazonaws.com.cn", "s3.ca-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "t3l3p0rt.net", "tele.amune.org", "apigee.io", "on-aptible.com", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "go-vip.co", "go-vip.net", "wpcomstaging.com", "myfritz.net", "*.awdev.ca", "*.advisor.ws", "b-data.io", "backplaneapp.io", "app.banzaicloud.io", "betainabox.com", "bnr.la", "blackbaudcdn.net", "boomla.net", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "browsersafetymark.io", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "mycd.eu", "carrd.co", "crd.co", "uwu.ai", "ae.org", "ar.com", "br.com", "cn.com", "com.de", "com.se", "de.com", "eu.com", "gb.com", "gb.net", "hu.com", "hu.net", "jp.net", "jpn.com", "kr.com", "mex.com", "no.com", "qc.com", "ru.com", "sa.com", "se.net", "uk.com", "uk.net", "us.com", "uy.com", "za.bz", "za.com", "africa.com", "gr.com", "in.net", "us.org", "co.com", "c.la", "certmgr.org", "xenapponazure.com", "discourse.group", "virtueeldomein.nl", "cleverapps.io", "*.lcl.dev", "*.stg.dev", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "cloudcontrolled.com", "cloudcontrolapp.com", "workers.dev", "wnext.app", "co.ca", "*.otap.co", "co.cz", "c.cdn77.org", "cdn77-ssl.net", "r.cdn77.net", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "cloudns.asia", "cloudns.biz", "cloudns.club", "cloudns.cc", "cloudns.eu", "cloudns.in", "cloudns.info", "cloudns.org", "cloudns.pro", "cloudns.pw", "cloudns.us", "cloudeity.net", "cnpy.gdn", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "dyn.cosidns.de", "dynamisches-dns.de", "dnsupdater.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "realm.cz", "*.cryptonomic.net", "cupcake.is", "cyon.link", "cyon.site", "daplie.me", "localhost.daplie.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "*.dapps.earth", "*.bzz.dapps.earth", "debian.net", "dedyn.io", "dnshome.de", "online.th", "shop.th", "drayddns.com", "dreamhosters.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "dyndns.biz", "dyndns.info", "dyndns.org", "dyndns.tv", "at-band-camp.net", "ath.cx", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "better-than.tv", "blogdns.com", "blogdns.net", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "broke-it.net", "buyshouses.net", "cechire.com", "dnsalias.com", "dnsalias.net", "dnsalias.org", "dnsdojo.com", "dnsdojo.net", "dnsdojo.org", "does-it.net", "doesntexist.com", "doesntexist.org", "dontexist.com", "dontexist.net", "dontexist.org", "doomdns.com", "doomdns.org", "dvrdns.org", "dyn-o-saur.com", "dynalias.com", "dynalias.net", "dynalias.org", "dynathome.net", "dyndns.ws", "endofinternet.net", "endofinternet.org", "endoftheinternet.org", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "for-better.biz", "for-more.biz", "for-our.info", "for-some.biz", "for-the.biz", "forgot.her.name", "forgot.his.name", "from-ak.com", "from-al.com", "from-ar.com", "from-az.net", "from-ca.com", "from-co.net", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-la.net", "from-ma.com", "from-md.com", "from-me.org", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-ny.net", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "ftpaccess.cc", "fuettertdasnetz.de", "game-host.org", "game-server.cc", "getmyip.com", "gets-it.net", "go.dyndns.org", "gotdns.com", "gotdns.org", "groks-the.info", "groks-this.info", "ham-radio-op.net", "here-for-more.info", "hobby-site.com", "hobby-site.org", "home.dyndns.org", "homedns.org", "homeftp.net", "homeftp.org", "homeip.net", "homelinux.com", "homelinux.net", "homelinux.org", "homeunix.com", "homeunix.net", "homeunix.org", "iamallama.com", "in-the-band.net", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bruinsfan.org", "is-a-bulls-fan.com", "is-a-candidate.org", "is-a-caterer.com", "is-a-celticsfan.org", "is-a-chef.com", "is-a-chef.net", "is-a-chef.org", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-geek.net", "is-a-geek.org", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-knight.org", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-linux-user.org", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-patsfan.org", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-soxfan.org", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-by.us", "is-certified.com", "is-found.org", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-lost.org", "is-not-certified.com", "is-saved.org", "is-slick.com", "is-uberleet.com", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "is-with-theband.com", "isa-geek.com", "isa-geek.net", "isa-geek.org", "isa-hockeynut.com", "issmarterthanyou.com", "isteingeek.de", "istmein.de", "kicks-ass.net", "kicks-ass.org", "knowsitall.info", "land-4-sale.us", "lebtimnetz.de", "leitungsen.de", "likes-pie.com", "likescandy.com", "merseine.nu", "mine.nu", "misconfused.org", "mypets.ws", "myphotos.cc", "neat-url.com", "office-on-the.net", "on-the-web.tv", "podzone.net", "podzone.org", "readmyblog.org", "saves-the-whales.com", "scrapper-site.net", "scrapping.cc", "selfip.biz", "selfip.com", "selfip.info", "selfip.net", "selfip.org", "sells-for-less.com", "sells-for-u.com", "sells-it.net", "sellsyourhome.org", "servebbs.com", "servebbs.net", "servebbs.org", "serveftp.net", "serveftp.org", "servegame.org", "shacknet.nu", "simple-url.com", "space-to-rent.com", "stuff-4-sale.org", "stuff-4-sale.us", "teaches-yoga.com", "thruhere.net", "traeumtgerade.de", "webhop.biz", "webhop.info", "webhop.net", "webhop.org", "worse-than.tv", "writesthisblog.com", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyndns1.de", "dyn-ip24.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "definima.net", "definima.io", "bci.dnstrace.pro", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "blogsite.xyz", "dynv6.net", "e4.cz", "mytuleap.com", "onred.one", "staging.onred.one", "enonic.io", "customer.enonic.io", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "mc.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "paris.eu.org", "pl.eu.org", "pt.eu.org", "q-a.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "apps.fbsbx.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "fastly-terrarium.com", "fastlylb.net", "map.fastlylb.net", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastpanel.direct", "fastvps-server.com", "fhapp.xyz", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "filegear.me", "filegear-au.me", "filegear-de.me", "filegear-gb.me", "filegear-ie.me", "filegear-jp.me", "filegear-sg.me", "firebaseapp.com", "flynnhub.com", "flynnhosting.net", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "service.gov.uk", "gehirn.ne.jp", "usercontent.jp", "lab.ms", "github.io", "githubusercontent.com", "gitlab.io", "glitch.me", "cloudapps.digital", "london.cloudapps.digital", "homeoffice.gov.uk", "ro.im", "shop.ro", "goip.de", "run.app", "a.run.app", "*.0emm.com", "appspot.com", "blogspot.ae", "blogspot.al", "blogspot.am", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.co.at", "blogspot.co.id", "blogspot.co.il", "blogspot.co.ke", "blogspot.co.nz", "blogspot.co.uk", "blogspot.co.za", "blogspot.com", "blogspot.com.ar", "blogspot.com.au", "blogspot.com.br", "blogspot.com.by", "blogspot.com.co", "blogspot.com.cy", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.com.mt", "blogspot.com.ng", "blogspot.com.tr", "blogspot.com.uy", "blogspot.cv", "blogspot.cz", "blogspot.de", "blogspot.dk", "blogspot.fi", "blogspot.fr", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.ie", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.mr", "blogspot.mx", "blogspot.my", "blogspot.nl", "blogspot.no", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.tw", "blogspot.ug", "blogspot.vn", "cloudfunctions.net", "cloud.goog", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "publishproxy.com", "withgoogle.com", "withyoutube.com", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "hashbang.sh", "hasura.app", "hasura-app.io", "hepforge.org", "herokuapp.com", "herokussl.com", "myravendb.com", "ravendb.community", "ravendb.me", "development.run", "ravendb.run", "bpl.biz", "orx.biz", "ng.city", "ng.ink", "biz.gl", "col.ng", "gen.ng", "ltd.ng", "sch.so", "häkkinen.fi", "*.moonscale.io", "moonscale.net", "iki.fi", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-dsl.net", "in-dsl.org", "in-vpn.de", "in-vpn.net", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "ipifony.net", "mein-iserv.de", "test-iserv.de", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "*.triton.zone", "*.cns.joyent.com", "js.org", "kaas.gg", "khplay.nl", "keymachine.de", "knightpoint.systems", "co.krd", "edu.krd", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "app.lmpm.com", "linkitools.space", "linkyard.cloud", "linkyard-cloud.ch", "members.linode.com", "nodebalancer.linode.com", "we.bs", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "uklugs.org", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.co.uk", "barsyonline.co.uk", "barsycenter.com", "barsyonline.com", "barsy.club", "barsy.de", "barsy.eu", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.shop", "barsy.site", "barsy.support", "barsy.uk", "*.magentosite.cloud", "mayfirst.info", "mayfirst.org", "hb.cldmail.ru", "miniserver.com", "memset.net", "cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "azurecontainer.io", "azurewebsites.net", "azure-mobile.net", "cloudapp.net", "mozilla-iot.org", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "ui.nabu.casa", "pony.club", "of.fashion", "on.fashion", "of.football", "in.london", "of.london", "for.men", "and.mom", "for.mom", "for.one", "for.sale", "of.work", "to.work", "nctu.me", "bitballoon.com", "netlify.com", "4u.com", "ngrok.io", "nh-serv.co.uk", "nfshost.com", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "ddnslive.com", "myiphost.com", "forumz.info", "16-b.it", "32-b.it", "64-b.it", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "crafting.xyz", "zapto.xyz", "nsupdate.info", "nerdpol.ovh", "blogsyte.com", "brasilia.me", "cable-modem.org", "ciscofreak.com", "collegefan.org", "couchpotatofries.org", "damnserver.com", "ddns.me", "ditchyourip.com", "dnsfor.me", "dnsiskinky.com", "dvrcam.info", "dynns.com", "eating-organic.net", "fantasyleague.cc", "geekgalaxy.com", "golffan.us", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "hopto.me", "ilovecollege.info", "loginto.me", "mlbfan.org", "mmafan.biz", "myactivedirectory.com", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.com", "mysecuritycamera.net", "mysecuritycamera.org", "net-freaks.com", "nflfan.org", "nhlfan.net", "no-ip.ca", "no-ip.co.uk", "no-ip.net", "noip.us", "onthewifi.com", "pgafan.net", "point2this.com", "pointto.us", "privatizehealthinsurance.net", "quicksytes.com", "read-books.org", "securitytactics.com", "serveexchange.com", "servehumour.com", "servep2p.com", "servesarcasm.com", "stufftoread.com", "ufcfan.org", "unusualperson.com", "workisboring.com", "3utilities.com", "bounceme.net", "ddns.net", "ddnsking.com", "gotdns.ch", "hopto.org", "myftp.biz", "myftp.org", "myvnc.com", "no-ip.biz", "no-ip.info", "no-ip.org", "noip.me", "redirectme.net", "servebeer.com", "serveblog.net", "servecounterstrike.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "serveirc.com", "serveminecraft.net", "servemp3.com", "servepics.com", "servequake.com", "sytes.net", "webhop.me", "zapto.org", "stage.nodeart.io", "nodum.co", "nodum.io", "pcloud.host", "nyc.mn", "nom.ae", "nom.af", "nom.ai", "nom.al", "nym.by", "nym.bz", "nom.cl", "nom.gd", "nom.ge", "nom.gl", "nym.gr", "nom.gt", "nym.gy", "nom.hn", "nym.ie", "nom.im", "nom.ke", "nym.kz", "nym.la", "nym.lc", "nom.li", "nym.li", "nym.lt", "nym.lu", "nym.me", "nom.mk", "nym.mn", "nym.mx", "nom.nu", "nym.nz", "nym.pe", "nym.pt", "nom.pw", "nom.qa", "nym.ro", "nom.rs", "nom.si", "nym.sk", "nom.st", "nym.su", "nym.sx", "nom.tj", "nym.tw", "nom.ug", "nom.uy", "nom.vc", "nom.vg", "cya.gg", "cloudycluster.net", "nid.io", "opencraft.hosting", "operaunite.com", "outsystemscloud.com", "ownprovider.com", "own.pm", "ox.rs", "oy.lc", "pgfog.com", "pagefrontapp.com", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "pantheonsite.io", "gotpantheon.com", "mypep.link", "on-web.fr", "*.platform.sh", "*.platformsh.site", "co.bn", "xen.prgmr.com", "priv.at", "prvcy.page", "*.dweb.link", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "instantcloud.cn", "ras.ru", "qa2.com", "dev-myqnapcloud.com", "alpha-myqnapcloud.com", "myqnapcloud.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "*.on-rancher.cloud", "*.on-rio.io", "readthedocs.io", "rhcloud.com", "app.render.com", "onrender.com", "repl.co", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "wellbeingzone.eu", "ptplus.fit", "wellbeingzone.co.uk", "git-pages.rit.edu", "sandcats.io", "logoip.de", "logoip.com", "schokokeks.net", "scrysec.com", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "*.s5y.io", "*.sensiosite.cloud", "biz.ua", "co.ua", "pp.ua", "shiftedit.io", "myshopblocks.com", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "bounty-full.com", "alpha.bounty-full.com", "beta.bounty-full.com", "stackhero-network.com", "static.land", "dev.static.land", "sites.static.land", "apps.lair.io", "*.stolos.io", "spacekit.io", "customer.speedpartner.de", "api.stdlib.com", "storj.farm", "utwente.io", "soc.srcf.net", "user.srcf.net", "temp-dns.com", "applicationcloud.io", "scapp.io", "syncloud.it", "diskstation.me", "dscloud.biz", "dscloud.me", "dscloud.mobi", "dsmynas.com", "dsmynas.net", "dsmynas.org", "familyds.com", "familyds.net", "familyds.org", "i234.me", "myds.me", "synology.me", "vpnplus.to", "taifun-dns.de", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "edugit.org", "telebit.app", "telebit.io", "*.telebit.xyz", "gwiddle.co.uk", "thingdustdata.com", "cust.dev.thingdust.io", "cust.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "arvo.network", "azimuth.network", "bloxcms.com", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "diskstation.eu", "diskstation.org", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "uber.space", "*.uberspace.de", "hk.com", "hk.org", "ltd.hk", "inc.hk", "virtualuser.de", "virtual-user.de", "lib.de.us", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "wafflecell.com", "wedeploy.io", "wedeploy.me", "wedeploy.sh", "remotewd.com", "wmflabs.org", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "official.academy", "yolasite.com", "ybo.faith", "yombo.me", "homelink.one", "ybo.party", "ybo.review", "ybo.science", "ybo.trade", "nohost.me", "noho.st", "za.net", "za.org", "now.sh", "bss.design", "basicserver.io", "virtualserver.io", "site.builder.nu", "enterprisecloud.nu", "zone.id" ];
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Store = __webpack_require__(476).Store, permuteDomain = __webpack_require__(477).permuteDomain, pathMatch = __webpack_require__(478).pathMatch, util = __webpack_require__(0);
    function MemoryCookieStore() {
        Store.call(this), this.idx = {};
    }
    util.inherits(MemoryCookieStore, Store), exports.MemoryCookieStore = MemoryCookieStore, 
    MemoryCookieStore.prototype.idx = null, MemoryCookieStore.prototype.synchronous = !0, 
    MemoryCookieStore.prototype.inspect = function() {
        return "{ idx: " + util.inspect(this.idx, !1, 2) + " }";
    }, util.inspect.custom && (MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect), 
    MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
        return this.idx[domain] && this.idx[domain][path] ? cb(null, this.idx[domain][path][key] || null) : cb(null, void 0);
    }, MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
        var pathMatcher, results = [];
        if (!domain) return cb(null, []);
        pathMatcher = path ? function(domainIndex) {
            Object.keys(domainIndex).forEach((function(cookiePath) {
                if (pathMatch(path, cookiePath)) {
                    var pathIndex = domainIndex[cookiePath];
                    for (var key in pathIndex) results.push(pathIndex[key]);
                }
            }));
        } : function(domainIndex) {
            for (var curPath in domainIndex) {
                var pathIndex = domainIndex[curPath];
                for (var key in pathIndex) results.push(pathIndex[key]);
            }
        };
        var domains = permuteDomain(domain) || [ domain ], idx = this.idx;
        domains.forEach((function(curDomain) {
            var domainIndex = idx[curDomain];
            domainIndex && pathMatcher(domainIndex);
        })), cb(null, results);
    }, MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
        this.idx[cookie.domain] || (this.idx[cookie.domain] = {}), this.idx[cookie.domain][cookie.path] || (this.idx[cookie.domain][cookie.path] = {}), 
        this.idx[cookie.domain][cookie.path][cookie.key] = cookie, cb(null);
    }, MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
        this.putCookie(newCookie, cb);
    }, MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
        this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key] && delete this.idx[domain][path][key], 
        cb(null);
    }, MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
        return this.idx[domain] && (path ? delete this.idx[domain][path] : delete this.idx[domain]), 
        cb(null);
    }, MemoryCookieStore.prototype.getAllCookies = function(cb) {
        var cookies = [], idx = this.idx;
        Object.keys(idx).forEach((function(domain) {
            Object.keys(idx[domain]).forEach((function(path) {
                Object.keys(idx[domain][path]).forEach((function(key) {
                    null !== key && cookies.push(idx[domain][path][key]);
                }));
            }));
        })), cookies.sort((function(a, b) {
            return (a.creationIndex || 0) - (b.creationIndex || 0);
        })), cb(null, cookies);
    };
}, function(module) {
    module.exports = {
        author: {
            name: "Jeremy Stashewsky",
            email: "jstash@gmail.com",
            website: "https://github.com/stash"
        },
        contributors: [ {
            name: "Alexander Savin",
            website: "https://github.com/apsavin"
        }, {
            name: "Ian Livingstone",
            website: "https://github.com/ianlivingstone"
        }, {
            name: "Ivan Nikulin",
            website: "https://github.com/inikulin"
        }, {
            name: "Lalit Kapoor",
            website: "https://github.com/lalitkapoor"
        }, {
            name: "Sam Thompson",
            website: "https://github.com/sambthompson"
        }, {
            name: "Sebastian Mayr",
            website: "https://github.com/Sebmaster"
        } ],
        license: "BSD-3-Clause",
        name: "tough-cookie",
        description: "RFC6265 Cookies and Cookie Jar for node.js",
        keywords: [ "HTTP", "cookie", "cookies", "set-cookie", "cookiejar", "jar", "RFC6265", "RFC2965" ],
        version: "2.4.3",
        homepage: "https://github.com/salesforce/tough-cookie",
        repository: {
            type: "git",
            url: "git://github.com/salesforce/tough-cookie.git"
        },
        bugs: {
            url: "https://github.com/salesforce/tough-cookie/issues"
        },
        main: "./lib/cookie",
        files: [ "lib" ],
        scripts: {
            test: "vows test/*_test.js",
            cover: "nyc --reporter=lcov --reporter=html vows test/*_test.js"
        },
        engines: {
            node: ">=0.8"
        },
        devDependencies: {
            async: "^1.4.2",
            nyc: "^11.6.0",
            "string.prototype.repeat": "^0.2.0",
            vows: "^0.8.1"
        },
        dependencies: {
            psl: "^1.1.24",
            punycode: "^1.4.1"
        }
    };
}, function(module, exports) {
    function serializer(replacer, cycleReplacer) {
        var stack = [], keys = [];
        return null == cycleReplacer && (cycleReplacer = function(key, value) {
            return stack[0] === value ? "[Circular ~]" : "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        }), function(key, value) {
            if (stack.length > 0) {
                var thisPos = stack.indexOf(this);
                ~thisPos ? stack.splice(thisPos + 1) : stack.push(this), ~thisPos ? keys.splice(thisPos, 1 / 0, key) : keys.push(key), 
                ~stack.indexOf(value) && (value = cycleReplacer.call(this, key, value));
            } else stack.push(value);
            return null == replacer ? value : replacer.call(this, key, value);
        };
    }
    (module.exports = function(obj, replacer, spaces, cycleReplacer) {
        return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }).getSerialize = serializer;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var http = __webpack_require__(11), https = __webpack_require__(22), url = __webpack_require__(7), util = __webpack_require__(0), stream = __webpack_require__(3), zlib = __webpack_require__(45), aws2 = __webpack_require__(1047), aws4 = __webpack_require__(1048), httpSignature = __webpack_require__(1050), mime = __webpack_require__(89), caseless = __webpack_require__(236), ForeverAgent = __webpack_require__(1067), FormData = __webpack_require__(1068), extend = __webpack_require__(147), isstream = __webpack_require__(492), isTypedArray = __webpack_require__(168).strict, helpers = __webpack_require__(229), cookies = __webpack_require__(473), getProxyFromURI = __webpack_require__(1075), Querystring = __webpack_require__(1076).Querystring, Har = __webpack_require__(1079).Har, Auth = __webpack_require__(1135).Auth, OAuth = __webpack_require__(1136).OAuth, hawk = __webpack_require__(1138), Multipart = __webpack_require__(1139).Multipart, Redirect = __webpack_require__(1140).Redirect, Tunnel = __webpack_require__(1141).Tunnel, now = __webpack_require__(1143), Buffer = __webpack_require__(23).Buffer, safeStringify = helpers.safeStringify, isReadStream = helpers.isReadStream, toBase64 = helpers.toBase64, defer = helpers.defer, copy = helpers.copy, version = helpers.version, globalCookieJar = cookies.jar(), globalPool = {};
    function requestToJSON() {
        return {
            uri: this.uri,
            method: this.method,
            headers: this.headers
        };
    }
    function responseToJSON() {
        return {
            statusCode: this.statusCode,
            body: this.body,
            headers: this.headers,
            request: requestToJSON.call(this.request)
        };
    }
    function Request(options) {
        options.har && (this._har = new Har(this), options = this._har.options(options)), 
        stream.Stream.call(this);
        var reserved = Object.keys(Request.prototype), nonReserved = (function(reserved, options) {
            var object = {};
            for (var i in options) -1 === reserved.indexOf(i) && (object[i] = options[i]);
            return object;
        })(reserved, options);
        extend(this, nonReserved), options = (function(reserved, options) {
            var object = {};
            for (var i in options) {
                var isReserved = !(-1 === reserved.indexOf(i)), isFunction = "function" == typeof options[i];
                isReserved && isFunction || (object[i] = options[i]);
            }
            return object;
        })(reserved, options), this.readable = !0, this.writable = !0, options.method && (this.explicitMethod = !0), 
        this._qs = new Querystring(this), this._auth = new Auth(this), this._oauth = new OAuth(this), 
        this._multipart = new Multipart(this), this._redirect = new Redirect(this), this._tunnel = new Tunnel(this), 
        this.init(options);
    }
    function debug() {
        Request.debug && console.error("REQUEST %s", util.format.apply(util, arguments));
    }
    util.inherits(Request, stream.Stream), Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG), 
    Request.prototype.debug = debug, Request.prototype.init = function(options) {
        var self = this;
        for (var headerName in options || (options = {}), self.headers = self.headers ? copy(self.headers) : {}, 
        self.headers) void 0 === self.headers[headerName] && delete self.headers[headerName];
        if (caseless.httpify(self, self.headers), self.method || (self.method = options.method || "GET"), 
        self.localAddress || (self.localAddress = options.localAddress), self._qs.init(options), 
        debug(options), self.pool || !1 === self.pool || (self.pool = globalPool), self.dests = self.dests || [], 
        self.__isRequestRequest = !0, !self._callback && self.callback && (self._callback = self.callback, 
        self.callback = function() {
            self._callbackCalled || (self._callbackCalled = !0, self._callback.apply(self, arguments));
        }, self.on("error", self.callback.bind()), self.on("complete", self.callback.bind(self, null))), 
        !self.uri && self.url && (self.uri = self.url, delete self.url), self.baseUrl) {
            if ("string" != typeof self.baseUrl) return self.emit("error", new Error("options.baseUrl must be a string"));
            if ("string" != typeof self.uri) return self.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
            if (0 === self.uri.indexOf("//") || -1 !== self.uri.indexOf("://")) return self.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
            var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf("/") === self.baseUrl.length - 1, uriStartsWithSlash = 0 === self.uri.indexOf("/");
            baseUrlEndsWithSlash && uriStartsWithSlash ? self.uri = self.baseUrl + self.uri.slice(1) : baseUrlEndsWithSlash || uriStartsWithSlash ? self.uri = self.baseUrl + self.uri : "" === self.uri ? self.uri = self.baseUrl : self.uri = self.baseUrl + "/" + self.uri, 
            delete self.baseUrl;
        }
        if (!self.uri) return self.emit("error", new Error("options.uri is a required argument"));
        if ("string" == typeof self.uri && (self.uri = url.parse(self.uri)), self.uri.href || (self.uri.href = url.format(self.uri)), 
        "unix:" === self.uri.protocol) return self.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
        if ("unix" === self.uri.host && self.enableUnixSocket(), !1 === self.strictSSL && (self.rejectUnauthorized = !1), 
        self.uri.pathname || (self.uri.pathname = "/"), !(self.uri.host || self.uri.hostname && self.uri.port || self.uri.isUnix)) {
            var message = 'Invalid URI "' + url.format(self.uri) + '"';
            return 0 === Object.keys(options).length && (message += ". This can be caused by a crappy redirection."), 
            self.abort(), self.emit("error", new Error(message));
        }
        if (self.hasOwnProperty("proxy") || (self.proxy = getProxyFromURI(self.uri)), self.tunnel = self._tunnel.isEnabled(), 
        self.proxy && self._tunnel.setup(options), self._redirect.onRequest(options), self.setHost = !1, 
        !self.hasHeader("host")) {
            var hostHeaderName = self.originalHostHeaderName || "host";
            self.setHeader(hostHeaderName, self.uri.host), self.uri.port && ("80" === self.uri.port && "http:" === self.uri.protocol || "443" === self.uri.port && "https:" === self.uri.protocol) && self.setHeader(hostHeaderName, self.uri.hostname), 
            self.setHost = !0;
        }
        if (self.jar(self._jar || options.jar), self.uri.port || ("http:" === self.uri.protocol ? self.uri.port = 80 : "https:" === self.uri.protocol && (self.uri.port = 443)), 
        self.proxy && !self.tunnel ? (self.port = self.proxy.port, self.host = self.proxy.hostname) : (self.port = self.uri.port, 
        self.host = self.uri.hostname), options.form && self.form(options.form), options.formData) {
            var formData = options.formData, requestForm = self.form(), appendFormValue = function(key, value) {
                value && value.hasOwnProperty("value") && value.hasOwnProperty("options") ? requestForm.append(key, value.value, value.options) : requestForm.append(key, value);
            };
            for (var formKey in formData) if (formData.hasOwnProperty(formKey)) {
                var formValue = formData[formKey];
                if (formValue instanceof Array) for (var j = 0; j < formValue.length; j++) appendFormValue(formKey, formValue[j]); else appendFormValue(formKey, formValue);
            }
        }
        if (options.qs && self.qs(options.qs), self.uri.path ? self.path = self.uri.path : self.path = self.uri.pathname + (self.uri.search || ""), 
        0 === self.path.length && (self.path = "/"), options.aws && self.aws(options.aws), 
        options.hawk && self.hawk(options.hawk), options.httpSignature && self.httpSignature(options.httpSignature), 
        options.auth && (Object.prototype.hasOwnProperty.call(options.auth, "username") && (options.auth.user = options.auth.username), 
        Object.prototype.hasOwnProperty.call(options.auth, "password") && (options.auth.pass = options.auth.password), 
        self.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer)), 
        self.gzip && !self.hasHeader("accept-encoding") && self.setHeader("accept-encoding", "gzip, deflate"), 
        self.uri.auth && !self.hasHeader("authorization")) {
            var uriAuthPieces = self.uri.auth.split(":").map((function(item) {
                return self._qs.unescape(item);
            }));
            self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), !0);
        }
        if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader("proxy-authorization")) {
            var proxyAuthPieces = self.proxy.auth.split(":").map((function(item) {
                return self._qs.unescape(item);
            })), authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
            self.setHeader("proxy-authorization", authHeader);
        }
        function setContentLength() {
            var length;
            isTypedArray(self.body) && (self.body = Buffer.from(self.body)), self.hasHeader("content-length") || ((length = "string" == typeof self.body ? Buffer.byteLength(self.body) : Array.isArray(self.body) ? self.body.reduce((function(a, b) {
                return a + b.length;
            }), 0) : self.body.length) ? self.setHeader("content-length", length) : self.emit("error", new Error("Argument error, options.body.")));
        }
        self.proxy && !self.tunnel && (self.path = self.uri.protocol + "//" + self.uri.host + self.path), 
        options.json && self.json(options.json), options.multipart && self.multipart(options.multipart), 
        options.time && (self.timing = !0, self.elapsedTime = self.elapsedTime || 0), self.body && !isstream(self.body) && setContentLength(), 
        options.oauth ? self.oauth(options.oauth) : self._oauth.params && self.hasHeader("authorization") && self.oauth(self._oauth.params);
        var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol, defaultModules = {
            "http:": http,
            "https:": https
        }, httpModules = self.httpModules || {};
        if (self.httpModule = httpModules[protocol] || defaultModules[protocol], !self.httpModule) return self.emit("error", new Error("Invalid protocol: " + protocol));
        if (options.ca && (self.ca = options.ca), !self.agent) if (options.agentOptions && (self.agentOptions = options.agentOptions), 
        options.agentClass) self.agentClass = options.agentClass; else if (options.forever) {
            var v = version();
            0 === v.major && v.minor <= 10 ? self.agentClass = "http:" === protocol ? ForeverAgent : ForeverAgent.SSL : (self.agentClass = self.httpModule.Agent, 
            self.agentOptions = self.agentOptions || {}, self.agentOptions.keepAlive = !0);
        } else self.agentClass = self.httpModule.Agent;
        !1 === self.pool ? self.agent = !1 : self.agent = self.agent || self.getNewAgent(), 
        self.on("pipe", (function(src) {
            if (self.ntick && self._started && self.emit("error", new Error("You cannot pipe to this stream after the outbound request has started.")), 
            self.src = src, isReadStream(src)) self.hasHeader("content-type") || self.setHeader("content-type", mime.lookup(src.path)); else {
                if (src.headers) for (var i in src.headers) self.hasHeader(i) || self.setHeader(i, src.headers[i]);
                self._json && !self.hasHeader("content-type") && self.setHeader("content-type", "application/json"), 
                src.method && !self.explicitMethod && (self.method = src.method);
            }
        })), defer((function() {
            if (!self._aborted) {
                var end = function() {
                    if (self._form && (self._auth.hasAuth ? self._auth.hasAuth && self._auth.sentAuth && self._form.pipe(self) : self._form.pipe(self)), 
                    self._multipart && self._multipart.chunked && self._multipart.body.pipe(self), self.body) isstream(self.body) ? self.body.pipe(self) : (setContentLength(), 
                    Array.isArray(self.body) ? self.body.forEach((function(part) {
                        self.write(part);
                    })) : self.write(self.body), self.end()); else if (self.requestBodyStream) console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe."), 
                    self.requestBodyStream.pipe(self); else if (!self.src) {
                        if (self._auth.hasAuth && !self._auth.sentAuth) return void self.end();
                        "GET" !== self.method && void 0 !== self.method && self.setHeader("content-length", 0), 
                        self.end();
                    }
                };
                self._form && !self.hasHeader("content-length") ? (self.setHeader(self._form.getHeaders(), !0), 
                self._form.getLength((function(err, length) {
                    err || isNaN(length) || self.setHeader("content-length", length), end();
                }))) : end(), self.ntick = !0;
            }
        }));
    }, Request.prototype.getNewAgent = function() {
        var Agent = this.agentClass, options = {};
        if (this.agentOptions) for (var i in this.agentOptions) options[i] = this.agentOptions[i];
        this.ca && (options.ca = this.ca), this.ciphers && (options.ciphers = this.ciphers), 
        this.secureProtocol && (options.secureProtocol = this.secureProtocol), this.secureOptions && (options.secureOptions = this.secureOptions), 
        void 0 !== this.rejectUnauthorized && (options.rejectUnauthorized = this.rejectUnauthorized), 
        this.cert && this.key && (options.key = this.key, options.cert = this.cert), this.pfx && (options.pfx = this.pfx), 
        this.passphrase && (options.passphrase = this.passphrase);
        var poolKey = "";
        Agent !== this.httpModule.Agent && (poolKey += Agent.name);
        var proxy = this.proxy;
        return "string" == typeof proxy && (proxy = url.parse(proxy)), (proxy && "https:" === proxy.protocol || "https:" === this.uri.protocol) && (options.ca && (poolKey && (poolKey += ":"), 
        poolKey += options.ca), void 0 !== options.rejectUnauthorized && (poolKey && (poolKey += ":"), 
        poolKey += options.rejectUnauthorized), options.cert && (poolKey && (poolKey += ":"), 
        poolKey += options.cert.toString("ascii") + options.key.toString("ascii")), options.pfx && (poolKey && (poolKey += ":"), 
        poolKey += options.pfx.toString("ascii")), options.ciphers && (poolKey && (poolKey += ":"), 
        poolKey += options.ciphers), options.secureProtocol && (poolKey && (poolKey += ":"), 
        poolKey += options.secureProtocol), options.secureOptions && (poolKey && (poolKey += ":"), 
        poolKey += options.secureOptions)), this.pool === globalPool && !poolKey && 0 === Object.keys(options).length && this.httpModule.globalAgent ? this.httpModule.globalAgent : (poolKey = this.uri.protocol + poolKey, 
        this.pool[poolKey] || (this.pool[poolKey] = new Agent(options), this.pool.maxSockets && (this.pool[poolKey].maxSockets = this.pool.maxSockets)), 
        this.pool[poolKey]);
    }, Request.prototype.start = function() {
        var self = this;
        if (self.timing) var startTime = (new Date).getTime(), startTimeNow = now();
        if (!self._aborted) {
            self._started = !0, self.method = self.method || "GET", self.href = self.uri.href, 
            self.src && self.src.stat && self.src.stat.size && !self.hasHeader("content-length") && self.setHeader("content-length", self.src.stat.size), 
            self._aws && self.aws(self._aws, !0);
            var timeout, reqOptions = copy(self);
            delete reqOptions.auth, debug("make request", self.uri.href), delete reqOptions.timeout;
            try {
                self.req = self.httpModule.request(reqOptions);
            } catch (err) {
                return void self.emit("error", err);
            }
            self.timing && (self.startTime = startTime, self.startTimeNow = startTimeNow, self.timings = {}), 
            self.timeout && !self.timeoutTimer && (self.timeout < 0 ? timeout = 0 : "number" == typeof self.timeout && isFinite(self.timeout) && (timeout = self.timeout)), 
            self.req.on("response", self.onRequestResponse.bind(self)), self.req.on("error", self.onRequestError.bind(self)), 
            self.req.on("drain", (function() {
                self.emit("drain");
            })), self.req.on("socket", (function(socket) {
                var isConnecting = socket._connecting || socket.connecting;
                if (self.timing && (self.timings.socket = now() - self.startTimeNow, isConnecting)) {
                    var onLookupTiming = function() {
                        self.timings.lookup = now() - self.startTimeNow;
                    }, onConnectTiming = function() {
                        self.timings.connect = now() - self.startTimeNow;
                    };
                    socket.once("lookup", onLookupTiming), socket.once("connect", onConnectTiming), 
                    self.req.once("error", (function() {
                        socket.removeListener("lookup", onLookupTiming), socket.removeListener("connect", onConnectTiming);
                    }));
                }
                var setReqTimeout = function() {
                    self.req.setTimeout(timeout, (function() {
                        if (self.req) {
                            self.abort();
                            var e = new Error("ESOCKETTIMEDOUT");
                            e.code = "ESOCKETTIMEDOUT", e.connect = !1, self.emit("error", e);
                        }
                    }));
                };
                if (void 0 !== timeout) if (isConnecting) {
                    var onReqSockConnect = function() {
                        socket.removeListener("connect", onReqSockConnect), clearTimeout(self.timeoutTimer), 
                        self.timeoutTimer = null, setReqTimeout();
                    };
                    socket.on("connect", onReqSockConnect), self.req.on("error", (function(err) {
                        socket.removeListener("connect", onReqSockConnect);
                    })), self.timeoutTimer = setTimeout((function() {
                        socket.removeListener("connect", onReqSockConnect), self.abort();
                        var e = new Error("ETIMEDOUT");
                        e.code = "ETIMEDOUT", e.connect = !0, self.emit("error", e);
                    }), timeout);
                } else setReqTimeout();
                self.emit("socket", socket);
            })), self.emit("request", self.req);
        }
    }, Request.prototype.onRequestError = function(error) {
        if (!this._aborted) {
            if (this.req && this.req._reusedSocket && "ECONNRESET" === error.code && this.agent.addRequestNoreuse) return this.agent = {
                addRequest: this.agent.addRequestNoreuse.bind(this.agent)
            }, this.start(), void this.req.end();
            this.timeout && this.timeoutTimer && (clearTimeout(this.timeoutTimer), this.timeoutTimer = null), 
            this.emit("error", error);
        }
    }, Request.prototype.onRequestResponse = function(response) {
        var self = this;
        if (self.timing && (self.timings.response = now() - self.startTimeNow), debug("onRequestResponse", self.uri.href, response.statusCode, response.headers), 
        response.on("end", (function() {
            self.timing && (self.timings.end = now() - self.startTimeNow, response.timingStart = self.startTime, 
            self.timings.socket || (self.timings.socket = 0), self.timings.lookup || (self.timings.lookup = self.timings.socket), 
            self.timings.connect || (self.timings.connect = self.timings.lookup), self.timings.response || (self.timings.response = self.timings.connect), 
            debug("elapsed time", self.timings.end), self.elapsedTime += Math.round(self.timings.end), 
            response.elapsedTime = self.elapsedTime, response.timings = self.timings, response.timingPhases = {
                wait: self.timings.socket,
                dns: self.timings.lookup - self.timings.socket,
                tcp: self.timings.connect - self.timings.lookup,
                firstByte: self.timings.response - self.timings.connect,
                download: self.timings.end - self.timings.response,
                total: self.timings.end
            }), debug("response end", self.uri.href, response.statusCode, response.headers);
        })), self._aborted) return debug("aborted", self.uri.href), void response.resume();
        if (self.response = response, response.request = self, response.toJSON = responseToJSON, 
        self.httpModule !== https || !self.strictSSL || response.hasOwnProperty("socket") && response.socket.authorized) {
            self.originalHost = self.getHeader("host"), self.originalHostHeaderName || (self.originalHostHeaderName = self.hasHeader("host")), 
            self.setHost && self.removeHeader("host"), self.timeout && self.timeoutTimer && (clearTimeout(self.timeoutTimer), 
            self.timeoutTimer = null);
            var targetCookieJar = self._jar && self._jar.setCookie ? self._jar : globalCookieJar, addCookie = function(cookie) {
                try {
                    targetCookieJar.setCookie(cookie, self.uri.href, {
                        ignoreError: !0
                    });
                } catch (e) {
                    self.emit("error", e);
                }
            };
            if (response.caseless = caseless(response.headers), response.caseless.has("set-cookie") && !self._disableCookies) {
                var headerName = response.caseless.has("set-cookie");
                Array.isArray(response.headers[headerName]) ? response.headers[headerName].forEach(addCookie) : addCookie(response.headers[headerName]);
            }
            if (!self._redirect.onResponse(response)) {
                var responseContent, code;
                if (response.on("close", (function() {
                    self._ended || self.response.emit("end");
                })), response.once("end", (function() {
                    self._ended = !0;
                })), !self.gzip || (code = response.statusCode, "HEAD" === self.method || code >= 100 && code < 200 || 204 === code || 304 === code)) responseContent = response; else {
                    var contentEncoding = response.headers["content-encoding"] || "identity";
                    contentEncoding = contentEncoding.trim().toLowerCase();
                    var zlibOptions = {
                        flush: zlib.Z_SYNC_FLUSH,
                        finishFlush: zlib.Z_SYNC_FLUSH
                    };
                    "gzip" === contentEncoding ? (responseContent = zlib.createGunzip(zlibOptions), 
                    response.pipe(responseContent)) : "deflate" === contentEncoding ? (responseContent = zlib.createInflate(zlibOptions), 
                    response.pipe(responseContent)) : ("identity" !== contentEncoding && debug("ignoring unrecognized Content-Encoding " + contentEncoding), 
                    responseContent = response);
                }
                self.encoding && (0 !== self.dests.length ? console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.") : responseContent.setEncoding(self.encoding)), 
                self._paused && responseContent.pause(), self.responseContent = responseContent, 
                self.emit("response", response), self.dests.forEach((function(dest) {
                    self.pipeDest(dest);
                })), responseContent.on("data", (function(chunk) {
                    self.timing && !self.responseStarted && (self.responseStartTime = (new Date).getTime(), 
                    response.responseStartTime = self.responseStartTime), self._destdata = !0, self.emit("data", chunk);
                })), responseContent.once("end", (function(chunk) {
                    self.emit("end", chunk);
                })), responseContent.on("error", (function(error) {
                    self.emit("error", error);
                })), responseContent.on("close", (function() {
                    self.emit("close");
                })), self.callback ? self.readResponseBody(response) : self.on("end", (function() {
                    self._aborted ? debug("aborted", self.uri.href) : self.emit("complete", response);
                })), debug("finish init function", self.uri.href);
            }
        } else {
            debug("strict ssl error", self.uri.href);
            var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self.uri.href + " does not support SSL";
            self.emit("error", new Error("SSL Error: " + sslErr));
        }
    }, Request.prototype.readResponseBody = function(response) {
        var self = this;
        debug("reading response's body");
        var buffers = [], bufferLength = 0, strings = [];
        self.on("data", (function(chunk) {
            Buffer.isBuffer(chunk) ? chunk.length && (bufferLength += chunk.length, buffers.push(chunk)) : strings.push(chunk);
        })), self.on("end", (function() {
            if (debug("end event", self.uri.href), self._aborted) return debug("aborted", self.uri.href), 
            buffers = [], void (bufferLength = 0);
            if (bufferLength ? (debug("has body", self.uri.href, bufferLength), response.body = Buffer.concat(buffers, bufferLength), 
            null !== self.encoding && (response.body = response.body.toString(self.encoding)), 
            buffers = [], bufferLength = 0) : strings.length && ("utf8" === self.encoding && strings[0].length > 0 && "\ufeff" === strings[0][0] && (strings[0] = strings[0].substring(1)), 
            response.body = strings.join("")), self._json) try {
                response.body = JSON.parse(response.body, self._jsonReviver);
            } catch (e) {
                debug("invalid JSON received", self.uri.href);
            }
            debug("emitting complete", self.uri.href), void 0 !== response.body || self._json || (response.body = null === self.encoding ? Buffer.alloc(0) : ""), 
            self.emit("complete", response, response.body);
        }));
    }, Request.prototype.abort = function() {
        this._aborted = !0, this.req ? this.req.abort() : this.response && this.response.destroy(), 
        this.emit("abort");
    }, Request.prototype.pipeDest = function(dest) {
        var response = this.response;
        if (dest.headers && !dest.headersSent) {
            if (response.caseless.has("content-type")) {
                var ctname = response.caseless.has("content-type");
                dest.setHeader ? dest.setHeader(ctname, response.headers[ctname]) : dest.headers[ctname] = response.headers[ctname];
            }
            if (response.caseless.has("content-length")) {
                var clname = response.caseless.has("content-length");
                dest.setHeader ? dest.setHeader(clname, response.headers[clname]) : dest.headers[clname] = response.headers[clname];
            }
        }
        if (dest.setHeader && !dest.headersSent) {
            for (var i in response.headers) this.gzip && "content-encoding" === i || dest.setHeader(i, response.headers[i]);
            dest.statusCode = response.statusCode;
        }
        this.pipefilter && this.pipefilter(response, dest);
    }, Request.prototype.qs = function(q, clobber) {
        var base;
        for (var i in base = !clobber && this.uri.query ? this._qs.parse(this.uri.query) : {}, 
        q) base[i] = q[i];
        var qs = this._qs.stringify(base);
        return "" === qs || (this.uri = url.parse(this.uri.href.split("?")[0] + "?" + qs), 
        this.url = this.uri, this.path = this.uri.path, "unix" === this.uri.host && this.enableUnixSocket()), 
        this;
    }, Request.prototype.form = function(form) {
        var self = this;
        return form ? (/^application\/x-www-form-urlencoded\b/.test(self.getHeader("content-type")) || self.setHeader("content-type", "application/x-www-form-urlencoded"), 
        self.body = "string" == typeof form ? self._qs.rfc3986(form.toString("utf8")) : self._qs.stringify(form).toString("utf8"), 
        self) : (self._form = new FormData, self._form.on("error", (function(err) {
            err.message = "form-data: " + err.message, self.emit("error", err), self.abort();
        })), self._form);
    }, Request.prototype.multipart = function(multipart) {
        return this._multipart.onRequest(multipart), this._multipart.chunked || (this.body = this._multipart.body), 
        this;
    }, Request.prototype.json = function(val) {
        return this.hasHeader("accept") || this.setHeader("accept", "application/json"), 
        "function" == typeof this.jsonReplacer && (this._jsonReplacer = this.jsonReplacer), 
        this._json = !0, "boolean" == typeof val ? void 0 !== this.body && (/^application\/x-www-form-urlencoded\b/.test(this.getHeader("content-type")) ? this.body = this._qs.rfc3986(this.body) : this.body = safeStringify(this.body, this._jsonReplacer), 
        this.hasHeader("content-type") || this.setHeader("content-type", "application/json")) : (this.body = safeStringify(val, this._jsonReplacer), 
        this.hasHeader("content-type") || this.setHeader("content-type", "application/json")), 
        "function" == typeof this.jsonReviver && (this._jsonReviver = this.jsonReviver), 
        this;
    }, Request.prototype.getHeader = function(name, headers) {
        var result, re;
        return headers || (headers = this.headers), Object.keys(headers).forEach((function(key) {
            key.length === name.length && (re = new RegExp(name, "i"), key.match(re) && (result = headers[key]));
        })), result;
    }, Request.prototype.enableUnixSocket = function() {
        var unixParts = this.uri.path.split(":"), host = unixParts[0], path = unixParts[1];
        this.socketPath = host, this.uri.pathname = path, this.uri.path = path, this.uri.host = host, 
        this.uri.hostname = host, this.uri.isUnix = !0;
    }, Request.prototype.auth = function(user, pass, sendImmediately, bearer) {
        return this._auth.onRequest(user, pass, sendImmediately, bearer), this;
    }, Request.prototype.aws = function(opts, now) {
        if (!now) return this._aws = opts, this;
        if (4 === opts.sign_version || "4" === opts.sign_version) {
            var options = {
                host: this.uri.host,
                path: this.uri.path,
                method: this.method,
                headers: this.headers,
                body: this.body
            };
            opts.service && (options.service = opts.service);
            var signRes = aws4.sign(options, {
                accessKeyId: opts.key,
                secretAccessKey: opts.secret,
                sessionToken: opts.session
            });
            this.setHeader("authorization", signRes.headers.Authorization), this.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]), 
            signRes.headers["X-Amz-Security-Token"] && this.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
        } else {
            var date = new Date;
            this.setHeader("date", date.toUTCString());
            var auth = {
                key: opts.key,
                secret: opts.secret,
                verb: this.method.toUpperCase(),
                date: date,
                contentType: this.getHeader("content-type") || "",
                md5: this.getHeader("content-md5") || "",
                amazonHeaders: aws2.canonicalizeHeaders(this.headers)
            }, path = this.uri.path;
            opts.bucket && path ? auth.resource = "/" + opts.bucket + path : opts.bucket && !path ? auth.resource = "/" + opts.bucket : !opts.bucket && path ? auth.resource = path : opts.bucket || path || (auth.resource = "/"), 
            auth.resource = aws2.canonicalizeResource(auth.resource), this.setHeader("authorization", aws2.authorization(auth));
        }
        return this;
    }, Request.prototype.httpSignature = function(opts) {
        var self = this;
        return httpSignature.signRequest({
            getHeader: function(header) {
                return self.getHeader(header, self.headers);
            },
            setHeader: function(header, value) {
                self.setHeader(header, value);
            },
            method: self.method,
            path: self.path
        }, opts), debug("httpSignature authorization", self.getHeader("authorization")), 
        self;
    }, Request.prototype.hawk = function(opts) {
        this.setHeader("Authorization", hawk.header(this.uri, this.method, opts));
    }, Request.prototype.oauth = function(_oauth) {
        return this._oauth.onRequest(_oauth), this;
    }, Request.prototype.jar = function(jar) {
        var cookies;
        if (0 === this._redirect.redirectsFollowed && (this.originalCookieHeader = this.getHeader("cookie")), 
        jar) {
            var targetCookieJar = jar && jar.getCookieString ? jar : globalCookieJar, urihref = this.uri.href;
            targetCookieJar && (cookies = targetCookieJar.getCookieString(urihref));
        } else cookies = !1, this._disableCookies = !0;
        return cookies && cookies.length && (this.originalCookieHeader ? this.setHeader("cookie", this.originalCookieHeader + "; " + cookies) : this.setHeader("cookie", cookies)), 
        this._jar = jar, this;
    }, Request.prototype.pipe = function(dest, opts) {
        if (!this.response) return this.dests.push(dest), stream.Stream.prototype.pipe.call(this, dest, opts), 
        dest;
        if (this._destdata) this.emit("error", new Error("You cannot pipe after data has been emitted from the response.")); else {
            if (!this._ended) return stream.Stream.prototype.pipe.call(this, dest, opts), this.pipeDest(dest), 
            dest;
            this.emit("error", new Error("You cannot pipe after the response has been ended."));
        }
    }, Request.prototype.write = function() {
        var self = this;
        if (!self._aborted) return self._started || self.start(), self.req ? self.req.write.apply(self.req, arguments) : void 0;
    }, Request.prototype.end = function(chunk) {
        this._aborted || (chunk && this.write(chunk), this._started || this.start(), this.req && this.req.end());
    }, Request.prototype.pause = function() {
        var self = this;
        self.responseContent ? self.responseContent.pause.apply(self.responseContent, arguments) : self._paused = !0;
    }, Request.prototype.resume = function() {
        var self = this;
        self.responseContent ? self.responseContent.resume.apply(self.responseContent, arguments) : self._paused = !1;
    }, Request.prototype.destroy = function() {
        this._ended ? this.response && this.response.destroy() : this.end();
    }, Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice(), 
    Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice(), 
    Request.prototype.toJSON = requestToJSON, module.exports = Request;
}, function(module, exports, __webpack_require__) {
    var crypto = __webpack_require__(9), parse = __webpack_require__(7).parse, keys = [ "acl", "location", "logging", "notification", "partNumber", "policy", "requestPayment", "torrent", "uploadId", "uploads", "versionId", "versioning", "versions", "website" ];
    function authorization(options) {
        return "AWS " + options.key + ":" + sign(options);
    }
    function hmacSha1(options) {
        return crypto.createHmac("sha1", options.secret).update(options.message).digest("base64");
    }
    function sign(options) {
        return options.message = stringToSign(options), hmacSha1(options);
    }
    function stringToSign(options) {
        var headers = options.amazonHeaders || "";
        return headers && (headers += "\n"), [ options.verb, options.md5, options.contentType, options.date ? options.date.toUTCString() : "", headers + options.resource ].join("\n");
    }
    function queryStringToSign(options) {
        return "GET\n\n\n" + options.date + "\n" + options.resource;
    }
    module.exports = authorization, module.exports.authorization = authorization, module.exports.hmacSha1 = hmacSha1, 
    module.exports.sign = sign, module.exports.signQuery = function(options) {
        return options.message = queryStringToSign(options), hmacSha1(options);
    }, module.exports.stringToSign = stringToSign, module.exports.queryStringToSign = queryStringToSign, 
    module.exports.canonicalizeHeaders = function(headers) {
        for (var buf = [], fields = Object.keys(headers), i = 0, len = fields.length; i < len; ++i) {
            var field, val = headers[field = fields[i]];
            0 === (field = field.toLowerCase()).indexOf("x-amz") && buf.push(field + ":" + val);
        }
        return buf.sort().join("\n");
    }, module.exports.canonicalizeResource = function(resource) {
        var url = parse(resource, !0), path = url.pathname, buf = [];
        return Object.keys(url.query).forEach((function(key) {
            if (~keys.indexOf(key)) {
                var val = "" == url.query[key] ? "" : "=" + encodeURIComponent(url.query[key]);
                buf.push(key + val);
            }
        })), path + (buf.length ? "?" + buf.sort().join("&") : "");
    };
}, function(module, exports, __webpack_require__) {
    var aws4 = exports, url = __webpack_require__(7), querystring = __webpack_require__(28), crypto = __webpack_require__(9), credentialsCache = __webpack_require__(1049)(1e3);
    function hmac(key, string, encoding) {
        return crypto.createHmac("sha256", key).update(string, "utf8").digest(encoding);
    }
    function hash(string, encoding) {
        return crypto.createHash("sha256").update(string, "utf8").digest(encoding);
    }
    function encodeRfc3986(urlEncodedString) {
        return urlEncodedString.replace(/[!'()*]/g, (function(c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        }));
    }
    function RequestSigner(request, credentials) {
        "string" == typeof request && (request = url.parse(request));
        var headers = request.headers = request.headers || {}, hostParts = this.matchHost(request.hostname || request.host || headers.Host || headers.host);
        this.request = request, this.credentials = credentials || this.defaultCredentials(), 
        this.service = request.service || hostParts[0] || "", this.region = request.region || hostParts[1] || "us-east-1", 
        "email" === this.service && (this.service = "ses"), !request.method && request.body && (request.method = "POST"), 
        headers.Host || headers.host || (headers.Host = request.hostname || request.host || this.createHost(), 
        request.port && (headers.Host += ":" + request.port)), request.hostname || request.host || (request.hostname = headers.Host || headers.host), 
        this.isCodeCommitGit = "codecommit" === this.service && "GIT" === request.method;
    }
    RequestSigner.prototype.matchHost = function(host) {
        var hostParts = ((host || "").match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/) || []).slice(1, 3);
        return "es" === hostParts[1] && (hostParts = hostParts.reverse()), hostParts;
    }, RequestSigner.prototype.isSingleRegion = function() {
        return [ "s3", "sdb" ].indexOf(this.service) >= 0 && "us-east-1" === this.region || [ "cloudfront", "ls", "route53", "iam", "importexport", "sts" ].indexOf(this.service) >= 0;
    }, RequestSigner.prototype.createHost = function() {
        var region = this.isSingleRegion() ? "" : ("s3" === this.service && "us-east-1" !== this.region ? "-" : ".") + this.region;
        return ("ses" === this.service ? "email" : this.service) + region + ".amazonaws.com";
    }, RequestSigner.prototype.prepareRequest = function() {
        this.parsePath();
        var query, request = this.request, headers = request.headers;
        request.signQuery ? (this.parsedPath.query = query = this.parsedPath.query || {}, 
        this.credentials.sessionToken && (query["X-Amz-Security-Token"] = this.credentials.sessionToken), 
        "s3" !== this.service || query["X-Amz-Expires"] || (query["X-Amz-Expires"] = 86400), 
        query["X-Amz-Date"] ? this.datetime = query["X-Amz-Date"] : query["X-Amz-Date"] = this.getDateTime(), 
        query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256", query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString(), 
        query["X-Amz-SignedHeaders"] = this.signedHeaders()) : (request.doNotModifyHeaders || this.isCodeCommitGit || (!request.body || headers["Content-Type"] || headers["content-type"] || (headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8"), 
        !request.body || headers["Content-Length"] || headers["content-length"] || (headers["Content-Length"] = Buffer.byteLength(request.body)), 
        !this.credentials.sessionToken || headers["X-Amz-Security-Token"] || headers["x-amz-security-token"] || (headers["X-Amz-Security-Token"] = this.credentials.sessionToken), 
        "s3" !== this.service || headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || (headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex")), 
        headers["X-Amz-Date"] || headers["x-amz-date"] ? this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"] : headers["X-Amz-Date"] = this.getDateTime()), 
        delete headers.Authorization, delete headers.authorization);
    }, RequestSigner.prototype.sign = function() {
        return this.parsedPath || this.prepareRequest(), this.request.signQuery ? this.parsedPath.query["X-Amz-Signature"] = this.signature() : this.request.headers.Authorization = this.authHeader(), 
        this.request.path = this.formatPath(), this.request;
    }, RequestSigner.prototype.getDateTime = function() {
        if (!this.datetime) {
            var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date);
            this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, ""), this.isCodeCommitGit && (this.datetime = this.datetime.slice(0, -1));
        }
        return this.datetime;
    }, RequestSigner.prototype.getDate = function() {
        return this.getDateTime().substr(0, 8);
    }, RequestSigner.prototype.authHeader = function() {
        return [ "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(), "SignedHeaders=" + this.signedHeaders(), "Signature=" + this.signature() ].join(", ");
    }, RequestSigner.prototype.signature = function() {
        var kDate, kRegion, kService, date = this.getDate(), cacheKey = [ this.credentials.secretAccessKey, date, this.region, this.service ].join(), kCredentials = credentialsCache.get(cacheKey);
        return kCredentials || (kDate = hmac("AWS4" + this.credentials.secretAccessKey, date), 
        kRegion = hmac(kDate, this.region), kService = hmac(kRegion, this.service), kCredentials = hmac(kService, "aws4_request"), 
        credentialsCache.set(cacheKey, kCredentials)), hmac(kCredentials, this.stringToSign(), "hex");
    }, RequestSigner.prototype.stringToSign = function() {
        return [ "AWS4-HMAC-SHA256", this.getDateTime(), this.credentialString(), hash(this.canonicalString(), "hex") ].join("\n");
    }, RequestSigner.prototype.canonicalString = function() {
        this.parsedPath || this.prepareRequest();
        var bodyHash, pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = "s3" !== this.service, decodePath = "s3" === this.service || this.request.doNotEncodePath, decodeSlashesInPath = "s3" === this.service, firstValOnly = "s3" === this.service;
        return bodyHash = "s3" === this.service && this.request.signQuery ? "UNSIGNED-PAYLOAD" : this.isCodeCommitGit ? "" : headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex"), 
        query && (queryStr = encodeRfc3986(querystring.stringify(Object.keys(query).sort().reduce((function(obj, key) {
            return key ? (obj[key] = Array.isArray(query[key]) ? firstValOnly ? query[key][0] : query[key].slice().sort() : query[key], 
            obj) : obj;
        }), {})))), "/" !== pathStr && (normalizePath && (pathStr = pathStr.replace(/\/{2,}/g, "/")), 
        "/" !== (pathStr = pathStr.split("/").reduce((function(path, piece) {
            return normalizePath && ".." === piece ? path.pop() : normalizePath && "." === piece || (decodePath && (piece = decodeURIComponent(piece)), 
            path.push(encodeRfc3986(encodeURIComponent(piece)))), path;
        }), []).join("/"))[0] && (pathStr = "/" + pathStr), decodeSlashesInPath && (pathStr = pathStr.replace(/%2F/g, "/"))), 
        [ this.request.method || "GET", pathStr, queryStr, this.canonicalHeaders() + "\n", this.signedHeaders(), bodyHash ].join("\n");
    }, RequestSigner.prototype.canonicalHeaders = function() {
        var headers = this.request.headers;
        return Object.keys(headers).sort((function(a, b) {
            return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
        })).map((function(key) {
            return key.toLowerCase() + ":" + headers[key].toString().trim().replace(/\s+/g, " ");
        })).join("\n");
    }, RequestSigner.prototype.signedHeaders = function() {
        return Object.keys(this.request.headers).map((function(key) {
            return key.toLowerCase();
        })).sort().join(";");
    }, RequestSigner.prototype.credentialString = function() {
        return [ this.getDate(), this.region, this.service, "aws4_request" ].join("/");
    }, RequestSigner.prototype.defaultCredentials = function() {
        var env = process.env;
        return {
            accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
            secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
            sessionToken: env.AWS_SESSION_TOKEN
        };
    }, RequestSigner.prototype.parsePath = function() {
        var path = this.request.path || "/", queryIx = path.indexOf("?"), query = null;
        queryIx >= 0 && (query = querystring.parse(path.slice(queryIx + 1)), path = path.slice(0, queryIx)), 
        /[^0-9A-Za-z!'()*\-._~%/]/.test(path) && (path = path.split("/").map((function(piece) {
            return encodeURIComponent(decodeURIComponent(piece));
        })).join("/")), this.parsedPath = {
            path: path,
            query: query
        };
    }, RequestSigner.prototype.formatPath = function() {
        var path = this.parsedPath.path, query = this.parsedPath.query;
        return query ? (null != query[""] && delete query[""], path + "?" + encodeRfc3986(querystring.stringify(query))) : path;
    }, aws4.RequestSigner = RequestSigner, aws4.sign = function(request, credentials) {
        return new RequestSigner(request, credentials).sign();
    };
}, function(module, exports) {
    function LruCache(size) {
        this.capacity = 0 | size, this.map = Object.create(null), this.list = new DoublyLinkedList;
    }
    function DoublyLinkedList() {
        this.firstNode = null, this.lastNode = null;
    }
    function DoublyLinkedNode(key, val) {
        this.key = key, this.val = val, this.prev = null, this.next = null;
    }
    module.exports = function(size) {
        return new LruCache(size);
    }, LruCache.prototype.get = function(key) {
        var node = this.map[key];
        if (null != node) return this.used(node), node.val;
    }, LruCache.prototype.set = function(key, val) {
        var node = this.map[key];
        if (null != node) node.val = val; else {
            if (this.capacity || this.prune(), !this.capacity) return !1;
            node = new DoublyLinkedNode(key, val), this.map[key] = node, this.capacity--;
        }
        return this.used(node), !0;
    }, LruCache.prototype.used = function(node) {
        this.list.moveToFront(node);
    }, LruCache.prototype.prune = function() {
        var node = this.list.pop();
        null != node && (delete this.map[node.key], this.capacity++);
    }, DoublyLinkedList.prototype.moveToFront = function(node) {
        this.firstNode != node && (this.remove(node), null == this.firstNode ? (this.firstNode = node, 
        this.lastNode = node, node.prev = null, node.next = null) : (node.prev = null, node.next = this.firstNode, 
        node.next.prev = node, this.firstNode = node));
    }, DoublyLinkedList.prototype.pop = function() {
        var lastNode = this.lastNode;
        return null != lastNode && this.remove(lastNode), lastNode;
    }, DoublyLinkedList.prototype.remove = function(node) {
        this.firstNode == node ? this.firstNode = node.next : null != node.prev && (node.prev.next = node.next), 
        this.lastNode == node ? this.lastNode = node.prev : null != node.next && (node.next.prev = node.prev);
    };
}, function(module, exports, __webpack_require__) {
    var parser = __webpack_require__(1051), signer = __webpack_require__(1059), verify = __webpack_require__(1066), utils = __webpack_require__(150);
    module.exports = {
        parse: parser.parseRequest,
        parseRequest: parser.parseRequest,
        sign: signer.signRequest,
        signRequest: signer.signRequest,
        createSigner: signer.createSigner,
        isSigner: signer.isSigner,
        sshKeyToPEM: utils.sshKeyToPEM,
        sshKeyFingerprint: utils.fingerprint,
        pemToRsaSSHKey: utils.pemToRsaSSHKey,
        verify: verify.verifySignature,
        verifySignature: verify.verifySignature,
        verifyHMAC: verify.verifyHMAC
    };
}, function(module, exports, __webpack_require__) {
    var assert = __webpack_require__(15), util = __webpack_require__(0), utils = __webpack_require__(150), HttpSignatureError = (utils.HASH_ALGOS, 
    utils.PK_ALGOS, utils.HttpSignatureError), InvalidAlgorithmError = utils.InvalidAlgorithmError, validateAlgorithm = utils.validateAlgorithm;
    function ExpiredRequestError(message) {
        HttpSignatureError.call(this, message, ExpiredRequestError);
    }
    function InvalidHeaderError(message) {
        HttpSignatureError.call(this, message, InvalidHeaderError);
    }
    function InvalidParamsError(message) {
        HttpSignatureError.call(this, message, InvalidParamsError);
    }
    function MissingHeaderError(message) {
        HttpSignatureError.call(this, message, MissingHeaderError);
    }
    function StrictParsingError(message) {
        HttpSignatureError.call(this, message, StrictParsingError);
    }
    util.inherits(ExpiredRequestError, HttpSignatureError), util.inherits(InvalidHeaderError, HttpSignatureError), 
    util.inherits(InvalidParamsError, HttpSignatureError), util.inherits(MissingHeaderError, HttpSignatureError), 
    util.inherits(StrictParsingError, HttpSignatureError), module.exports = {
        parseRequest: function(request, options) {
            assert.object(request, "request"), assert.object(request.headers, "request.headers"), 
            void 0 === options && (options = {}), void 0 === options.headers && (options.headers = [ request.headers["x-date"] ? "x-date" : "date" ]), 
            assert.object(options, "options"), assert.arrayOfString(options.headers, "options.headers"), 
            assert.optionalFinite(options.clockSkew, "options.clockSkew");
            var authzHeaderName = options.authorizationHeaderName || "authorization";
            if (!request.headers[authzHeaderName]) throw new MissingHeaderError("no " + authzHeaderName + " header present in the request");
            options.clockSkew = options.clockSkew || 300;
            var date, i = 0, state = 0, substate = 0, tmpName = "", tmpValue = "", parsed = {
                scheme: "",
                params: {},
                signingString: ""
            }, authz = request.headers[authzHeaderName];
            for (i = 0; i < authz.length; i++) {
                var c = authz.charAt(i);
                switch (Number(state)) {
                  case 0:
                    " " !== c ? parsed.scheme += c : state = 1;
                    break;

                  case 1:
                    switch (Number(substate)) {
                      case 0:
                        var code = c.charCodeAt(0);
                        if (code >= 65 && code <= 90 || code >= 97 && code <= 122) tmpName += c; else {
                            if ("=" !== c) throw new InvalidHeaderError("bad param format");
                            if (0 === tmpName.length) throw new InvalidHeaderError("bad param format");
                            substate = 1;
                        }
                        break;

                      case 1:
                        if ('"' !== c) throw new InvalidHeaderError("bad param format");
                        tmpValue = "", substate = 2;
                        break;

                      case 2:
                        '"' === c ? (parsed.params[tmpName] = tmpValue, substate = 3) : tmpValue += c;
                        break;

                      case 3:
                        if ("," !== c) throw new InvalidHeaderError("bad param format");
                        tmpName = "", substate = 0;
                        break;

                      default:
                        throw new Error("Invalid substate");
                    }
                    break;

                  default:
                    throw new Error("Invalid substate");
                }
            }
            if (parsed.params.headers && "" !== parsed.params.headers ? parsed.params.headers = parsed.params.headers.split(" ") : request.headers["x-date"] ? parsed.params.headers = [ "x-date" ] : parsed.params.headers = [ "date" ], 
            !parsed.scheme || "Signature" !== parsed.scheme) throw new InvalidHeaderError('scheme was not "Signature"');
            if (!parsed.params.keyId) throw new InvalidHeaderError("keyId was not specified");
            if (!parsed.params.algorithm) throw new InvalidHeaderError("algorithm was not specified");
            if (!parsed.params.signature) throw new InvalidHeaderError("signature was not specified");
            parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
            try {
                validateAlgorithm(parsed.params.algorithm);
            } catch (e) {
                throw e instanceof InvalidAlgorithmError ? new InvalidParamsError(parsed.params.algorithm + " is not supported") : e;
            }
            for (i = 0; i < parsed.params.headers.length; i++) {
                var h = parsed.params.headers[i].toLowerCase();
                if (parsed.params.headers[i] = h, "request-line" === h) {
                    if (options.strict) throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
                    parsed.signingString += request.method + " " + request.url + " HTTP/" + request.httpVersion;
                } else if ("(request-target)" === h) parsed.signingString += "(request-target): " + request.method.toLowerCase() + " " + request.url; else {
                    var value = request.headers[h];
                    if (void 0 === value) throw new MissingHeaderError(h + " was not in the request");
                    parsed.signingString += h + ": " + value;
                }
                i + 1 < parsed.params.headers.length && (parsed.signingString += "\n");
            }
            if (request.headers.date || request.headers["x-date"]) {
                date = request.headers["x-date"] ? new Date(request.headers["x-date"]) : new Date(request.headers.date);
                var now = new Date, skew = Math.abs(now.getTime() - date.getTime());
                if (skew > 1e3 * options.clockSkew) throw new ExpiredRequestError("clock skew of " + skew / 1e3 + "s was greater than " + options.clockSkew + "s");
            }
            if (options.headers.forEach((function(hdr) {
                if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0) throw new MissingHeaderError(hdr + " was not a signed header");
            })), options.algorithms && -1 === options.algorithms.indexOf(parsed.params.algorithm)) throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
            return parsed.algorithm = parsed.params.algorithm.toUpperCase(), parsed.keyId = parsed.params.keyId, 
            parsed;
        }
    };
}, function(module, exports, __webpack_require__) {
    var errors = __webpack_require__(231), types = __webpack_require__(232), Reader = __webpack_require__(1053), Writer = __webpack_require__(1054);
    for (var t in module.exports = {
        Reader: Reader,
        Writer: Writer
    }, types) types.hasOwnProperty(t) && (module.exports[t] = types[t]);
    for (var e in errors) errors.hasOwnProperty(e) && (module.exports[e] = errors[e]);
}, function(module, exports, __webpack_require__) {
    var assert = __webpack_require__(24), Buffer = __webpack_require__(14).Buffer, ASN1 = __webpack_require__(232), newInvalidAsn1Error = __webpack_require__(231).newInvalidAsn1Error;
    function Reader(data) {
        if (!data || !Buffer.isBuffer(data)) throw new TypeError("data must be a node Buffer");
        this._buf = data, this._size = data.length, this._len = 0, this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
        enumerable: !0,
        get: function() {
            return this._len;
        }
    }), Object.defineProperty(Reader.prototype, "offset", {
        enumerable: !0,
        get: function() {
            return this._offset;
        }
    }), Object.defineProperty(Reader.prototype, "remain", {
        get: function() {
            return this._size - this._offset;
        }
    }), Object.defineProperty(Reader.prototype, "buffer", {
        get: function() {
            return this._buf.slice(this._offset);
        }
    }), Reader.prototype.readByte = function(peek) {
        if (this._size - this._offset < 1) return null;
        var b = 255 & this._buf[this._offset];
        return peek || (this._offset += 1), b;
    }, Reader.prototype.peek = function() {
        return this.readByte(!0);
    }, Reader.prototype.readLength = function(offset) {
        if (void 0 === offset && (offset = this._offset), offset >= this._size) return null;
        var lenB = 255 & this._buf[offset++];
        if (null === lenB) return null;
        if (128 == (128 & lenB)) {
            if (0 == (lenB &= 127)) throw newInvalidAsn1Error("Indefinite length not supported");
            if (lenB > 4) throw newInvalidAsn1Error("encoding too long");
            if (this._size - offset < lenB) return null;
            this._len = 0;
            for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (255 & this._buf[offset++]);
        } else this._len = lenB;
        return offset;
    }, Reader.prototype.readSequence = function(tag) {
        var seq = this.peek();
        if (null === seq) return null;
        if (void 0 !== tag && tag !== seq) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
        var o = this.readLength(this._offset + 1);
        return null === o ? null : (this._offset = o, seq);
    }, Reader.prototype.readInt = function() {
        return this._readTag(ASN1.Integer);
    }, Reader.prototype.readBoolean = function() {
        return 0 !== this._readTag(ASN1.Boolean);
    }, Reader.prototype.readEnumeration = function() {
        return this._readTag(ASN1.Enumeration);
    }, Reader.prototype.readString = function(tag, retbuf) {
        tag || (tag = ASN1.OctetString);
        var b = this.peek();
        if (null === b) return null;
        if (b !== tag) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
        var o = this.readLength(this._offset + 1);
        if (null === o) return null;
        if (this.length > this._size - o) return null;
        if (this._offset = o, 0 === this.length) return retbuf ? Buffer.alloc(0) : "";
        var str = this._buf.slice(this._offset, this._offset + this.length);
        return this._offset += this.length, retbuf ? str : str.toString("utf8");
    }, Reader.prototype.readOID = function(tag) {
        tag || (tag = ASN1.OID);
        var b = this.readString(tag, !0);
        if (null === b) return null;
        for (var values = [], value = 0, i = 0; i < b.length; i++) {
            var byte = 255 & b[i];
            value <<= 7, value += 127 & byte, 0 == (128 & byte) && (values.push(value), value = 0);
        }
        return value = values.shift(), values.unshift(value % 40), values.unshift(value / 40 >> 0), 
        values.join(".");
    }, Reader.prototype._readTag = function(tag) {
        assert.ok(void 0 !== tag);
        var b = this.peek();
        if (null === b) return null;
        if (b !== tag) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
        var o = this.readLength(this._offset + 1);
        if (null === o) return null;
        if (this.length > 4) throw newInvalidAsn1Error("Integer too long: " + this.length);
        if (this.length > this._size - o) return null;
        this._offset = o;
        for (var fb = this._buf[this._offset], value = 0, i = 0; i < this.length; i++) value <<= 8, 
        value |= 255 & this._buf[this._offset++];
        return 128 == (128 & fb) && 4 !== i && (value -= 1 << 8 * i), value >> 0;
    }, module.exports = Reader;
}, function(module, exports, __webpack_require__) {
    var assert = __webpack_require__(24), Buffer = __webpack_require__(14).Buffer, ASN1 = __webpack_require__(232), newInvalidAsn1Error = __webpack_require__(231).newInvalidAsn1Error, DEFAULT_OPTS = {
        size: 1024,
        growthFactor: 8
    };
    function Writer(options) {
        var from, to;
        from = DEFAULT_OPTS, to = options || {}, assert.ok(from), assert.equal(typeof from, "object"), 
        assert.ok(to), assert.equal(typeof to, "object"), Object.getOwnPropertyNames(from).forEach((function(key) {
            if (!to[key]) {
                var value = Object.getOwnPropertyDescriptor(from, key);
                Object.defineProperty(to, key, value);
            }
        })), options = to, this._buf = Buffer.alloc(options.size || 1024), this._size = this._buf.length, 
        this._offset = 0, this._options = options, this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
        get: function() {
            if (this._seq.length) throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
            return this._buf.slice(0, this._offset);
        }
    }), Writer.prototype.writeByte = function(b) {
        if ("number" != typeof b) throw new TypeError("argument must be a Number");
        this._ensure(1), this._buf[this._offset++] = b;
    }, Writer.prototype.writeInt = function(i, tag) {
        if ("number" != typeof i) throw new TypeError("argument must be a Number");
        "number" != typeof tag && (tag = ASN1.Integer);
        for (var sz = 4; (0 == (4286578688 & i) || -8388608 == (4286578688 & i)) && sz > 1; ) sz--, 
        i <<= 8;
        if (sz > 4) throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
        for (this._ensure(2 + sz), this._buf[this._offset++] = tag, this._buf[this._offset++] = sz; sz-- > 0; ) this._buf[this._offset++] = (4278190080 & i) >>> 24, 
        i <<= 8;
    }, Writer.prototype.writeNull = function() {
        this.writeByte(ASN1.Null), this.writeByte(0);
    }, Writer.prototype.writeEnumeration = function(i, tag) {
        if ("number" != typeof i) throw new TypeError("argument must be a Number");
        return "number" != typeof tag && (tag = ASN1.Enumeration), this.writeInt(i, tag);
    }, Writer.prototype.writeBoolean = function(b, tag) {
        if ("boolean" != typeof b) throw new TypeError("argument must be a Boolean");
        "number" != typeof tag && (tag = ASN1.Boolean), this._ensure(3), this._buf[this._offset++] = tag, 
        this._buf[this._offset++] = 1, this._buf[this._offset++] = b ? 255 : 0;
    }, Writer.prototype.writeString = function(s, tag) {
        if ("string" != typeof s) throw new TypeError("argument must be a string (was: " + typeof s + ")");
        "number" != typeof tag && (tag = ASN1.OctetString);
        var len = Buffer.byteLength(s);
        this.writeByte(tag), this.writeLength(len), len && (this._ensure(len), this._buf.write(s, this._offset), 
        this._offset += len);
    }, Writer.prototype.writeBuffer = function(buf, tag) {
        if ("number" != typeof tag) throw new TypeError("tag must be a number");
        if (!Buffer.isBuffer(buf)) throw new TypeError("argument must be a buffer");
        this.writeByte(tag), this.writeLength(buf.length), this._ensure(buf.length), buf.copy(this._buf, this._offset, 0, buf.length), 
        this._offset += buf.length;
    }, Writer.prototype.writeStringArray = function(strings) {
        if (!strings instanceof Array) throw new TypeError("argument must be an Array[String]");
        var self = this;
        strings.forEach((function(s) {
            self.writeString(s);
        }));
    }, Writer.prototype.writeOID = function(s, tag) {
        if ("string" != typeof s) throw new TypeError("argument must be a string");
        if ("number" != typeof tag && (tag = ASN1.OID), !/^([0-9]+\.){3,}[0-9]+$/.test(s)) throw new Error("argument is not a valid OID string");
        var tmp = s.split("."), bytes = [];
        bytes.push(40 * parseInt(tmp[0], 10) + parseInt(tmp[1], 10)), tmp.slice(2).forEach((function(b) {
            !(function(bytes, octet) {
                octet < 128 ? bytes.push(octet) : octet < 16384 ? (bytes.push(octet >>> 7 | 128), 
                bytes.push(127 & octet)) : octet < 2097152 ? (bytes.push(octet >>> 14 | 128), bytes.push(255 & (octet >>> 7 | 128)), 
                bytes.push(127 & octet)) : octet < 268435456 ? (bytes.push(octet >>> 21 | 128), 
                bytes.push(255 & (octet >>> 14 | 128)), bytes.push(255 & (octet >>> 7 | 128)), bytes.push(127 & octet)) : (bytes.push(255 & (octet >>> 28 | 128)), 
                bytes.push(255 & (octet >>> 21 | 128)), bytes.push(255 & (octet >>> 14 | 128)), 
                bytes.push(255 & (octet >>> 7 | 128)), bytes.push(127 & octet));
            })(bytes, parseInt(b, 10));
        }));
        var self = this;
        this._ensure(2 + bytes.length), this.writeByte(tag), this.writeLength(bytes.length), 
        bytes.forEach((function(b) {
            self.writeByte(b);
        }));
    }, Writer.prototype.writeLength = function(len) {
        if ("number" != typeof len) throw new TypeError("argument must be a Number");
        if (this._ensure(4), len <= 127) this._buf[this._offset++] = len; else if (len <= 255) this._buf[this._offset++] = 129, 
        this._buf[this._offset++] = len; else if (len <= 65535) this._buf[this._offset++] = 130, 
        this._buf[this._offset++] = len >> 8, this._buf[this._offset++] = len; else {
            if (!(len <= 16777215)) throw newInvalidAsn1Error("Length too long (> 4 bytes)");
            this._buf[this._offset++] = 131, this._buf[this._offset++] = len >> 16, this._buf[this._offset++] = len >> 8, 
            this._buf[this._offset++] = len;
        }
    }, Writer.prototype.startSequence = function(tag) {
        "number" != typeof tag && (tag = ASN1.Sequence | ASN1.Constructor), this.writeByte(tag), 
        this._seq.push(this._offset), this._ensure(3), this._offset += 3;
    }, Writer.prototype.endSequence = function() {
        var seq = this._seq.pop(), start = seq + 3, len = this._offset - start;
        if (len <= 127) this._shift(start, len, -2), this._buf[seq] = len; else if (len <= 255) this._shift(start, len, -1), 
        this._buf[seq] = 129, this._buf[seq + 1] = len; else if (len <= 65535) this._buf[seq] = 130, 
        this._buf[seq + 1] = len >> 8, this._buf[seq + 2] = len; else {
            if (!(len <= 16777215)) throw newInvalidAsn1Error("Sequence too long");
            this._shift(start, len, 1), this._buf[seq] = 131, this._buf[seq + 1] = len >> 16, 
            this._buf[seq + 2] = len >> 8, this._buf[seq + 3] = len;
        }
    }, Writer.prototype._shift = function(start, len, shift) {
        assert.ok(void 0 !== start), assert.ok(void 0 !== len), assert.ok(shift), this._buf.copy(this._buf, start + shift, start, start + len), 
        this._offset += shift;
    }, Writer.prototype._ensure = function(len) {
        if (assert.ok(len), this._size - this._offset < len) {
            var sz = this._size * this._options.growthFactor;
            sz - this._offset < len && (sz += len);
            var buf = Buffer.alloc(sz);
            this._buf.copy(buf, 0, 0, this._offset), this._buf = buf, this._size = sz;
        }
    }, module.exports = Writer;
}, function(module, exports, __webpack_require__) {
    var crypto = __webpack_require__(9), BigInteger = __webpack_require__(98).BigInteger, Buffer = (__webpack_require__(151).ECPointFp, 
    __webpack_require__(14).Buffer);
    function unstupid(hex, len) {
        return hex.length >= len ? hex : unstupid("0" + hex, len);
    }
    exports.ECCurves = __webpack_require__(1056), exports.ECKey = function(curve, key, isPublic) {
        var priv, c = curve(), n = c.getN(), bytes = Math.floor(n.bitLength() / 8);
        if (key) if (isPublic) curve = c.getCurve(), this.P = curve.decodePointHex(key.toString("hex")); else {
            if (key.length != bytes) return !1;
            priv = new BigInteger(key.toString("hex"), 16);
        } else {
            var n1 = n.subtract(BigInteger.ONE), r = new BigInteger(crypto.randomBytes(n.bitLength()));
            priv = r.mod(n1).add(BigInteger.ONE), this.P = c.getG().multiply(priv);
        }
        this.P && (this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P), "hex")), 
        priv && (this.PrivateKey = Buffer.from(unstupid(priv.toString(16), 2 * bytes), "hex"), 
        this.deriveSharedSecret = function(key) {
            if (!key || !key.P) return !1;
            var S = key.P.multiply(priv);
            return Buffer.from(unstupid(S.getX().toBigInteger().toString(16), 2 * bytes), "hex");
        });
    };
}, function(module, exports, __webpack_require__) {
    var BigInteger = __webpack_require__(98).BigInteger, ECCurveFp = __webpack_require__(151).ECCurveFp;
    function X9ECParameters(curve, g, n, h) {
        this.curve = curve, this.g = g, this.n = n, this.h = h;
    }
    function fromHex(s) {
        return new BigInteger(s, 16);
    }
    X9ECParameters.prototype.getCurve = function() {
        return this.curve;
    }, X9ECParameters.prototype.getG = function() {
        return this.g;
    }, X9ECParameters.prototype.getN = function() {
        return this.n;
    }, X9ECParameters.prototype.getH = function() {
        return this.h;
    }, module.exports = {
        secp128r1: function() {
            var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF"), a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC"), b = fromHex("E87579C11079F43DD824993C2CEE5ED3"), n = fromHex("FFFFFFFE0000000075A30D1B9038A115"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83");
            return new X9ECParameters(curve, G, n, h);
        },
        secp160k1: function() {
            var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73"), a = BigInteger.ZERO, b = fromHex("7"), n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE");
            return new X9ECParameters(curve, G, n, h);
        },
        secp160r1: function() {
            var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF"), a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC"), b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45"), n = fromHex("0100000000000000000001F4C8F927AED3CA752257"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32");
            return new X9ECParameters(curve, G, n, h);
        },
        secp192k1: function() {
            var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37"), a = BigInteger.ZERO, b = fromHex("3"), n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
            return new X9ECParameters(curve, G, n, h);
        },
        secp192r1: function() {
            var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF"), a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC"), b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1"), n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
            return new X9ECParameters(curve, G, n, h);
        },
        secp224r1: function() {
            var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001"), a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE"), b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4"), n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
            return new X9ECParameters(curve, G, n, h);
        },
        secp256r1: function() {
            var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF"), a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC"), b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B"), n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551"), h = BigInteger.ONE, curve = new ECCurveFp(p, a, b), G = curve.decodePointHex("046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
            return new X9ECParameters(curve, G, n, h);
        }
    };
}, function(module, exports, __webpack_require__) {
    module.exports = {
        read: function(buf, options) {
            Buffer.isBuffer(buf) && (buf = buf.toString("ascii"));
            var parts = buf.trim().split(/[ \t\n]+/g);
            if (parts.length < 2 || parts.length > 3) throw new Error("Not a valid SSH certificate line");
            var algo = parts[0], data = parts[1];
            return fromBuffer(data = Buffer.from(data, "base64"), algo);
        },
        verify: function(cert, key) {
            return !1;
        },
        sign: function(cert, key) {
            void 0 === cert.signatures.openssh && (cert.signatures.openssh = {});
            try {
                var blob = toBuffer(cert, !0);
            } catch (e) {
                return delete cert.signatures.openssh, !1;
            }
            var sig = cert.signatures.openssh, hashAlgo = void 0;
            "rsa" !== key.type && "dsa" !== key.type || (hashAlgo = "sha1");
            var signer = key.createSign(hashAlgo);
            return signer.write(blob), sig.signature = signer.sign(), !0;
        },
        signAsync: function(cert, signer, done) {
            void 0 === cert.signatures.openssh && (cert.signatures.openssh = {});
            try {
                var blob = toBuffer(cert, !0);
            } catch (e) {
                return delete cert.signatures.openssh, void done(e);
            }
            var sig = cert.signatures.openssh;
            signer(blob, (function(err, signature) {
                if (err) done(err); else {
                    try {
                        signature.toBuffer("ssh");
                    } catch (e) {
                        return void done(e);
                    }
                    sig.signature = signature, done();
                }
            }));
        },
        write: function(cert, options) {
            void 0 === options && (options = {});
            var blob = toBuffer(cert), out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
            return options.comment && (out = out + " " + options.comment), out;
        },
        fromBuffer: fromBuffer,
        toBuffer: toBuffer
    };
    var assert = __webpack_require__(15), SSHBuffer = __webpack_require__(100), crypto = __webpack_require__(9), Buffer = __webpack_require__(14).Buffer, algs = __webpack_require__(30), Key = __webpack_require__(25), Identity = (__webpack_require__(27), 
    __webpack_require__(103)), rfc4253 = __webpack_require__(57), Signature = __webpack_require__(48), utils = __webpack_require__(26), Certificate = __webpack_require__(102), TYPES = {
        user: 1,
        host: 2
    };
    Object.keys(TYPES).forEach((function(k) {
        TYPES[TYPES[k]] = k;
    }));
    var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
    function fromBuffer(data, algo, partial) {
        var sshbuf = new SSHBuffer({
            buffer: data
        }), innerAlgo = sshbuf.readString();
        if (void 0 !== algo && innerAlgo !== algo) throw new Error("SSH certificate algorithm mismatch");
        void 0 === algo && (algo = innerAlgo);
        var cert = {
            signatures: {}
        };
        cert.signatures.openssh = {}, cert.signatures.openssh.nonce = sshbuf.readBuffer();
        var key = {}, parts = key.parts = [];
        key.type = (function(certType) {
            if ("ssh-rsa-cert-v01@openssh.com" === certType) return "rsa";
            if ("ssh-dss-cert-v01@openssh.com" === certType) return "dsa";
            if (certType.match(ECDSA_ALGO)) return "ecdsa";
            if ("ssh-ed25519-cert-v01@openssh.com" === certType) return "ed25519";
            throw new Error("Unsupported cert type " + certType);
        })(algo);
        for (var partCount = algs.info[key.type].parts.length; parts.length < partCount; ) parts.push(sshbuf.readPart());
        assert.ok(parts.length >= 1, "key must have at least one part");
        var algInfo = algs.info[key.type];
        if ("ecdsa" === key.type) {
            var res = ECDSA_ALGO.exec(algo);
            assert.ok(null !== res), assert.strictEqual(res[1], parts[0].data.toString());
        }
        for (var i = 0; i < algInfo.parts.length; ++i) if (parts[i].name = algInfo.parts[i], 
        "curve" !== parts[i].name && !1 !== algInfo.normalize) {
            var p = parts[i];
            p.data = utils.mpNormalize(p.data);
        }
        cert.subjectKey = new Key(key), cert.serial = sshbuf.readInt64();
        var type = TYPES[sshbuf.readInt()];
        assert.string(type, "valid cert type"), cert.signatures.openssh.keyId = sshbuf.readString();
        for (var principals = [], pbuf = sshbuf.readBuffer(), psshbuf = new SSHBuffer({
            buffer: pbuf
        }); !psshbuf.atEnd(); ) principals.push(psshbuf.readString());
        0 === principals.length && (principals = [ "*" ]), cert.subjects = principals.map((function(pr) {
            if ("user" === type) return Identity.forUser(pr);
            if ("host" === type) return Identity.forHost(pr);
            throw new Error("Unknown identity type " + type);
        })), cert.validFrom = int64ToDate(sshbuf.readInt64()), cert.validUntil = int64ToDate(sshbuf.readInt64());
        for (var ext, exts = [], extbuf = new SSHBuffer({
            buffer: sshbuf.readBuffer()
        }); !extbuf.atEnd(); ) (ext = {
            critical: !0
        }).name = extbuf.readString(), ext.data = extbuf.readBuffer(), exts.push(ext);
        for (extbuf = new SSHBuffer({
            buffer: sshbuf.readBuffer()
        }); !extbuf.atEnd(); ) (ext = {
            critical: !1
        }).name = extbuf.readString(), ext.data = extbuf.readBuffer(), exts.push(ext);
        cert.signatures.openssh.exts = exts, sshbuf.readBuffer();
        var signingKeyBuf = sshbuf.readBuffer();
        cert.issuerKey = rfc4253.read(signingKeyBuf), cert.issuer = Identity.forHost("**");
        var sigBuf = sshbuf.readBuffer();
        return cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh"), 
        void 0 !== partial && (partial.remainder = sshbuf.remainder(), partial.consumed = sshbuf._offset), 
        new Certificate(cert);
    }
    function int64ToDate(buf) {
        var i = 4294967296 * buf.readUInt32BE(0);
        i += buf.readUInt32BE(4);
        var d = new Date;
        return d.setTime(1e3 * i), d.sourceInt64 = buf, d;
    }
    function dateToInt64(date) {
        if (void 0 !== date.sourceInt64) return date.sourceInt64;
        var i = Math.round(date.getTime() / 1e3), upper = Math.floor(i / 4294967296), lower = Math.floor(i % 4294967296), buf = Buffer.alloc(8);
        return buf.writeUInt32BE(upper, 0), buf.writeUInt32BE(lower, 4), buf;
    }
    function toBuffer(cert, noSig) {
        assert.object(cert.signatures.openssh, "signature for openssh format");
        var sig = cert.signatures.openssh;
        void 0 === sig.nonce && (sig.nonce = crypto.randomBytes(16));
        var buf = new SSHBuffer({});
        buf.writeString(getCertType(cert.subjectKey)), buf.writeBuffer(sig.nonce);
        var key = cert.subjectKey;
        algs.info[key.type].parts.forEach((function(part) {
            buf.writePart(key.part[part]);
        })), buf.writeInt64(cert.serial);
        var type = cert.subjects[0].type;
        assert.notStrictEqual(type, "unknown"), cert.subjects.forEach((function(id) {
            assert.strictEqual(id.type, type);
        })), type = TYPES[type], buf.writeInt(type), void 0 === sig.keyId && (sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname)), 
        buf.writeString(sig.keyId);
        var sub = new SSHBuffer({});
        cert.subjects.forEach((function(id) {
            type === TYPES.host ? sub.writeString(id.hostname) : type === TYPES.user && sub.writeString(id.uid);
        })), buf.writeBuffer(sub.toBuffer()), buf.writeInt64(dateToInt64(cert.validFrom)), 
        buf.writeInt64(dateToInt64(cert.validUntil));
        var exts = sig.exts;
        void 0 === exts && (exts = []);
        var extbuf = new SSHBuffer({});
        return exts.forEach((function(ext) {
            !0 === ext.critical && (extbuf.writeString(ext.name), extbuf.writeBuffer(ext.data));
        })), buf.writeBuffer(extbuf.toBuffer()), extbuf = new SSHBuffer({}), exts.forEach((function(ext) {
            !0 !== ext.critical && (extbuf.writeString(ext.name), extbuf.writeBuffer(ext.data));
        })), buf.writeBuffer(extbuf.toBuffer()), buf.writeBuffer(Buffer.alloc(0)), sub = rfc4253.write(cert.issuerKey), 
        buf.writeBuffer(sub), noSig || buf.writeBuffer(sig.signature.toBuffer("ssh")), buf.toBuffer();
    }
    function getCertType(key) {
        if ("rsa" === key.type) return "ssh-rsa-cert-v01@openssh.com";
        if ("dsa" === key.type) return "ssh-dss-cert-v01@openssh.com";
        if ("ecdsa" === key.type) return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
        if ("ed25519" === key.type) return "ssh-ed25519-cert-v01@openssh.com";
        throw new Error("Unsupported key type " + key.type);
    }
}, function(module, exports, __webpack_require__) {
    var x509 = __webpack_require__(484);
    module.exports = {
        read: function(buf, options) {
            "string" != typeof buf && (assert.buffer(buf, "buf"), buf = buf.toString("ascii"));
            for (var m, m2, lines = buf.trim().split(/[\r\n]+/g), si = -1; !m && si < lines.length; ) m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
            assert.ok(m, "invalid PEM header");
            for (var ei = lines.length; !m2 && ei > 0; ) m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
            assert.ok(m2, "invalid PEM footer"), lines = lines.slice(si, ei + 1);
            for (var headers = {}; m = (lines = lines.slice(1))[0].match(/^([A-Za-z0-9-]+): (.+)$/); ) headers[m[1].toLowerCase()] = m[2];
            return lines = lines.slice(0, -1).join(""), buf = Buffer.from(lines, "base64"), 
            x509.read(buf, options);
        },
        verify: x509.verify,
        sign: x509.sign,
        write: function(cert, options) {
            var tmp = x509.write(cert, options).toString("base64"), len = tmp.length + tmp.length / 64 + 18 + 16 + 2 * "CERTIFICATE".length + 10, buf = Buffer.alloc(len), o = 0;
            o += buf.write("-----BEGIN CERTIFICATE-----\n", o);
            for (var i = 0; i < tmp.length; ) {
                var limit = i + 64;
                limit > tmp.length && (limit = tmp.length), o += buf.write(tmp.slice(i, limit), o), 
                buf[o++] = 10, i = limit;
            }
            return o += buf.write("-----END CERTIFICATE-----\n", o), buf.slice(0, o);
        }
    };
    var assert = __webpack_require__(15), Buffer = (__webpack_require__(49), __webpack_require__(14).Buffer);
    __webpack_require__(30), __webpack_require__(26), __webpack_require__(25), __webpack_require__(27), 
    __webpack_require__(56), __webpack_require__(103), __webpack_require__(48), __webpack_require__(102);
}, function(module, exports, __webpack_require__) {
    var assert = __webpack_require__(15), crypto = __webpack_require__(9), util = (__webpack_require__(11), 
    __webpack_require__(0)), sshpk = __webpack_require__(230), jsprim = __webpack_require__(1060), utils = __webpack_require__(150), sprintf = __webpack_require__(0).format, HASH_ALGOS = utils.HASH_ALGOS, PK_ALGOS = utils.PK_ALGOS, InvalidAlgorithmError = utils.InvalidAlgorithmError, HttpSignatureError = utils.HttpSignatureError, validateAlgorithm = utils.validateAlgorithm, AUTHZ_FMT = 'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
    function MissingHeaderError(message) {
        HttpSignatureError.call(this, message, MissingHeaderError);
    }
    function StrictParsingError(message) {
        HttpSignatureError.call(this, message, StrictParsingError);
    }
    function RequestSigner(options) {
        assert.object(options, "options");
        var alg = [];
        if (void 0 !== options.algorithm && (assert.string(options.algorithm, "options.algorithm"), 
        alg = validateAlgorithm(options.algorithm)), this.rs_alg = alg, void 0 !== options.sign) assert.func(options.sign, "options.sign"), 
        this.rs_signFunc = options.sign; else if ("hmac" === alg[0] && void 0 !== options.key) {
            if (assert.string(options.keyId, "options.keyId"), this.rs_keyId = options.keyId, 
            "string" != typeof options.key && !Buffer.isBuffer(options.key)) throw new TypeError("options.key for HMAC must be a string or Buffer");
            this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key), this.rs_signer.sign = function() {
                var digest = this.digest("base64");
                return {
                    hashAlgorithm: alg[1],
                    toString: function() {
                        return digest;
                    }
                };
            };
        } else {
            if (void 0 === options.key) throw new TypeError("options.sign (func) or options.key is required");
            var key = options.key;
            if (("string" == typeof key || Buffer.isBuffer(key)) && (key = sshpk.parsePrivateKey(key)), 
            assert.ok(sshpk.PrivateKey.isPrivateKey(key, [ 1, 2 ]), "options.key must be a sshpk.PrivateKey"), 
            this.rs_key = key, assert.string(options.keyId, "options.keyId"), this.rs_keyId = options.keyId, 
            !PK_ALGOS[key.type]) throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
            if (void 0 !== alg[0] && key.type !== alg[0]) throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
            this.rs_signer = key.createSign(alg[1]);
        }
        this.rs_headers = [], this.rs_lines = [];
    }
    util.inherits(MissingHeaderError, HttpSignatureError), util.inherits(StrictParsingError, HttpSignatureError), 
    RequestSigner.prototype.writeHeader = function(header, value) {
        if (assert.string(header, "header"), header = header.toLowerCase(), assert.string(value, "value"), 
        this.rs_headers.push(header), this.rs_signFunc) this.rs_lines.push(header + ": " + value); else {
            var line = header + ": " + value;
            this.rs_headers.length > 0 && (line = "\n" + line), this.rs_signer.update(line);
        }
        return value;
    }, RequestSigner.prototype.writeDateHeader = function() {
        return this.writeHeader("date", jsprim.rfc1123(new Date));
    }, RequestSigner.prototype.writeTarget = function(method, path) {
        assert.string(method, "method"), assert.string(path, "path"), method = method.toLowerCase(), 
        this.writeHeader("(request-target)", method + " " + path);
    }, RequestSigner.prototype.sign = function(cb) {
        if (assert.func(cb, "callback"), this.rs_headers.length < 1) throw new Error("At least one header must be signed");
        var alg, authz;
        if (this.rs_signFunc) {
            var data = this.rs_lines.join("\n"), self = this;
            this.rs_signFunc(data, (function(err, sig) {
                if (err) cb(err); else {
                    try {
                        assert.object(sig, "signature"), assert.string(sig.keyId, "signature.keyId"), assert.string(sig.algorithm, "signature.algorithm"), 
                        assert.string(sig.signature, "signature.signature"), alg = validateAlgorithm(sig.algorithm), 
                        authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self.rs_headers.join(" "), sig.signature);
                    } catch (e) {
                        return void cb(e);
                    }
                    cb(null, authz);
                }
            }));
        } else {
            try {
                var sigObj = this.rs_signer.sign();
            } catch (e) {
                return void cb(e);
            }
            alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
            var signature = sigObj.toString();
            authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(" "), signature), 
            cb(null, authz);
        }
    }, module.exports = {
        isSigner: function(obj) {
            return "object" == typeof obj && obj instanceof RequestSigner;
        },
        createSigner: function(options) {
            return new RequestSigner(options);
        },
        signRequest: function(request, options) {
            assert.object(request, "request"), assert.object(options, "options"), assert.optionalString(options.algorithm, "options.algorithm"), 
            assert.string(options.keyId, "options.keyId"), assert.optionalArrayOfString(options.headers, "options.headers"), 
            assert.optionalString(options.httpVersion, "options.httpVersion"), request.getHeader("Date") || request.setHeader("Date", jsprim.rfc1123(new Date)), 
            options.headers || (options.headers = [ "date" ]), options.httpVersion || (options.httpVersion = "1.1");
            var i, alg = [];
            options.algorithm && (options.algorithm = options.algorithm.toLowerCase(), alg = validateAlgorithm(options.algorithm));
            var signature, stringToSign = "";
            for (i = 0; i < options.headers.length; i++) {
                if ("string" != typeof options.headers[i]) throw new TypeError("options.headers must be an array of Strings");
                var h = options.headers[i].toLowerCase();
                if ("request-line" === h) {
                    if (options.strict) throw new StrictParsingError("request-line is not a valid header with strict parsing enabled.");
                    stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion;
                } else if ("(request-target)" === h) stringToSign += "(request-target): " + request.method.toLowerCase() + " " + request.path; else {
                    var value = request.getHeader(h);
                    if (void 0 === value || "" === value) throw new MissingHeaderError(h + " was not in the request");
                    stringToSign += h + ": " + value;
                }
                i + 1 < options.headers.length && (stringToSign += "\n");
            }
            if (request.hasOwnProperty("_stringToSign") && (request._stringToSign = stringToSign), 
            "hmac" === alg[0]) {
                if ("string" != typeof options.key && !Buffer.isBuffer(options.key)) throw new TypeError("options.key must be a string or Buffer");
                var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
                hmac.update(stringToSign), signature = hmac.digest("base64");
            } else {
                var key = options.key;
                if (("string" == typeof key || Buffer.isBuffer(key)) && (key = sshpk.parsePrivateKey(options.key)), 
                assert.ok(sshpk.PrivateKey.isPrivateKey(key, [ 1, 2 ]), "options.key must be a sshpk.PrivateKey"), 
                !PK_ALGOS[key.type]) throw new InvalidAlgorithmError(key.type.toUpperCase() + " type keys are not supported");
                if (void 0 !== alg[0] && key.type !== alg[0]) throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
                var signer = key.createSign(alg[1]);
                signer.update(stringToSign);
                var sigObj = signer.sign();
                if (!HASH_ALGOS[sigObj.hashAlgorithm]) throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
                options.algorithm = key.type + "-" + sigObj.hashAlgorithm, signature = sigObj.toString(), 
                assert.notStrictEqual(signature, "", "empty signature produced");
            }
            var authzHeaderName = options.authorizationHeaderName || "Authorization";
            return request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(" "), signature)), 
            !0;
        }
    };
}, function(module, exports, __webpack_require__) {
    var mod_assert = __webpack_require__(15), mod_extsprintf = (__webpack_require__(0), 
    __webpack_require__(1061)), mod_verror = __webpack_require__(1062), mod_jsonschema = __webpack_require__(1065);
    function hasKey(obj, key) {
        return mod_assert.equal(typeof key, "string"), Object.prototype.hasOwnProperty.call(obj, key);
    }
    function pluckv(obj, key) {
        if (null !== obj && "object" == typeof obj) {
            if (obj.hasOwnProperty(key)) return obj[key];
            var i = key.indexOf(".");
            if (-1 != i) {
                var key1 = key.substr(0, i);
                if (obj.hasOwnProperty(key1)) return pluckv(obj[key1], key.substr(i + 1));
            }
        }
    }
    function doFlattenIter(data, depth, accum, callback) {
        var each, key;
        if (0 === depth) return (each = accum.slice(0)).push(data), void callback(each);
        for (key in mod_assert.ok(null !== data), mod_assert.equal(typeof data, "object"), 
        mod_assert.equal(typeof depth, "number"), mod_assert.ok(depth >= 0), data) (each = accum.slice(0)).push(key), 
        doFlattenIter(data[key], depth - 1, each, callback);
    }
    exports.deepCopy = function deepCopy(obj) {
        var ret, key, marker = "__deepCopy";
        if (obj && obj[marker]) throw new Error("attempted deep copy of cyclic object");
        if (obj && obj.constructor == Object) {
            for (key in ret = {}, obj[marker] = !0, obj) key != marker && (ret[key] = deepCopy(obj[key]));
            return delete obj[marker], ret;
        }
        if (obj && obj.constructor == Array) {
            for (ret = [], obj[marker] = !0, key = 0; key < obj.length; key++) ret.push(deepCopy(obj[key]));
            return delete obj[marker], ret;
        }
        return obj;
    }, exports.deepEqual = function deepEqual(obj1, obj2) {
        if (typeof obj1 != typeof obj2) return !1;
        if (null === obj1 || null === obj2 || "object" != typeof obj1) return obj1 === obj2;
        if (obj1.constructor != obj2.constructor) return !1;
        var k;
        for (k in obj1) {
            if (!obj2.hasOwnProperty(k)) return !1;
            if (!deepEqual(obj1[k], obj2[k])) return !1;
        }
        for (k in obj2) if (!obj1.hasOwnProperty(k)) return !1;
        return !0;
    }, exports.isEmpty = function(obj) {
        var key;
        for (key in obj) return !1;
        return !0;
    }, exports.hasKey = hasKey, exports.forEachKey = function(obj, callback) {
        for (var key in obj) hasKey(obj, key) && callback(key, obj[key]);
    }, exports.pluck = function(obj, key) {
        return mod_assert.equal(typeof key, "string"), pluckv(obj, key);
    }, exports.flattenObject = function flattenObject(data, depth) {
        if (0 === depth) return [ data ];
        mod_assert.ok(null !== data), mod_assert.equal(typeof data, "object"), mod_assert.equal(typeof depth, "number"), 
        mod_assert.ok(depth >= 0);
        var key, rv = [];
        for (key in data) flattenObject(data[key], depth - 1).forEach((function(p) {
            rv.push([ key ].concat(p));
        }));
        return rv;
    }, exports.flattenIter = function(data, depth, callback) {
        doFlattenIter(data, depth, [], callback);
    }, exports.validateJsonObject = validateJsonObjectJS, exports.validateJsonObjectJS = validateJsonObjectJS, 
    exports.randElt = function(arr) {
        return mod_assert.ok(Array.isArray(arr) && arr.length > 0, "randElt argument must be a non-empty array"), 
        arr[Math.floor(Math.random() * arr.length)];
    }, exports.extraProperties = function(obj, allowed) {
        mod_assert.ok("object" == typeof obj && null !== obj, "obj argument must be a non-null object"), 
        mod_assert.ok(Array.isArray(allowed), "allowed argument must be an array of strings");
        for (var i = 0; i < allowed.length; i++) mod_assert.ok("string" == typeof allowed[i], "allowed argument must be an array of strings");
        return Object.keys(obj).filter((function(key) {
            return -1 === allowed.indexOf(key);
        }));
    }, exports.mergeObjects = mergeObjects, exports.startsWith = function(str, prefix) {
        return str.substr(0, prefix.length) == prefix;
    }, exports.endsWith = function(str, suffix) {
        return str.substr(str.length - suffix.length, suffix.length) == suffix;
    }, exports.parseInteger = function(str, uopts) {
        mod_assert.string(str, "str"), mod_assert.optionalObject(uopts, "options");
        var c, baseOverride = !1, options = PI_DEFAULTS;
        uopts && (baseOverride = hasKey(uopts, "base"), options = mergeObjects(options, uopts), 
        mod_assert.number(options.base, "options.base"), mod_assert.ok(options.base >= 2, "options.base >= 2"), 
        mod_assert.ok(options.base <= 36, "options.base <= 36"), mod_assert.bool(options.allowSign, "options.allowSign"), 
        mod_assert.bool(options.allowPrefix, "options.allowPrefix"), mod_assert.bool(options.allowTrailing, "options.allowTrailing"), 
        mod_assert.bool(options.allowImprecise, "options.allowImprecise"), mod_assert.bool(options.trimWhitespace, "options.trimWhitespace"), 
        mod_assert.bool(options.leadingZeroIsOctal, "options.leadingZeroIsOctal"), options.leadingZeroIsOctal && mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are mutually exclusive'));
        var start, d, pbase = -1, base = options.base, mult = 1, value = 0, idx = 0, len = str.length;
        if (options.trimWhitespace) for (;idx < len && isSpace(str.charCodeAt(idx)); ) ++idx;
        for (options.allowSign && ("-" === str[idx] ? (idx += 1, mult = -1) : "+" === str[idx] && (idx += 1)), 
        "0" === str[idx] && (options.allowPrefix && (pbase = (function(c) {
            return 98 === c || 66 === c ? 2 : 111 === c || 79 === c ? 8 : 116 === c || 84 === c ? 10 : 120 === c || 88 === c ? 16 : -1;
        })(str.charCodeAt(idx + 1)), -1 === pbase || baseOverride && pbase !== base || (base = pbase, 
        idx += 2)), -1 === pbase && options.leadingZeroIsOctal && (base = 8)), start = idx; idx < len && -1 != (c = (d = str.charCodeAt(idx)) >= 48 && d <= 57 ? d - 48 : d >= 65 && d <= 90 ? d - 55 : d >= 97 && d <= 122 ? d - 87 : -1) && c < base; ++idx) value *= base, 
        value += c;
        if (start === idx) return new Error("invalid number: " + JSON.stringify(str));
        if (options.trimWhitespace) for (;idx < len && isSpace(str.charCodeAt(idx)); ) ++idx;
        if (idx < len && !options.allowTrailing) return new Error("trailing characters after number: " + JSON.stringify(str.slice(idx)));
        if (0 === value) return 0;
        var result = value * mult;
        return !options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER) ? new Error("number is outside of the supported range: " + JSON.stringify(str.slice(start, idx))) : result;
    }, exports.iso8601 = function(d) {
        return "number" == typeof d && (d = new Date(d)), mod_assert.ok(d.constructor === Date), 
        mod_extsprintf.sprintf("%4d-%02d-%02dT%02d:%02d:%02d.%03dZ", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
    }, exports.rfc1123 = function(date) {
        return mod_extsprintf.sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
    }, exports.parseDateTime = function(str) {
        var numeric = +str;
        return isNaN(numeric) ? new Date(str) : new Date(numeric);
    }, exports.hrtimediff = hrtimeDiff, exports.hrtimeDiff = hrtimeDiff, exports.hrtimeAccum = hrtimeAccum, 
    exports.hrtimeAdd = function(a, b) {
        return assertHrtime(a), hrtimeAccum([ a[0], a[1] ], b);
    }, exports.hrtimeNanosec = function(a) {
        return assertHrtime(a), Math.floor(1e9 * a[0] + a[1]);
    }, exports.hrtimeMicrosec = function(a) {
        return assertHrtime(a), Math.floor(1e6 * a[0] + a[1] / 1e3);
    }, exports.hrtimeMillisec = function(a) {
        return assertHrtime(a), Math.floor(1e3 * a[0] + a[1] / 1e6);
    };
    var RFC1123_MONTHS = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], RFC1123_DAYS = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991, PI_DEFAULTS = {
        base: 10,
        allowSign: !0,
        allowPrefix: !1,
        allowTrailing: !1,
        allowImprecise: !1,
        trimWhitespace: !1,
        leadingZeroIsOctal: !1
    };
    function isSpace(c) {
        return 32 === c || c >= 9 && c <= 13 || 160 === c || 5760 === c || 6158 === c || c >= 8192 && c <= 8202 || 8232 === c || 8233 === c || 8239 === c || 8287 === c || 12288 === c || 65279 === c;
    }
    function validateJsonObjectJS(schema, input) {
        var report = mod_jsonschema.validate(input, schema);
        if (0 === report.errors.length) return null;
        var i, j, error = report.errors[0], propname = error.property, reason = error.message.toLowerCase();
        -1 != (i = reason.indexOf("the property ")) && -1 != (j = reason.indexOf(" is not defined in the schema and the schema does not allow additional properties")) && (i += "the property ".length, 
        propname = "" === propname ? reason.substr(i, j - i) : propname + "." + reason.substr(i, j - i), 
        reason = "unsupported property");
        var rv = new mod_verror.VError('property "%s": %s', propname, reason);
        return rv.jsv_details = error, rv;
    }
    function assertHrtime(a) {
        mod_assert.ok(a[0] >= 0 && a[1] >= 0, "negative numbers not allowed in hrtimes"), 
        mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
    }
    function hrtimeDiff(a, b) {
        assertHrtime(a), assertHrtime(b), mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], "negative differences not allowed");
        var rv = [ a[0] - b[0], 0 ];
        return a[1] >= b[1] ? rv[1] = a[1] - b[1] : (rv[0]--, rv[1] = 1e9 - (b[1] - a[1])), 
        rv;
    }
    function hrtimeAccum(a, b) {
        return assertHrtime(a), assertHrtime(b), a[1] += b[1], a[1] >= 1e9 && (a[0]++, a[1] -= 1e9), 
        a[0] += b[0], a;
    }
    function mergeObjects(provided, overrides, defaults) {
        var rv, k;
        if (rv = {}, defaults) for (k in defaults) rv[k] = defaults[k];
        if (provided) for (k in provided) rv[k] = provided[k];
        if (overrides) for (k in overrides) rv[k] = overrides[k];
        return rv;
    }
}, function(module, exports, __webpack_require__) {
    var mod_assert = __webpack_require__(24), mod_util = __webpack_require__(0);
    function jsSprintf(fmt) {
        var flags, width, precision, conversion, left, pad, sign, arg, match, regex = [ "([^%]*)", "%", "(['\\-+ #0]*?)", "([1-9]\\d*)?", "(\\.([1-9]\\d*))?", "[lhjztL]*?", "([diouxXfFeEgGaAcCsSp%jr])" ].join(""), re = new RegExp(regex), args = Array.prototype.slice.call(arguments, 1), ret = "", argn = 1;
        for (mod_assert.equal("string", typeof fmt); null !== (match = re.exec(fmt)); ) if (ret += match[1], 
        fmt = fmt.substring(match[0].length), flags = match[2] || "", width = match[3] || 0, 
        precision = match[4] || "", left = !1, sign = !1, pad = " ", "%" != (conversion = match[6])) {
            if (0 === args.length) throw new Error("too few args to sprintf");
            if (arg = args.shift(), argn++, flags.match(/[\' #]/)) throw new Error("unsupported flags: " + flags);
            if (precision.length > 0) throw new Error("non-zero precision not supported");
            switch (flags.match(/-/) && (left = !0), flags.match(/0/) && (pad = "0"), flags.match(/\+/) && (sign = !0), 
            conversion) {
              case "s":
                if (null == arg) throw new Error("argument " + argn + ": attempted to print undefined or null as a string");
                ret += doPad(pad, width, left, arg.toString());
                break;

              case "d":
                arg = Math.floor(arg);

              case "f":
                ret += (sign = sign && arg > 0 ? "+" : "") + doPad(pad, width, left, arg.toString());
                break;

              case "x":
                ret += doPad(pad, width, left, arg.toString(16));
                break;

              case "j":
                0 === width && (width = 10), ret += mod_util.inspect(arg, !1, width);
                break;

              case "r":
                ret += dumpException(arg);
                break;

              default:
                throw new Error("unsupported conversion: " + conversion);
            }
        } else ret += "%";
        return ret + fmt;
    }
    function jsFprintf(stream) {
        var args = Array.prototype.slice.call(arguments, 1);
        return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
        for (var ret = str; ret.length < width; ) left ? ret += chr : ret = chr + ret;
        return ret;
    }
    function dumpException(ex) {
        var ret;
        if (!(ex instanceof Error)) throw new Error(jsSprintf("invalid type for %%r: %j", ex));
        if (ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack, ex.cause && "function" == typeof ex.cause) {
            var cex = ex.cause();
            cex && (ret += "\nCaused by: " + dumpException(cex));
        }
        return ret;
    }
    exports.sprintf = jsSprintf, exports.printf = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(process.stdout), jsFprintf.apply(null, args);
    }, exports.fprintf = jsFprintf;
}, function(module, exports, __webpack_require__) {
    var mod_assertplus = __webpack_require__(15), mod_util = __webpack_require__(0), mod_extsprintf = __webpack_require__(1063), mod_isError = __webpack_require__(1064).isError, sprintf = mod_extsprintf.sprintf;
    function parseConstructorArguments(args) {
        var argv, options, sprintf_args, k;
        if (mod_assertplus.object(args, "args"), mod_assertplus.bool(args.strict, "args.strict"), 
        mod_assertplus.array(args.argv, "args.argv"), 0 === (argv = args.argv).length) options = {}, 
        sprintf_args = []; else if (mod_isError(argv[0])) options = {
            cause: argv[0]
        }, sprintf_args = argv.slice(1); else if ("object" == typeof argv[0]) {
            for (k in options = {}, argv[0]) options[k] = argv[0][k];
            sprintf_args = argv.slice(1);
        } else mod_assertplus.string(argv[0], "first argument to VError, SError, or WError constructor must be a string, object, or Error"), 
        options = {}, sprintf_args = argv;
        return mod_assertplus.object(options), options.strict || args.strict || (sprintf_args = sprintf_args.map((function(a) {
            return null === a ? "null" : void 0 === a ? "undefined" : a;
        }))), {
            options: options,
            shortmessage: 0 === sprintf_args.length ? "" : sprintf.apply(null, sprintf_args)
        };
    }
    function VError() {
        var args, obj, parsed, cause, ctor, message, k;
        if (args = Array.prototype.slice.call(arguments, 0), !(this instanceof VError)) return obj = Object.create(VError.prototype), 
        VError.apply(obj, arguments), obj;
        if ((parsed = parseConstructorArguments({
            argv: args,
            strict: !1
        })).options.name && (mod_assertplus.string(parsed.options.name, 'error\'s "name" must be a string'), 
        this.name = parsed.options.name), this.jse_shortmsg = parsed.shortmessage, message = parsed.shortmessage, 
        (cause = parsed.options.cause) && (mod_assertplus.ok(mod_isError(cause), "cause is not an Error"), 
        this.jse_cause = cause, parsed.options.skipCauseMessage || (message += ": " + cause.message)), 
        this.jse_info = {}, parsed.options.info) for (k in parsed.options.info) this.jse_info[k] = parsed.options.info[k];
        return this.message = message, Error.call(this, message), Error.captureStackTrace && (ctor = parsed.options.constructorOpt || this.constructor, 
        Error.captureStackTrace(this, ctor)), this;
    }
    function SError() {
        var args, obj, parsed, options;
        return args = Array.prototype.slice.call(arguments, 0), this instanceof SError ? (options = (parsed = parseConstructorArguments({
            argv: args,
            strict: !0
        })).options, VError.call(this, options, "%s", parsed.shortmessage), this) : (obj = Object.create(SError.prototype), 
        SError.apply(obj, arguments), obj);
    }
    function MultiError(errors) {
        mod_assertplus.array(errors, "list of errors"), mod_assertplus.ok(errors.length > 0, "must be at least one error"), 
        this.ase_errors = errors, VError.call(this, {
            cause: errors[0]
        }, "first of %d error%s", errors.length, 1 == errors.length ? "" : "s");
    }
    function WError() {
        var args, obj, parsed, options;
        return args = Array.prototype.slice.call(arguments, 0), this instanceof WError ? ((options = (parsed = parseConstructorArguments({
            argv: args,
            strict: !1
        })).options).skipCauseMessage = !0, VError.call(this, options, "%s", parsed.shortmessage), 
        this) : (obj = Object.create(WError.prototype), WError.apply(obj, args), obj);
    }
    module.exports = VError, VError.VError = VError, VError.SError = SError, VError.WError = WError, 
    VError.MultiError = MultiError, mod_util.inherits(VError, Error), VError.prototype.name = "VError", 
    VError.prototype.toString = function() {
        var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
        return this.message && (str += ": " + this.message), str;
    }, VError.prototype.cause = function() {
        var cause = VError.cause(this);
        return null === cause ? void 0 : cause;
    }, VError.cause = function(err) {
        return mod_assertplus.ok(mod_isError(err), "err must be an Error"), mod_isError(err.jse_cause) ? err.jse_cause : null;
    }, VError.info = function(err) {
        var rv, cause, k;
        if (mod_assertplus.ok(mod_isError(err), "err must be an Error"), rv = null !== (cause = VError.cause(err)) ? VError.info(cause) : {}, 
        "object" == typeof err.jse_info && null !== err.jse_info) for (k in err.jse_info) rv[k] = err.jse_info[k];
        return rv;
    }, VError.findCauseByName = function(err, name) {
        var cause;
        for (mod_assertplus.ok(mod_isError(err), "err must be an Error"), mod_assertplus.string(name, "name"), 
        mod_assertplus.ok(name.length > 0, "name cannot be empty"), cause = err; null !== cause; cause = VError.cause(cause)) if (mod_assertplus.ok(mod_isError(cause)), 
        cause.name == name) return cause;
        return null;
    }, VError.hasCauseWithName = function(err, name) {
        return null !== VError.findCauseByName(err, name);
    }, VError.fullStack = function(err) {
        mod_assertplus.ok(mod_isError(err), "err must be an Error");
        var cause = VError.cause(err);
        return cause ? err.stack + "\ncaused by: " + VError.fullStack(cause) : err.stack;
    }, VError.errorFromList = function(errors) {
        return mod_assertplus.arrayOfObject(errors, "errors"), 0 === errors.length ? null : (errors.forEach((function(e) {
            mod_assertplus.ok(mod_isError(e));
        })), 1 == errors.length ? errors[0] : new MultiError(errors));
    }, VError.errorForEach = function(err, func) {
        mod_assertplus.ok(mod_isError(err), "err must be an Error"), mod_assertplus.func(func, "func"), 
        err instanceof MultiError ? err.errors().forEach((function(e) {
            func(e);
        })) : func(err);
    }, mod_util.inherits(SError, VError), mod_util.inherits(MultiError, VError), MultiError.prototype.name = "MultiError", 
    MultiError.prototype.errors = function() {
        return this.ase_errors.slice(0);
    }, mod_util.inherits(WError, VError), WError.prototype.name = "WError", WError.prototype.toString = function() {
        var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
        return this.message && (str += ": " + this.message), this.jse_cause && this.jse_cause.message && (str += "; caused by " + this.jse_cause.toString()), 
        str;
    }, WError.prototype.cause = function(c) {
        return mod_isError(c) && (this.jse_cause = c), this.jse_cause;
    };
}, function(module, exports, __webpack_require__) {
    var mod_assert = __webpack_require__(24), mod_util = __webpack_require__(0);
    function jsSprintf(ofmt) {
        var flags, width, precision, conversion, left, pad, sign, arg, match, convposn, curconv, regex = [ "([^%]*)", "%", "(['\\-+ #0]*?)", "([1-9]\\d*)?", "(\\.([1-9]\\d*))?", "[lhjztL]*?", "([diouxXfFeEgGaAcCsSp%jr])" ].join(""), re = new RegExp(regex), args = Array.prototype.slice.call(arguments, 1), fmt = ofmt, ret = "", argn = 1, posn = 0;
        for (mod_assert.equal("string", typeof fmt, "first argument must be a format string"); null !== (match = re.exec(fmt)); ) if (ret += match[1], 
        fmt = fmt.substring(match[0].length), curconv = match[0].substring(match[1].length), 
        convposn = posn + match[1].length + 1, posn += match[0].length, flags = match[2] || "", 
        width = match[3] || 0, precision = match[4] || "", left = !1, sign = !1, pad = " ", 
        "%" != (conversion = match[6])) {
            if (0 === args.length) throw jsError(ofmt, convposn, curconv, "has no matching argument (too few arguments passed)");
            if (arg = args.shift(), argn++, flags.match(/[\' #]/)) throw jsError(ofmt, convposn, curconv, "uses unsupported flags");
            if (precision.length > 0) throw jsError(ofmt, convposn, curconv, "uses non-zero precision (not supported)");
            switch (flags.match(/-/) && (left = !0), flags.match(/0/) && (pad = "0"), flags.match(/\+/) && (sign = !0), 
            conversion) {
              case "s":
                if (null == arg) throw jsError(ofmt, convposn, curconv, "attempted to print undefined or null as a string (argument " + argn + " to sprintf)");
                ret += doPad(pad, width, left, arg.toString());
                break;

              case "d":
                arg = Math.floor(arg);

              case "f":
                ret += (sign = sign && arg > 0 ? "+" : "") + doPad(pad, width, left, arg.toString());
                break;

              case "x":
                ret += doPad(pad, width, left, arg.toString(16));
                break;

              case "j":
                0 === width && (width = 10), ret += mod_util.inspect(arg, !1, width);
                break;

              case "r":
                ret += dumpException(arg);
                break;

              default:
                throw jsError(ofmt, convposn, curconv, "is not supported");
            }
        } else ret += "%";
        return ret + fmt;
    }
    function jsError(fmtstr, convposn, curconv, reason) {
        return mod_assert.equal(typeof fmtstr, "string"), mod_assert.equal(typeof curconv, "string"), 
        mod_assert.equal(typeof convposn, "number"), mod_assert.equal(typeof reason, "string"), 
        new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
    }
    function jsFprintf(stream) {
        var args = Array.prototype.slice.call(arguments, 1);
        return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
        for (var ret = str; ret.length < width; ) left ? ret += chr : ret = chr + ret;
        return ret;
    }
    function dumpException(ex) {
        var ret;
        if (!(ex instanceof Error)) throw new Error(jsSprintf("invalid type for %%r: %j", ex));
        if (ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack, ex.cause && "function" == typeof ex.cause) {
            var cex = ex.cause();
            cex && (ret += "\nCaused by: " + dumpException(cex));
        }
        return ret;
    }
    exports.sprintf = jsSprintf, exports.printf = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(process.stdout), jsFprintf.apply(null, args);
    }, exports.fprintf = jsFprintf;
}, function(module, exports) {
    function objectToString(o) {
        return Object.prototype.toString.call(o);
    }
    exports.isArray = function(arg) {
        return Array.isArray ? Array.isArray(arg) : "[object Array]" === objectToString(arg);
    }, exports.isBoolean = function(arg) {
        return "boolean" == typeof arg;
    }, exports.isNull = function(arg) {
        return null === arg;
    }, exports.isNullOrUndefined = function(arg) {
        return null == arg;
    }, exports.isNumber = function(arg) {
        return "number" == typeof arg;
    }, exports.isString = function(arg) {
        return "string" == typeof arg;
    }, exports.isSymbol = function(arg) {
        return "symbol" == typeof arg;
    }, exports.isUndefined = function(arg) {
        return void 0 === arg;
    }, exports.isRegExp = function(re) {
        return "[object RegExp]" === objectToString(re);
    }, exports.isObject = function(arg) {
        return "object" == typeof arg && null !== arg;
    }, exports.isDate = function(d) {
        return "[object Date]" === objectToString(d);
    }, exports.isError = function(e) {
        return "[object Error]" === objectToString(e) || e instanceof Error;
    }, exports.isFunction = function(arg) {
        return "function" == typeof arg;
    }, exports.isPrimitive = function(arg) {
        return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || void 0 === arg;
    }, exports.isBuffer = Buffer.isBuffer;
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    __WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return (function() {
            var exports = validate;
            exports.Integer = {
                type: "integer"
            };
            var primitiveConstructors = {
                String: String,
                Boolean: Boolean,
                Number: Number,
                Object: Object,
                Array: Array,
                Date: Date
            };
            function validate(instance, schema) {
                return validate(instance, schema, {
                    changing: !1
                });
            }
            exports.validate = validate, exports.checkPropertyChange = function(value, schema, property) {
                return validate(value, schema, {
                    changing: property || "property"
                });
            };
            var validate = exports._validate = function(instance, schema, options) {
                options || (options = {});
                var _changing = options.changing;
                function getType(schema) {
                    return schema.type || primitiveConstructors[schema.name] == schema && schema.name.toLowerCase();
                }
                var errors = [];
                function checkProp(value, schema, path, i) {
                    var l;
                    function addError(message) {
                        errors.push({
                            property: path,
                            message: message
                        });
                    }
                    if (path += path ? "number" == typeof i ? "[" + i + "]" : void 0 === i ? "" : "." + i : i, 
                    ("object" != typeof schema || schema instanceof Array) && (path || "function" != typeof schema) && (!schema || !getType(schema))) return "function" == typeof schema ? value instanceof schema || addError("is not an instance of the class/constructor " + schema.name) : schema && addError("Invalid schema/property definition " + schema), 
                    null;
                    function checkType(type, value) {
                        if (type) {
                            if (!("string" != typeof type || "any" == type || ("null" == type ? null === value : typeof value == type) || value instanceof Array && "array" == type || value instanceof Date && "date" == type || "integer" == type && value % 1 == 0)) return [ {
                                property: path,
                                message: typeof value + " value found, but a " + type + " is required"
                            } ];
                            if (type instanceof Array) {
                                for (var unionErrors = [], j = 0; j < type.length && (unionErrors = checkType(type[j], value)).length; j++) ;
                                if (unionErrors.length) return unionErrors;
                            } else if ("object" == typeof type) {
                                var priorErrors = errors;
                                errors = [], checkProp(value, type, path);
                                var theseErrors = errors;
                                return errors = priorErrors, theseErrors;
                            }
                        }
                        return [];
                    }
                    if (_changing && schema.readonly && addError("is a readonly field, it can not be changed"), 
                    schema.extends && checkProp(value, schema.extends, path, i), void 0 === value) schema.required && addError("is missing and it is required"); else if (errors = errors.concat(checkType(getType(schema), value)), 
                    schema.disallow && !checkType(schema.disallow, value).length && addError(" disallowed value was matched"), 
                    null !== value) {
                        if (value instanceof Array) {
                            if (schema.items) {
                                var itemsIsArray = schema.items instanceof Array, propDef = schema.items;
                                for (i = 0, l = value.length; i < l; i += 1) itemsIsArray && (propDef = schema.items[i]), 
                                options.coerce && (value[i] = options.coerce(value[i], propDef)), errors.concat(checkProp(value[i], propDef, path, i));
                            }
                            schema.minItems && value.length < schema.minItems && addError("There must be a minimum of " + schema.minItems + " in the array"), 
                            schema.maxItems && value.length > schema.maxItems && addError("There must be a maximum of " + schema.maxItems + " in the array");
                        } else (schema.properties || schema.additionalProperties) && errors.concat((function(instance, objTypeDef, path, additionalProp) {
                            if ("object" == typeof objTypeDef) for (var i in ("object" != typeof instance || instance instanceof Array) && errors.push({
                                property: path,
                                message: "an object is required"
                            }), objTypeDef) if (objTypeDef.hasOwnProperty(i)) {
                                var value = instance[i];
                                if (void 0 === value && options.existingOnly) continue;
                                var propDef = objTypeDef[i];
                                void 0 === value && propDef.default && (value = instance[i] = propDef.default), 
                                options.coerce && i in instance && (value = instance[i] = options.coerce(value, propDef)), 
                                checkProp(value, propDef, path, i);
                            }
                            for (i in instance) {
                                if (instance.hasOwnProperty(i) && ("_" != i.charAt(0) || "_" != i.charAt(1)) && objTypeDef && !objTypeDef[i] && !1 === additionalProp) {
                                    if (options.filter) {
                                        delete instance[i];
                                        continue;
                                    }
                                    errors.push({
                                        property: path,
                                        message: typeof value + "The property " + i + " is not defined in the schema and the schema does not allow additional properties"
                                    });
                                }
                                var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
                                requires && !(requires in instance) && errors.push({
                                    property: path,
                                    message: "the presence of the property " + i + " requires that " + requires + " also be present"
                                }), value = instance[i], !additionalProp || objTypeDef && "object" == typeof objTypeDef && i in objTypeDef || (options.coerce && (value = instance[i] = options.coerce(value, additionalProp)), 
                                checkProp(value, additionalProp, path, i)), !_changing && value && value.$schema && (errors = errors.concat(checkProp(value, value.$schema, path, i)));
                            }
                            return errors;
                        })(value, schema.properties, path, schema.additionalProperties));
                        if (schema.pattern && "string" == typeof value && !value.match(schema.pattern) && addError("does not match the regex pattern " + schema.pattern), 
                        schema.maxLength && "string" == typeof value && value.length > schema.maxLength && addError("may only be " + schema.maxLength + " characters long"), 
                        schema.minLength && "string" == typeof value && value.length < schema.minLength && addError("must be at least " + schema.minLength + " characters long"), 
                        void 0 !== typeof schema.minimum && typeof value == typeof schema.minimum && schema.minimum > value && addError("must have a minimum value of " + schema.minimum), 
                        void 0 !== typeof schema.maximum && typeof value == typeof schema.maximum && schema.maximum < value && addError("must have a maximum value of " + schema.maximum), 
                        schema.enum) {
                            var found, enumer = schema.enum;
                            l = enumer.length;
                            for (var j = 0; j < l; j++) if (enumer[j] === value) {
                                found = 1;
                                break;
                            }
                            found || addError("does not have a value in the enumeration " + enumer.join(", "));
                        }
                        "number" == typeof schema.maxDecimal && value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")) && addError("may only have " + schema.maxDecimal + " digits of decimal places");
                    }
                    return null;
                }
                return schema && checkProp(instance, schema, "", _changing || ""), !_changing && instance && instance.$schema && checkProp(instance, instance.$schema, "", ""), 
                {
                    valid: !errors.length,
                    errors: errors
                };
            };
            return exports.mustBeValid = function(result) {
                if (!result.valid) throw new TypeError(result.errors.map((function(error) {
                    return "for property " + error.property + ": " + error.message;
                })).join(", \n"));
            }, exports;
        })();
    }.apply(exports, []), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function(module, exports, __webpack_require__) {
    var assert = __webpack_require__(15), crypto = __webpack_require__(9), sshpk = __webpack_require__(230), utils = __webpack_require__(150), validateAlgorithm = (utils.HASH_ALGOS, 
    utils.PK_ALGOS, utils.InvalidAlgorithmError, utils.HttpSignatureError, utils.validateAlgorithm);
    module.exports = {
        verifySignature: function(parsedSignature, pubkey) {
            assert.object(parsedSignature, "parsedSignature"), ("string" == typeof pubkey || Buffer.isBuffer(pubkey)) && (pubkey = sshpk.parseKey(pubkey)), 
            assert.ok(sshpk.Key.isKey(pubkey, [ 1, 1 ]), "pubkey must be a sshpk.Key");
            var alg = validateAlgorithm(parsedSignature.algorithm);
            if ("hmac" === alg[0] || alg[0] !== pubkey.type) return !1;
            var v = pubkey.createVerify(alg[1]);
            return v.update(parsedSignature.signingString), v.verify(parsedSignature.params.signature, "base64");
        },
        verifyHMAC: function(parsedSignature, secret) {
            assert.object(parsedSignature, "parsedHMAC"), assert.string(secret, "secret");
            var alg = validateAlgorithm(parsedSignature.algorithm);
            if ("hmac" !== alg[0]) return !1;
            var hashAlg = alg[1].toUpperCase(), hmac = crypto.createHmac(hashAlg, secret);
            hmac.update(parsedSignature.signingString);
            var h1 = crypto.createHmac(hashAlg, secret);
            h1.update(hmac.digest()), h1 = h1.digest();
            var h2 = crypto.createHmac(hashAlg, secret);
            return h2.update(new Buffer(parsedSignature.params.signature, "base64")), h2 = h2.digest(), 
            "string" == typeof h1 ? h1 === h2 : Buffer.isBuffer(h1) && !h1.equals ? h1.toString("binary") === h2.toString("binary") : h1.equals(h2);
        }
    };
}, function(module, exports, __webpack_require__) {
    module.exports = ForeverAgent, ForeverAgent.SSL = ForeverAgentSSL;
    var util = __webpack_require__(0), Agent = __webpack_require__(11).Agent, net = __webpack_require__(42), tls = __webpack_require__(92), AgentSSL = __webpack_require__(22).Agent;
    function getConnectionName(host, port) {
        return "string" == typeof host ? host + ":" + port : host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
    }
    function ForeverAgent(options) {
        var self = this;
        self.options = options || {}, self.requests = {}, self.sockets = {}, self.freeSockets = {}, 
        self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets, self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets, 
        self.on("free", (function(socket, host, port) {
            var name = getConnectionName(host, port);
            if (self.requests[name] && self.requests[name].length) self.requests[name].shift().onSocket(socket); else if (self.sockets[name].length < self.minSockets) {
                self.freeSockets[name] || (self.freeSockets[name] = []), self.freeSockets[name].push(socket);
                var onIdleError = function() {
                    socket.destroy();
                };
                socket._onIdleError = onIdleError, socket.on("error", onIdleError);
            } else socket.destroy();
        }));
    }
    function ForeverAgentSSL(options) {
        ForeverAgent.call(this, options);
    }
    util.inherits(ForeverAgent, Agent), ForeverAgent.defaultMinSockets = 5, ForeverAgent.prototype.createConnection = net.createConnection, 
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest, ForeverAgent.prototype.addRequest = function(req, host, port) {
        var name = getConnectionName(host, port);
        if ("string" != typeof host) {
            var options = host;
            port = options.port, host = options.host;
        }
        if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
            var idleSocket = this.freeSockets[name].pop();
            idleSocket.removeListener("error", idleSocket._onIdleError), delete idleSocket._onIdleError, 
            req._reusedSocket = !0, req.onSocket(idleSocket);
        } else this.addRequestNoreuse(req, host, port);
    }, ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
        var index;
        this.sockets[name] ? -1 !== (index = this.sockets[name].indexOf(s)) && this.sockets[name].splice(index, 1) : this.sockets[name] && 0 === this.sockets[name].length && (delete this.sockets[name], 
        delete this.requests[name]), this.freeSockets[name] && -1 !== (index = this.freeSockets[name].indexOf(s)) && (this.freeSockets[name].splice(index, 1), 
        0 === this.freeSockets[name].length && delete this.freeSockets[name]), this.requests[name] && this.requests[name].length && this.createSocket(name, host, port).emit("free");
    }, util.inherits(ForeverAgentSSL, ForeverAgent), ForeverAgentSSL.prototype.createConnection = function(port, host, options) {
        return "object" == typeof port ? options = port : "object" == typeof host ? options = host : "object" == typeof options || (options = {}), 
        "number" == typeof port && (options.port = port), "string" == typeof host && (options.host = host), 
        tls.connect(options);
    }, ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
}, function(module, exports, __webpack_require__) {
    var CombinedStream = __webpack_require__(485), util = __webpack_require__(0), path = __webpack_require__(4), http = __webpack_require__(11), https = __webpack_require__(22), parseUrl = __webpack_require__(7).parse, fs = __webpack_require__(2), mime = __webpack_require__(89), asynckit = __webpack_require__(1070), populate = __webpack_require__(1074);
    function FormData(options) {
        if (!(this instanceof FormData)) return new FormData;
        for (var option in this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], 
        CombinedStream.call(this), options = options || {}) this[option] = options[option];
    }
    module.exports = FormData, util.inherits(FormData, CombinedStream), FormData.LINE_BREAK = "\r\n", 
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream", FormData.prototype.append = function(field, value, options) {
        "string" == typeof (options = options || {}) && (options = {
            filename: options
        });
        var append = CombinedStream.prototype.append.bind(this);
        if ("number" == typeof value && (value = "" + value), util.isArray(value)) this._error(new Error("Arrays are not supported.")); else {
            var header = this._multiPartHeader(field, value, options), footer = this._multiPartFooter();
            append(header), append(value), append(footer), this._trackLength(header, value, options);
        }
    }, FormData.prototype._trackLength = function(header, value, options) {
        var valueLength = 0;
        null != options.knownLength ? valueLength += +options.knownLength : Buffer.isBuffer(value) ? valueLength = value.length : "string" == typeof value && (valueLength = Buffer.byteLength(value)), 
        this._valueLength += valueLength, this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length, 
        value && (value.path || value.readable && value.hasOwnProperty("httpVersion")) && (options.knownLength || this._valuesToMeasure.push(value));
    }, FormData.prototype._lengthRetriever = function(value, callback) {
        value.hasOwnProperty("fd") ? null != value.end && value.end != 1 / 0 && null != value.start ? callback(null, value.end + 1 - (value.start ? value.start : 0)) : fs.stat(value.path, (function(err, stat) {
            var fileSize;
            err ? callback(err) : (fileSize = stat.size - (value.start ? value.start : 0), callback(null, fileSize));
        })) : value.hasOwnProperty("httpVersion") ? callback(null, +value.headers["content-length"]) : value.hasOwnProperty("httpModule") ? (value.on("response", (function(response) {
            value.pause(), callback(null, +response.headers["content-length"]);
        })), value.resume()) : callback("Unknown stream");
    }, FormData.prototype._multiPartHeader = function(field, value, options) {
        if ("string" == typeof options.header) return options.header;
        var header, contentDisposition = this._getContentDisposition(value, options), contentType = this._getContentType(value, options), contents = "", headers = {
            "Content-Disposition": [ "form-data", 'name="' + field + '"' ].concat(contentDisposition || []),
            "Content-Type": [].concat(contentType || [])
        };
        for (var prop in "object" == typeof options.header && populate(headers, options.header), 
        headers) headers.hasOwnProperty(prop) && null != (header = headers[prop]) && (Array.isArray(header) || (header = [ header ]), 
        header.length && (contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK));
        return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    }, FormData.prototype._getContentDisposition = function(value, options) {
        var filename, contentDisposition;
        return "string" == typeof options.filepath ? filename = path.normalize(options.filepath).replace(/\\/g, "/") : options.filename || value.name || value.path ? filename = path.basename(options.filename || value.name || value.path) : value.readable && value.hasOwnProperty("httpVersion") && (filename = path.basename(value.client._httpMessage.path)), 
        filename && (contentDisposition = 'filename="' + filename + '"'), contentDisposition;
    }, FormData.prototype._getContentType = function(value, options) {
        var contentType = options.contentType;
        return !contentType && value.name && (contentType = mime.lookup(value.name)), !contentType && value.path && (contentType = mime.lookup(value.path)), 
        !contentType && value.readable && value.hasOwnProperty("httpVersion") && (contentType = value.headers["content-type"]), 
        contentType || !options.filepath && !options.filename || (contentType = mime.lookup(options.filepath || options.filename)), 
        contentType || "object" != typeof value || (contentType = FormData.DEFAULT_CONTENT_TYPE), 
        contentType;
    }, FormData.prototype._multiPartFooter = function() {
        return function(next) {
            var footer = FormData.LINE_BREAK;
            0 === this._streams.length && (footer += this._lastBoundary()), next(footer);
        }.bind(this);
    }, FormData.prototype._lastBoundary = function() {
        return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    }, FormData.prototype.getHeaders = function(userHeaders) {
        var header, formHeaders = {
            "content-type": "multipart/form-data; boundary=" + this.getBoundary()
        };
        for (header in userHeaders) userHeaders.hasOwnProperty(header) && (formHeaders[header.toLowerCase()] = userHeaders[header]);
        return formHeaders;
    }, FormData.prototype.getBoundary = function() {
        return this._boundary || this._generateBoundary(), this._boundary;
    }, FormData.prototype._generateBoundary = function() {
        for (var boundary = "--------------------------", i = 0; i < 24; i++) boundary += Math.floor(10 * Math.random()).toString(16);
        this._boundary = boundary;
    }, FormData.prototype.getLengthSync = function() {
        var knownLength = this._overheadLength + this._valueLength;
        return this._streams.length && (knownLength += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), 
        knownLength;
    }, FormData.prototype.hasKnownLength = function() {
        var hasKnownLength = !0;
        return this._valuesToMeasure.length && (hasKnownLength = !1), hasKnownLength;
    }, FormData.prototype.getLength = function(cb) {
        var knownLength = this._overheadLength + this._valueLength;
        this._streams.length && (knownLength += this._lastBoundary().length), this._valuesToMeasure.length ? asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, (function(err, values) {
            err ? cb(err) : (values.forEach((function(length) {
                knownLength += length;
            })), cb(null, knownLength));
        })) : process.nextTick(cb.bind(this, null, knownLength));
    }, FormData.prototype.submit = function(params, cb) {
        var request, options, defaults = {
            method: "post"
        };
        return "string" == typeof params ? (params = parseUrl(params), options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults)) : (options = populate(params, defaults)).port || (options.port = "https:" == options.protocol ? 443 : 80), 
        options.headers = this.getHeaders(params.headers), request = "https:" == options.protocol ? https.request(options) : http.request(options), 
        this.getLength(function(err, length) {
            err ? this._error(err) : (request.setHeader("Content-Length", length), this.pipe(request), 
            cb && (request.on("error", cb), request.on("response", cb.bind(this, null))));
        }.bind(this)), request;
    }, FormData.prototype._error = function(err) {
        this.error || (this.error = err, this.pause(), this.emit("error", err));
    }, FormData.prototype.toString = function() {
        return "[object FormData]";
    };
}, function(module, exports, __webpack_require__) {
    var Stream = __webpack_require__(3).Stream, util = __webpack_require__(0);
    function DelayedStream() {
        this.source = null, this.dataSize = 0, this.maxDataSize = 1048576, this.pauseStream = !0, 
        this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
    }
    module.exports = DelayedStream, util.inherits(DelayedStream, Stream), DelayedStream.create = function(source, options) {
        var delayedStream = new this;
        for (var option in options = options || {}) delayedStream[option] = options[option];
        delayedStream.source = source;
        var realEmit = source.emit;
        return source.emit = function() {
            return delayedStream._handleEmit(arguments), realEmit.apply(source, arguments);
        }, source.on("error", (function() {})), delayedStream.pauseStream && source.pause(), 
        delayedStream;
    }, Object.defineProperty(DelayedStream.prototype, "readable", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            return this.source.readable;
        }
    }), DelayedStream.prototype.setEncoding = function() {
        return this.source.setEncoding.apply(this.source, arguments);
    }, DelayedStream.prototype.resume = function() {
        this._released || this.release(), this.source.resume();
    }, DelayedStream.prototype.pause = function() {
        this.source.pause();
    }, DelayedStream.prototype.release = function() {
        this._released = !0, this._bufferedEvents.forEach(function(args) {
            this.emit.apply(this, args);
        }.bind(this)), this._bufferedEvents = [];
    }, DelayedStream.prototype.pipe = function() {
        var r = Stream.prototype.pipe.apply(this, arguments);
        return this.resume(), r;
    }, DelayedStream.prototype._handleEmit = function(args) {
        this._released ? this.emit.apply(this, args) : ("data" === args[0] && (this.dataSize += args[1].length, 
        this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(args));
    }, DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
        if (!(this._maxDataSizeExceeded || this.dataSize <= this.maxDataSize)) {
            this._maxDataSizeExceeded = !0;
            var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
            this.emit("error", new Error(message));
        }
    };
}, function(module, exports, __webpack_require__) {
    module.exports = {
        parallel: __webpack_require__(1071),
        serial: __webpack_require__(1073),
        serialOrdered: __webpack_require__(491)
    };
}, function(module, exports, __webpack_require__) {
    var iterate = __webpack_require__(486), initState = __webpack_require__(489), terminator = __webpack_require__(490);
    module.exports = function(list, iterator, callback) {
        for (var state = initState(list); state.index < (state.keyedList || list).length; ) iterate(list, iterator, state, (function(error, result) {
            error ? callback(error, result) : 0 !== Object.keys(state.jobs).length || callback(null, state.results);
        })), state.index++;
        return terminator.bind(state, callback);
    };
}, function(module, exports) {
    module.exports = function(fn) {
        var nextTick = "function" == typeof setImmediate ? setImmediate : "object" == typeof process && "function" == typeof process.nextTick ? process.nextTick : null;
        nextTick ? nextTick(fn) : setTimeout(fn, 0);
    };
}, function(module, exports, __webpack_require__) {
    var serialOrdered = __webpack_require__(491);
    module.exports = function(list, iterator, callback) {
        return serialOrdered(list, iterator, null, callback);
    };
}, function(module, exports) {
    module.exports = function(dst, src) {
        return Object.keys(src).forEach((function(prop) {
            dst[prop] = dst[prop] || src[prop];
        })), dst;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    function formatHostname(hostname) {
        return hostname.replace(/^\.*/, ".").toLowerCase();
    }
    function parseNoProxyZone(zone) {
        var zoneParts = (zone = zone.trim().toLowerCase()).split(":", 2);
        return {
            hostname: formatHostname(zoneParts[0]),
            port: zoneParts[1],
            hasPort: zone.indexOf(":") > -1
        };
    }
    module.exports = function(uri) {
        var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
        return "*" === noProxy || "" !== noProxy && (function(uri, noProxy) {
            var port = uri.port || ("https:" === uri.protocol ? "443" : "80"), hostname = formatHostname(uri.hostname);
            return noProxy.split(",").map(parseNoProxyZone).some((function(noProxyZone) {
                var isMatchedAt = hostname.indexOf(noProxyZone.hostname), hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
                return noProxyZone.hasPort ? port === noProxyZone.port && hostnameMatched : hostnameMatched;
            }));
        })(uri, noProxy) ? null : "http:" === uri.protocol ? process.env.HTTP_PROXY || process.env.http_proxy || null : "https:" === uri.protocol && (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy) || null;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var qs = __webpack_require__(493), querystring = __webpack_require__(28);
    function Querystring(request) {
        this.request = request, this.lib = null, this.useQuerystring = null, this.parseOptions = null, 
        this.stringifyOptions = null;
    }
    Querystring.prototype.init = function(options) {
        this.lib || (this.useQuerystring = options.useQuerystring, this.lib = this.useQuerystring ? querystring : qs, 
        this.parseOptions = options.qsParseOptions || {}, this.stringifyOptions = options.qsStringifyOptions || {});
    }, Querystring.prototype.stringify = function(obj) {
        return this.useQuerystring ? this.rfc3986(this.lib.stringify(obj, this.stringifyOptions.sep || null, this.stringifyOptions.eq || null, this.stringifyOptions)) : this.lib.stringify(obj, this.stringifyOptions);
    }, Querystring.prototype.parse = function(str) {
        return this.useQuerystring ? this.lib.parse(str, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions) : this.lib.parse(str, this.parseOptions);
    }, Querystring.prototype.rfc3986 = function(str) {
        return str.replace(/[!'()*]/g, (function(c) {
            return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        }));
    }, Querystring.prototype.unescape = querystring.unescape, exports.Querystring = Querystring;
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(494), formats = __webpack_require__(495), arrayPrefixGenerators = {
        brackets: function(prefix) {
            return prefix + "[]";
        },
        indices: function(prefix, key) {
            return prefix + "[" + key + "]";
        },
        repeat: function(prefix) {
            return prefix;
        }
    }, toISO = Date.prototype.toISOString, defaults = {
        delimiter: "&",
        encode: !0,
        encoder: utils.encode,
        encodeValuesOnly: !1,
        serializeDate: function(date) {
            return toISO.call(date);
        },
        skipNulls: !1,
        strictNullHandling: !1
    }, stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
        var obj = object;
        if ("function" == typeof filter) obj = filter(prefix, obj); else if (obj instanceof Date) obj = serializeDate(obj); else if (null === obj) {
            if (strictNullHandling) return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
            obj = "";
        }
        if ("string" == typeof obj || "number" == typeof obj || "boolean" == typeof obj || utils.isBuffer(obj)) return encoder ? [ formatter(encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder)) + "=" + formatter(encoder(obj, defaults.encoder)) ] : [ formatter(prefix) + "=" + formatter(String(obj)) ];
        var objKeys, values = [];
        if (void 0 === obj) return values;
        if (Array.isArray(filter)) objKeys = filter; else {
            var keys = Object.keys(obj);
            objKeys = sort ? keys.sort(sort) : keys;
        }
        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            skipNulls && null === obj[key] || (values = Array.isArray(obj) ? values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)) : values.concat(stringify(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)));
        }
        return values;
    };
    module.exports = function(object, opts) {
        var obj = object, options = opts ? utils.assign({}, opts) : {};
        if (null !== options.encoder && void 0 !== options.encoder && "function" != typeof options.encoder) throw new TypeError("Encoder has to be a function.");
        var delimiter = void 0 === options.delimiter ? defaults.delimiter : options.delimiter, strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, skipNulls = "boolean" == typeof options.skipNulls ? options.skipNulls : defaults.skipNulls, encode = "boolean" == typeof options.encode ? options.encode : defaults.encode, encoder = "function" == typeof options.encoder ? options.encoder : defaults.encoder, sort = "function" == typeof options.sort ? options.sort : null, allowDots = void 0 !== options.allowDots && options.allowDots, serializeDate = "function" == typeof options.serializeDate ? options.serializeDate : defaults.serializeDate, encodeValuesOnly = "boolean" == typeof options.encodeValuesOnly ? options.encodeValuesOnly : defaults.encodeValuesOnly;
        if (void 0 === options.format) options.format = formats.default; else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) throw new TypeError("Unknown format option provided.");
        var objKeys, filter, formatter = formats.formatters[options.format];
        "function" == typeof options.filter ? obj = (filter = options.filter)("", obj) : Array.isArray(options.filter) && (objKeys = filter = options.filter);
        var arrayFormat, keys = [];
        if ("object" != typeof obj || null === obj) return "";
        arrayFormat = options.arrayFormat in arrayPrefixGenerators ? options.arrayFormat : "indices" in options ? options.indices ? "indices" : "repeat" : "indices";
        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        objKeys || (objKeys = Object.keys(obj)), sort && objKeys.sort(sort);
        for (var i = 0; i < objKeys.length; ++i) {
            var key = objKeys[i];
            skipNulls && null === obj[key] || (keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly)));
        }
        var joined = keys.join(delimiter), prefix = !0 === options.addQueryPrefix ? "?" : "";
        return joined.length > 0 ? prefix + joined : "";
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var utils = __webpack_require__(494), has = Object.prototype.hasOwnProperty, defaults = {
        allowDots: !1,
        allowPrototypes: !1,
        arrayLimit: 20,
        decoder: utils.decode,
        delimiter: "&",
        depth: 5,
        parameterLimit: 1e3,
        plainObjects: !1,
        strictNullHandling: !1
    }, parseKeys = function(givenKey, val, options) {
        if (givenKey) {
            var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey, child = /(\[[^[\]]*])/g, segment = /(\[[^[\]]*])/.exec(key), parent = segment ? key.slice(0, segment.index) : key, keys = [];
            if (parent) {
                if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) return;
                keys.push(parent);
            }
            for (var i = 0; null !== (segment = child.exec(key)) && i < options.depth; ) {
                if (i += 1, !options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes) return;
                keys.push(segment[1]);
            }
            return segment && keys.push("[" + key.slice(segment.index) + "]"), (function(chain, val, options) {
                for (var leaf = val, i = chain.length - 1; i >= 0; --i) {
                    var obj, root = chain[i];
                    if ("[]" === root) obj = (obj = []).concat(leaf); else {
                        obj = options.plainObjects ? Object.create(null) : {};
                        var cleanRoot = "[" === root.charAt(0) && "]" === root.charAt(root.length - 1) ? root.slice(1, -1) : root, index = parseInt(cleanRoot, 10);
                        !isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit ? (obj = [])[index] = leaf : obj[cleanRoot] = leaf;
                    }
                    leaf = obj;
                }
                return leaf;
            })(keys, val, options);
        }
    };
    module.exports = function(str, opts) {
        var options = opts ? utils.assign({}, opts) : {};
        if (null !== options.decoder && void 0 !== options.decoder && "function" != typeof options.decoder) throw new TypeError("Decoder has to be a function.");
        if (options.ignoreQueryPrefix = !0 === options.ignoreQueryPrefix, options.delimiter = "string" == typeof options.delimiter || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter, 
        options.depth = "number" == typeof options.depth ? options.depth : defaults.depth, 
        options.arrayLimit = "number" == typeof options.arrayLimit ? options.arrayLimit : defaults.arrayLimit, 
        options.parseArrays = !1 !== options.parseArrays, options.decoder = "function" == typeof options.decoder ? options.decoder : defaults.decoder, 
        options.allowDots = "boolean" == typeof options.allowDots ? options.allowDots : defaults.allowDots, 
        options.plainObjects = "boolean" == typeof options.plainObjects ? options.plainObjects : defaults.plainObjects, 
        options.allowPrototypes = "boolean" == typeof options.allowPrototypes ? options.allowPrototypes : defaults.allowPrototypes, 
        options.parameterLimit = "number" == typeof options.parameterLimit ? options.parameterLimit : defaults.parameterLimit, 
        options.strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, 
        "" === str || null == str) return options.plainObjects ? Object.create(null) : {};
        for (var tempObj = "string" == typeof str ? (function(str, options) {
            for (var obj = {}, cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str, limit = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit, parts = cleanStr.split(options.delimiter, limit), i = 0; i < parts.length; ++i) {
                var key, val, part = parts[i], bracketEqualsPos = part.indexOf("]="), pos = -1 === bracketEqualsPos ? part.indexOf("=") : bracketEqualsPos + 1;
                -1 === pos ? (key = options.decoder(part, defaults.decoder), val = options.strictNullHandling ? null : "") : (key = options.decoder(part.slice(0, pos), defaults.decoder), 
                val = options.decoder(part.slice(pos + 1), defaults.decoder)), has.call(obj, key) ? obj[key] = [].concat(obj[key]).concat(val) : obj[key] = val;
            }
            return obj;
        })(str, options) : str, obj = options.plainObjects ? Object.create(null) : {}, keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) {
            var key = keys[i], newObj = parseKeys(key, tempObj[key], options);
            obj = utils.merge(obj, newObj, options);
        }
        return utils.compact(obj);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var fs = __webpack_require__(2), qs = __webpack_require__(28), validate = __webpack_require__(1080), extend = __webpack_require__(147);
    function Har(request) {
        this.request = request;
    }
    Har.prototype.reducer = function(obj, pair) {
        if (void 0 === obj[pair.name]) return obj[pair.name] = pair.value, obj;
        var arr = [ obj[pair.name], pair.value ];
        return obj[pair.name] = arr, obj;
    }, Har.prototype.prep = function(data) {
        if (data.queryObj = {}, data.headersObj = {}, data.postData.jsonObj = !1, data.postData.paramsObj = !1, 
        data.queryString && data.queryString.length && (data.queryObj = data.queryString.reduce(this.reducer, {})), 
        data.headers && data.headers.length && (data.headersObj = data.headers.reduceRight((function(headers, header) {
            return headers[header.name] = header.value, headers;
        }), {})), data.cookies && data.cookies.length) {
            var cookies = data.cookies.map((function(cookie) {
                return cookie.name + "=" + cookie.value;
            }));
            cookies.length && (data.headersObj.cookie = cookies.join("; "));
        }
        function some(arr) {
            return arr.some((function(type) {
                return 0 === data.postData.mimeType.indexOf(type);
            }));
        }
        if (some([ "multipart/mixed", "multipart/related", "multipart/form-data", "multipart/alternative" ])) data.postData.mimeType = "multipart/form-data"; else if (some([ "application/x-www-form-urlencoded" ])) data.postData.params ? (data.postData.paramsObj = data.postData.params.reduce(this.reducer, {}), 
        data.postData.text = qs.stringify(data.postData.paramsObj)) : data.postData.text = ""; else if (some([ "text/json", "text/x-json", "application/json", "application/x-json" ]) && (data.postData.mimeType = "application/json", 
        data.postData.text)) try {
            data.postData.jsonObj = JSON.parse(data.postData.text);
        } catch (e) {
            this.request.debug(e), data.postData.mimeType = "text/plain";
        }
        return data;
    }, Har.prototype.options = function(options) {
        if (!options.har) return options;
        var har = {};
        if (extend(har, options.har), har.log && har.log.entries && (har = har.log.entries[0]), 
        har.url = har.url || options.url || options.uri || options.baseUrl || "/", har.httpVersion = har.httpVersion || "HTTP/1.1", 
        har.queryString = har.queryString || [], har.headers = har.headers || [], har.cookies = har.cookies || [], 
        har.postData = har.postData || {}, har.postData.mimeType = har.postData.mimeType || "application/octet-stream", 
        har.bodySize = 0, har.headersSize = 0, har.postData.size = 0, !validate.request(har)) return options;
        var req = this.prep(har);
        function test(type) {
            return 0 === req.postData.mimeType.indexOf(type);
        }
        return req.url && (options.url = req.url), req.method && (options.method = req.method), 
        Object.keys(req.queryObj).length && (options.qs = req.queryObj), Object.keys(req.headersObj).length && (options.headers = req.headersObj), 
        test("application/x-www-form-urlencoded") ? options.form = req.postData.paramsObj : test("application/json") ? req.postData.jsonObj && (options.body = req.postData.jsonObj, 
        options.json = !0) : test("multipart/form-data") ? (options.formData = {}, req.postData.params.forEach((function(param) {
            var attachment = {};
            param.fileName || param.fileName || param.contentType ? (param.fileName && !param.value ? attachment.value = fs.createReadStream(param.fileName) : param.value && (attachment.value = param.value), 
            param.fileName && (attachment.options = {
                filename: param.fileName,
                contentType: param.contentType ? param.contentType : null
            }), options.formData[param.name] = attachment) : options.formData[param.name] = param.value;
        }))) : req.postData.text && (options.body = req.postData.text), options;
    }, exports.Har = Har;
}, function(module, exports, __webpack_require__) {
    var ajv, Ajv = __webpack_require__(1081), HARError = __webpack_require__(1114), schemas = __webpack_require__(1115);
    function validate(name, data) {
        data = data || {};
        var validate = (ajv = ajv || (function() {
            var ajv = new Ajv({
                allErrors: !0
            });
            return ajv.addMetaSchema(__webpack_require__(1134)), ajv.addSchema(schemas), ajv;
        })()).getSchema(name + ".json");
        return new Promise((function(resolve, reject) {
            validate(data) ? resolve(data) : reject(new HARError(validate.errors));
        }));
    }
    exports.afterRequest = function(data) {
        return validate("afterRequest", data);
    }, exports.beforeRequest = function(data) {
        return validate("beforeRequest", data);
    }, exports.browser = function(data) {
        return validate("browser", data);
    }, exports.cache = function(data) {
        return validate("cache", data);
    }, exports.content = function(data) {
        return validate("content", data);
    }, exports.cookie = function(data) {
        return validate("cookie", data);
    }, exports.creator = function(data) {
        return validate("creator", data);
    }, exports.entry = function(data) {
        return validate("entry", data);
    }, exports.har = function(data) {
        return validate("har", data);
    }, exports.header = function(data) {
        return validate("header", data);
    }, exports.log = function(data) {
        return validate("log", data);
    }, exports.page = function(data) {
        return validate("page", data);
    }, exports.pageTimings = function(data) {
        return validate("pageTimings", data);
    }, exports.postData = function(data) {
        return validate("postData", data);
    }, exports.query = function(data) {
        return validate("query", data);
    }, exports.request = function(data) {
        return validate("request", data);
    }, exports.response = function(data) {
        return validate("response", data);
    }, exports.timings = function(data) {
        return validate("timings", data);
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var compileSchema = __webpack_require__(1082), resolve = __webpack_require__(237), Cache = __webpack_require__(1086), SchemaObject = __webpack_require__(496), stableStringify = __webpack_require__(497), formats = __webpack_require__(1087), rules = __webpack_require__(1088), $dataMetaSchema = __webpack_require__(1109), util = __webpack_require__(80);
    module.exports = Ajv, Ajv.prototype.validate = function(schemaKeyRef, data) {
        var v;
        if ("string" == typeof schemaKeyRef) {
            if (!(v = this.getSchema(schemaKeyRef))) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
        } else {
            var schemaObj = this._addSchema(schemaKeyRef);
            v = schemaObj.validate || this._compile(schemaObj);
        }
        var valid = v(data);
        return !0 !== v.$async && (this.errors = v.errors), valid;
    }, Ajv.prototype.compile = function(schema, _meta) {
        var schemaObj = this._addSchema(schema, void 0, _meta);
        return schemaObj.validate || this._compile(schemaObj);
    }, Ajv.prototype.addSchema = function(schema, key, _skipValidation, _meta) {
        if (Array.isArray(schema)) {
            for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], void 0, _skipValidation, _meta);
            return this;
        }
        var id = this._getId(schema);
        if (void 0 !== id && "string" != typeof id) throw new Error("schema id must be string");
        return checkUnique(this, key = resolve.normalizeId(key || id)), this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, !0), 
        this;
    }, Ajv.prototype.addMetaSchema = function(schema, key, skipValidation) {
        return this.addSchema(schema, key, skipValidation, !0), this;
    }, Ajv.prototype.validateSchema = function(schema, throwOrLogError) {
        var $schema = schema.$schema;
        if (void 0 !== $schema && "string" != typeof $schema) throw new Error("$schema must be a string");
        if (!($schema = $schema || this._opts.defaultMeta || (function(self) {
            var meta = self._opts.meta;
            return self._opts.defaultMeta = "object" == typeof meta ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0, 
            self._opts.defaultMeta;
        })(this))) return this.logger.warn("meta-schema not available"), this.errors = null, 
        !0;
        var valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
            var message = "schema is invalid: " + this.errorsText();
            if ("log" != this._opts.validateSchema) throw new Error(message);
            this.logger.error(message);
        }
        return valid;
    }, Ajv.prototype.getSchema = function(keyRef) {
        var schemaObj = _getSchemaObj(this, keyRef);
        switch (typeof schemaObj) {
          case "object":
            return schemaObj.validate || this._compile(schemaObj);

          case "string":
            return this.getSchema(schemaObj);

          case "undefined":
            return (function(self, ref) {
                var res = resolve.schema.call(self, {
                    schema: {}
                }, ref);
                if (res) {
                    var schema = res.schema, root = res.root, baseId = res.baseId, v = compileSchema.call(self, schema, root, void 0, baseId);
                    return self._fragments[ref] = new SchemaObject({
                        ref: ref,
                        fragment: !0,
                        schema: schema,
                        root: root,
                        baseId: baseId,
                        validate: v
                    }), v;
                }
            })(this, keyRef);
        }
    }, Ajv.prototype.removeSchema = function(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) return _removeAllSchemas(this, this._schemas, schemaKeyRef), 
        _removeAllSchemas(this, this._refs, schemaKeyRef), this;
        switch (typeof schemaKeyRef) {
          case "undefined":
            return _removeAllSchemas(this, this._schemas), _removeAllSchemas(this, this._refs), 
            this._cache.clear(), this;

          case "string":
            var schemaObj = _getSchemaObj(this, schemaKeyRef);
            return schemaObj && this._cache.del(schemaObj.cacheKey), delete this._schemas[schemaKeyRef], 
            delete this._refs[schemaKeyRef], this;

          case "object":
            var serialize = this._opts.serialize, cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
            this._cache.del(cacheKey);
            var id = this._getId(schemaKeyRef);
            id && (id = resolve.normalizeId(id), delete this._schemas[id], delete this._refs[id]);
        }
        return this;
    }, Ajv.prototype.addFormat = function(name, format) {
        return "string" == typeof format && (format = new RegExp(format)), this._formats[name] = format, 
        this;
    }, Ajv.prototype.errorsText = function(errors, options) {
        if (!(errors = errors || this.errors)) return "No errors";
        for (var separator = void 0 === (options = options || {}).separator ? ", " : options.separator, dataVar = void 0 === options.dataVar ? "data" : options.dataVar, text = "", i = 0; i < errors.length; i++) {
            var e = errors[i];
            e && (text += dataVar + e.dataPath + " " + e.message + separator);
        }
        return text.slice(0, -separator.length);
    }, Ajv.prototype._addSchema = function(schema, skipValidation, meta, shouldAddSchema) {
        if ("object" != typeof schema && "boolean" != typeof schema) throw new Error("schema should be object or boolean");
        var serialize = this._opts.serialize, cacheKey = serialize ? serialize(schema) : schema, cached = this._cache.get(cacheKey);
        if (cached) return cached;
        shouldAddSchema = shouldAddSchema || !1 !== this._opts.addUsedSchema;
        var id = resolve.normalizeId(this._getId(schema));
        id && shouldAddSchema && checkUnique(this, id);
        var recursiveMeta, willValidate = !1 !== this._opts.validateSchema && !skipValidation;
        willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)) && this.validateSchema(schema, !0);
        var localRefs = resolve.ids.call(this, schema), schemaObj = new SchemaObject({
            id: id,
            schema: schema,
            localRefs: localRefs,
            cacheKey: cacheKey,
            meta: meta
        });
        return "#" != id[0] && shouldAddSchema && (this._refs[id] = schemaObj), this._cache.put(cacheKey, schemaObj), 
        willValidate && recursiveMeta && this.validateSchema(schema, !0), schemaObj;
    }, Ajv.prototype._compile = function(schemaObj, root) {
        if (schemaObj.compiling) return schemaObj.validate = callValidate, callValidate.schema = schemaObj.schema, 
        callValidate.errors = null, callValidate.root = root || callValidate, !0 === schemaObj.schema.$async && (callValidate.$async = !0), 
        callValidate;
        var currentOpts, v;
        schemaObj.compiling = !0, schemaObj.meta && (currentOpts = this._opts, this._opts = this._metaOpts);
        try {
            v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
        } catch (e) {
            throw delete schemaObj.validate, e;
        } finally {
            schemaObj.compiling = !1, schemaObj.meta && (this._opts = currentOpts);
        }
        return schemaObj.validate = v, schemaObj.refs = v.refs, schemaObj.refVal = v.refVal, 
        schemaObj.root = v.root, v;
        function callValidate() {
            var _validate = schemaObj.validate, result = _validate.apply(this, arguments);
            return callValidate.errors = _validate.errors, result;
        }
    }, Ajv.prototype.compileAsync = __webpack_require__(1110);
    var customKeyword = __webpack_require__(1111);
    Ajv.prototype.addKeyword = customKeyword.add, Ajv.prototype.getKeyword = customKeyword.get, 
    Ajv.prototype.removeKeyword = customKeyword.remove, Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = __webpack_require__(239);
    Ajv.ValidationError = errorClasses.Validation, Ajv.MissingRefError = errorClasses.MissingRef, 
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", META_IGNORE_OPTIONS = [ "removeAdditional", "useDefaults", "coerceTypes", "strictDefaults" ], META_SUPPORT_DATA = [ "/properties" ];
    function Ajv(opts) {
        if (!(this instanceof Ajv)) return new Ajv(opts);
        opts = this._opts = util.copy(opts) || {}, (function(self) {
            var logger = self._opts.logger;
            if (!1 === logger) self.logger = {
                log: noop,
                warn: noop,
                error: noop
            }; else {
                if (void 0 === logger && (logger = console), !("object" == typeof logger && logger.log && logger.warn && logger.error)) throw new Error("logger must implement log, warn and error methods");
                self.logger = logger;
            }
        })(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = formats(opts.format), 
        this._cache = opts.cache || new Cache, this._loadingSchemas = {}, this._compilations = [], 
        this.RULES = rules(), this._getId = (function(opts) {
            switch (opts.schemaId) {
              case "auto":
                return _get$IdOrId;

              case "id":
                return _getId;

              default:
                return _get$Id;
            }
        })(opts), opts.loopRequired = opts.loopRequired || 1 / 0, "property" == opts.errorDataPath && (opts._errorDataPathProperty = !0), 
        void 0 === opts.serialize && (opts.serialize = stableStringify), this._metaOpts = (function(self) {
            for (var metaOpts = util.copy(self._opts), i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];
            return metaOpts;
        })(this), opts.formats && (function(self) {
            for (var name in self._opts.formats) {
                var format = self._opts.formats[name];
                self.addFormat(name, format);
            }
        })(this), (function(self) {
            var $dataSchema;
            if (self._opts.$data && ($dataSchema = __webpack_require__(1113), self.addMetaSchema($dataSchema, $dataSchema.$id, !0)), 
            !1 !== self._opts.meta) {
                var metaSchema = __webpack_require__(503);
                self._opts.$data && (metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA)), 
                self.addMetaSchema(metaSchema, META_SCHEMA_ID, !0), self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
            }
        })(this), "object" == typeof opts.meta && this.addMetaSchema(opts.meta), opts.nullable && this.addKeyword("nullable", {
            metaSchema: {
                type: "boolean"
            }
        }), (function(self) {
            var optsSchemas = self._opts.schemas;
            if (optsSchemas) if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas); else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
        })(this);
    }
    function _getSchemaObj(self, keyRef) {
        return keyRef = resolve.normalizeId(keyRef), self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
    }
    function _removeAllSchemas(self, schemas, regex) {
        for (var keyRef in schemas) {
            var schemaObj = schemas[keyRef];
            schemaObj.meta || regex && !regex.test(keyRef) || (self._cache.del(schemaObj.cacheKey), 
            delete schemas[keyRef]);
        }
    }
    function _getId(schema) {
        return schema.$id && this.logger.warn("schema $id ignored", schema.$id), schema.id;
    }
    function _get$Id(schema) {
        return schema.id && this.logger.warn("schema id ignored", schema.id), schema.$id;
    }
    function _get$IdOrId(schema) {
        if (schema.$id && schema.id && schema.$id != schema.id) throw new Error("schema $id is different from id");
        return schema.$id || schema.id;
    }
    function checkUnique(self, id) {
        if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
    }
    function noop() {}
}, function(module, exports, __webpack_require__) {
    "use strict";
    var resolve = __webpack_require__(237), util = __webpack_require__(80), errorClasses = __webpack_require__(239), stableStringify = __webpack_require__(497), validateGenerator = __webpack_require__(498), ucs2length = util.ucs2length, equal = __webpack_require__(238), ValidationError = errorClasses.Validation;
    function checkCompiling(schema, root, baseId) {
        var index = compIndex.call(this, schema, root, baseId);
        return index >= 0 ? {
            index: index,
            compiling: !0
        } : (index = this._compilations.length, this._compilations[index] = {
            schema: schema,
            root: root,
            baseId: baseId
        }, {
            index: index,
            compiling: !1
        });
    }
    function endCompiling(schema, root, baseId) {
        var i = compIndex.call(this, schema, root, baseId);
        i >= 0 && this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
        for (var i = 0; i < this._compilations.length; i++) {
            var c = this._compilations[i];
            if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
        }
        return -1;
    }
    function patternCode(i, patterns) {
        return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
        return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
        return void 0 === refVal[i] ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
        return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
        if (!arr.length) return "";
        for (var code = "", i = 0; i < arr.length; i++) code += statement(i, arr);
        return code;
    }
    module.exports = function compile(schema, root, localRefs, baseId) {
        var self = this, opts = this._opts, refVal = [ void 0 ], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
        root = root || {
            schema: schema,
            refVal: refVal,
            refs: refs
        };
        var c = checkCompiling.call(this, schema, root, baseId), compilation = this._compilations[c.index];
        if (c.compiling) return compilation.callValidate = function callValidate() {
            var validate = compilation.validate, result = validate.apply(this, arguments);
            return callValidate.errors = validate.errors, result;
        };
        var formats = this._formats, RULES = this.RULES;
        try {
            var v = localCompile(schema, root, localRefs, baseId);
            compilation.validate = v;
            var cv = compilation.callValidate;
            return cv && (cv.schema = v.schema, cv.errors = null, cv.refs = v.refs, cv.refVal = v.refVal, 
            cv.root = v.root, cv.$async = v.$async, opts.sourceCode && (cv.source = v.source)), 
            v;
        } finally {
            endCompiling.call(this, schema, root, baseId);
        }
        function localCompile(_schema, _root, localRefs, baseId) {
            var isRoot = !_root || _root && _root.schema == _schema;
            if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);
            var validate, $async = !0 === _schema.$async, sourceCode = validateGenerator({
                isTop: !0,
                schema: _schema,
                isRoot: isRoot,
                baseId: baseId,
                root: _root,
                schemaPath: "",
                errSchemaPath: "#",
                errorPath: '""',
                MissingRefError: errorClasses.MissingRef,
                RULES: RULES,
                validate: validateGenerator,
                util: util,
                resolve: resolve,
                resolveRef: resolveRef,
                usePattern: usePattern,
                useDefault: useDefault,
                useCustomRule: useCustomRule,
                opts: opts,
                formats: formats,
                logger: self.logger,
                self: self
            });
            sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode, 
            opts.processCode && (sourceCode = opts.processCode(sourceCode));
            try {
                validate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode)(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError), 
                refVal[0] = validate;
            } catch (e) {
                throw self.logger.error("Error compiling schema, function code:", sourceCode), e;
            }
            return validate.schema = _schema, validate.errors = null, validate.refs = refs, 
            validate.refVal = refVal, validate.root = isRoot ? validate : _root, $async && (validate.$async = !0), 
            !0 === opts.sourceCode && (validate.source = {
                code: sourceCode,
                patterns: patterns,
                defaults: defaults
            }), validate;
        }
        function resolveRef(baseId, ref, isRoot) {
            ref = resolve.url(baseId, ref);
            var _refVal, refCode, refIndex = refs[ref];
            if (void 0 !== refIndex) return resolvedRef(_refVal = refVal[refIndex], refCode = "refVal[" + refIndex + "]");
            if (!isRoot && root.refs) {
                var rootRefId = root.refs[ref];
                if (void 0 !== rootRefId) return resolvedRef(_refVal = root.refVal[rootRefId], refCode = addLocalRef(ref, _refVal));
            }
            refCode = addLocalRef(ref);
            var v = resolve.call(self, localCompile, root, ref);
            if (void 0 === v) {
                var localSchema = localRefs && localRefs[ref];
                localSchema && (v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId));
            }
            if (void 0 !== v) return (function(ref, v) {
                var refId = refs[ref];
                refVal[refId] = v;
            })(ref, v), resolvedRef(v, refCode);
            !(function(ref) {
                delete refs[ref];
            })(ref);
        }
        function addLocalRef(ref, v) {
            var refId = refVal.length;
            return refVal[refId] = v, refs[ref] = refId, "refVal" + refId;
        }
        function resolvedRef(refVal, code) {
            return "object" == typeof refVal || "boolean" == typeof refVal ? {
                code: code,
                schema: refVal,
                inline: !0
            } : {
                code: code,
                $async: refVal && !!refVal.$async
            };
        }
        function usePattern(regexStr) {
            var index = patternsHash[regexStr];
            return void 0 === index && (index = patternsHash[regexStr] = patterns.length, patterns[index] = regexStr), 
            "pattern" + index;
        }
        function useDefault(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
                return "" + value;

              case "string":
                return util.toQuotedString(value);

              case "object":
                if (null === value) return "null";
                var valueStr = stableStringify(value), index = defaultsHash[valueStr];
                return void 0 === index && (index = defaultsHash[valueStr] = defaults.length, defaults[index] = value), 
                "default" + index;
            }
        }
        function useCustomRule(rule, schema, parentSchema, it) {
            if (!1 !== self._opts.validateSchema) {
                var deps = rule.definition.dependencies;
                if (deps && !deps.every((function(keyword) {
                    return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
                }))) throw new Error("parent schema must have all required keywords: " + deps.join(","));
                var validateSchema = rule.definition.validateSchema;
                if (validateSchema && !validateSchema(schema)) {
                    var message = "keyword schema is invalid: " + self.errorsText(validateSchema.errors);
                    if ("log" != self._opts.validateSchema) throw new Error(message);
                    self.logger.error(message);
                }
            }
            var validate, compile = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
            if (compile) validate = compile.call(self, schema, parentSchema, it); else if (macro) validate = macro.call(self, schema, parentSchema, it), 
            !1 !== opts.validateSchema && self.validateSchema(validate, !0); else if (inline) validate = inline.call(self, it, rule.keyword, schema, parentSchema); else if (!(validate = rule.definition.validate)) return;
            if (void 0 === validate) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
            var index = customRules.length;
            return customRules[index] = validate, {
                code: "customRule" + index,
                validate: validate
            };
        }
    };
}, function(module, exports, __webpack_require__) {
    !(function(exports) {
        "use strict";
        function merge() {
            for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) sets[_key] = arguments[_key];
            if (sets.length > 1) {
                sets[0] = sets[0].slice(0, -1);
                for (var xl = sets.length - 1, x = 1; x < xl; ++x) sets[x] = sets[x].slice(1, -1);
                return sets[xl] = sets[xl].slice(1), sets.join("");
            }
            return sets[0];
        }
        function subexp(str) {
            return "(?:" + str + ")";
        }
        function typeOf(o) {
            return void 0 === o ? "undefined" : null === o ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
        }
        function toUpperCase(str) {
            return str.toUpperCase();
        }
        function buildExps(isIRI) {
            var HEXDIG$$ = merge("[0-9]", "[A-Fa-f]"), PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge("[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$), IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$ = merge("[A-Za-z]", "[0-9]", "[\\-\\.\\_\\~]", isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"), SCHEME$ = subexp("[A-Za-z]" + merge("[A-Za-z]", "[0-9]", "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET_RELAXED$ = (subexp(subexp("25[0-5]") + "|" + subexp("2[0-4][0-9]") + "|" + subexp("1[0-9][0-9]") + "|" + subexp("[1-9][0-9]") + "|[0-9]"), 
            subexp(subexp("25[0-5]") + "|" + subexp("2[0-4][0-9]") + "|" + subexp("1[0-9][0-9]") + "|" + subexp("0?[1-9][0-9]") + "|0?0?[0-9]")), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$ + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([ IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$ ].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"), IPV6ADDRZ_RELAXED$ = (subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), 
            subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$)), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp("[0-9]*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", QUERY$ = (subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), 
            subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*")), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?");
            return subexp(URI$ + "|" + RELATIVE$), subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), 
            subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")"), 
            subexp("\\?(" + QUERY$ + ")"), subexp("\\#(" + FRAGMENT$ + ")"), subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")"), 
            subexp("\\?(" + QUERY$ + ")"), subexp("\\#(" + FRAGMENT$ + ")"), subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")"), 
            subexp("\\?(" + QUERY$ + ")"), subexp("\\#(" + FRAGMENT$ + ")"), subexp("(" + USERINFO$ + ")@"), 
            subexp("\\:(" + PORT$ + ")"), {
                NOT_SCHEME: new RegExp(merge("[^]", "[A-Za-z]", "[0-9]", "[\\+\\-\\.]"), "g"),
                NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
                NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
                ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
                UNRESERVED: new RegExp(UNRESERVED$$, "g"),
                OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
                PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
                IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
                IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
            };
        }
        var URI_PROTOCOL = buildExps(!1), IRI_PROTOCOL = buildExps(!0), slicedToArray = function(arr, i) {
            if (Array.isArray(arr)) return arr;
            if (Symbol.iterator in Object(arr)) return (function(arr, i) {
                var _arr = [], _n = !0, _d = !1, _e = void 0;
                try {
                    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                    !i || _arr.length !== i); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        !_n && _i.return && _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            })(arr, i);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }, maxInt = 2147483647, regexPunycode = /^xn--/, regexNonASCII = /[^\0-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, floor = Math.floor, stringFromCharCode = String.fromCharCode;
        function error$1(type) {
            throw new RangeError(errors[type]);
        }
        function mapDomain(string, fn) {
            var parts = string.split("@"), result = "";
            return parts.length > 1 && (result = parts[0] + "@", string = parts[1]), result + (function(array, fn) {
                for (var result = [], length = array.length; length--; ) result[length] = fn(array[length]);
                return result;
            })((string = string.replace(regexSeparators, ".")).split("."), fn).join(".");
        }
        function ucs2decode(string) {
            for (var output = [], counter = 0, length = string.length; counter < length; ) {
                var value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                    var extra = string.charCodeAt(counter++);
                    56320 == (64512 & extra) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), 
                    counter--);
                } else output.push(value);
            }
            return output;
        }
        var digitToBasic = function(digit, flag) {
            return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
        }, adapt = function(delta, numPoints, firstTime) {
            var k = 0;
            for (delta = firstTime ? floor(delta / 700) : delta >> 1, delta += floor(delta / numPoints); delta > 455; k += 36) delta = floor(delta / 35);
            return floor(k + 36 * delta / (delta + 38));
        }, decode = function(input) {
            var codePoint, output = [], inputLength = input.length, i = 0, n = 128, bias = 72, basic = input.lastIndexOf("-");
            basic < 0 && (basic = 0);
            for (var j = 0; j < basic; ++j) input.charCodeAt(j) >= 128 && error$1("not-basic"), 
            output.push(input.charCodeAt(j));
            for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                for (var oldi = i, w = 1, k = 36; ;k += 36) {
                    index >= inputLength && error$1("invalid-input");
                    var digit = (codePoint = input.charCodeAt(index++)) - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : 36;
                    (digit >= 36 || digit > floor((maxInt - i) / w)) && error$1("overflow"), i += digit * w;
                    var t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                    if (digit < t) break;
                    var baseMinusT = 36 - t;
                    w > floor(maxInt / baseMinusT) && error$1("overflow"), w *= baseMinusT;
                }
                var out = output.length + 1;
                bias = adapt(i - oldi, out, 0 == oldi), floor(i / out) > maxInt - n && error$1("overflow"), 
                n += floor(i / out), i %= out, output.splice(i++, 0, n);
            }
            return String.fromCodePoint.apply(String, output);
        }, encode = function(input) {
            var output = [], inputLength = (input = ucs2decode(input)).length, n = 128, delta = 0, bias = 72, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
            try {
                for (var _step, _iterator = input[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                    var _currentValue2 = _step.value;
                    _currentValue2 < 128 && output.push(stringFromCharCode(_currentValue2));
                }
            } catch (err) {
                _didIteratorError = !0, _iteratorError = err;
            } finally {
                try {
                    !_iteratorNormalCompletion && _iterator.return && _iterator.return();
                } finally {
                    if (_didIteratorError) throw _iteratorError;
                }
            }
            var basicLength = output.length, handledCPCount = basicLength;
            for (basicLength && output.push("-"); handledCPCount < inputLength; ) {
                var m = maxInt, _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                try {
                    for (var _step2, _iterator2 = input[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                        var currentValue = _step2.value;
                        currentValue >= n && currentValue < m && (m = currentValue);
                    }
                } catch (err) {
                    _didIteratorError2 = !0, _iteratorError2 = err;
                } finally {
                    try {
                        !_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return();
                    } finally {
                        if (_didIteratorError2) throw _iteratorError2;
                    }
                }
                var handledCPCountPlusOne = handledCPCount + 1;
                m - n > floor((maxInt - delta) / handledCPCountPlusOne) && error$1("overflow"), 
                delta += (m - n) * handledCPCountPlusOne, n = m;
                var _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
                try {
                    for (var _step3, _iterator3 = input[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
                        var _currentValue = _step3.value;
                        if (_currentValue < n && ++delta > maxInt && error$1("overflow"), _currentValue == n) {
                            for (var q = delta, k = 36; ;k += 36) {
                                var t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias;
                                if (q < t) break;
                                var qMinusT = q - t, baseMinusT = 36 - t;
                                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), q = floor(qMinusT / baseMinusT);
                            }
                            output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), 
                            delta = 0, ++handledCPCount;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = !0, _iteratorError3 = err;
                } finally {
                    try {
                        !_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return();
                    } finally {
                        if (_didIteratorError3) throw _iteratorError3;
                    }
                }
                ++delta, ++n;
            }
            return output.join("");
        }, punycode_toASCII = function(input) {
            return mapDomain(input, (function(string) {
                return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
            }));
        }, punycode_toUnicode = function(input) {
            return mapDomain(input, (function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            }));
        }, SCHEMES = {};
        function pctEncChar(chr) {
            var c = chr.charCodeAt(0);
            return c < 16 ? "%0" + c.toString(16).toUpperCase() : c < 128 ? "%" + c.toString(16).toUpperCase() : c < 2048 ? "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & c | 128).toString(16).toUpperCase() : "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & c | 128).toString(16).toUpperCase();
        }
        function pctDecChars(str) {
            for (var newStr = "", i = 0, il = str.length; i < il; ) {
                var c = parseInt(str.substr(i + 1, 2), 16);
                if (c < 128) newStr += String.fromCharCode(c), i += 3; else if (c >= 194 && c < 224) {
                    if (il - i >= 6) {
                        var c2 = parseInt(str.substr(i + 4, 2), 16);
                        newStr += String.fromCharCode((31 & c) << 6 | 63 & c2);
                    } else newStr += str.substr(i, 6);
                    i += 6;
                } else if (c >= 224) {
                    if (il - i >= 9) {
                        var _c = parseInt(str.substr(i + 4, 2), 16), c3 = parseInt(str.substr(i + 7, 2), 16);
                        newStr += String.fromCharCode((15 & c) << 12 | (63 & _c) << 6 | 63 & c3);
                    } else newStr += str.substr(i, 9);
                    i += 9;
                } else newStr += str.substr(i, 3), i += 3;
            }
            return newStr;
        }
        function _normalizeComponentEncoding(components, protocol) {
            function decodeUnreserved(str) {
                var decStr = pctDecChars(str);
                return decStr.match(protocol.UNRESERVED) ? decStr : str;
            }
            return components.scheme && (components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "")), 
            void 0 !== components.userinfo && (components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
            void 0 !== components.host && (components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
            void 0 !== components.path && (components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
            void 0 !== components.query && (components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
            void 0 !== components.fragment && (components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase)), 
            components;
        }
        function _stripLeadingZeros(str) {
            return str.replace(/^0*(.*)/, "$1") || "0";
        }
        function _normalizeIPv4(host, protocol) {
            var matches = host.match(protocol.IPV4ADDRESS) || [], address = slicedToArray(matches, 2)[1];
            return address ? address.split(".").map(_stripLeadingZeros).join(".") : host;
        }
        function _normalizeIPv6(host, protocol) {
            var matches = host.match(protocol.IPV6ADDRESS) || [], _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
            if (address) {
                for (var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1], firstFields = first ? first.split(":").map(_stripLeadingZeros) : [], lastFields = last.split(":").map(_stripLeadingZeros), isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]), fieldCount = isLastFieldIPv4Address ? 7 : 8, lastFieldsStart = lastFields.length - fieldCount, fields = Array(fieldCount), x = 0; x < fieldCount; ++x) fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
                isLastFieldIPv4Address && (fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol));
                var longestZeroFields = fields.reduce((function(acc, field, index) {
                    if (!field || "0" === field) {
                        var lastLongest = acc[acc.length - 1];
                        lastLongest && lastLongest.index + lastLongest.length === index ? lastLongest.length++ : acc.push({
                            index: index,
                            length: 1
                        });
                    }
                    return acc;
                }), []).sort((function(a, b) {
                    return b.length - a.length;
                }))[0], newHost = void 0;
                if (longestZeroFields && longestZeroFields.length > 1) {
                    var newFirst = fields.slice(0, longestZeroFields.index), newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
                    newHost = newFirst.join(":") + "::" + newLast.join(":");
                } else newHost = fields.join(":");
                return zone && (newHost += "%" + zone), newHost;
            }
            return host;
        }
        var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, NO_MATCH_IS_UNDEFINED = void 0 === "".match(/(){0}/)[1];
        function parse(uriString) {
            var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, components = {}, protocol = !1 !== options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
            "suffix" === options.reference && (uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString);
            var matches = uriString.match(URI_PARSE);
            if (matches) {
                NO_MATCH_IS_UNDEFINED ? (components.scheme = matches[1], components.userinfo = matches[3], 
                components.host = matches[4], components.port = parseInt(matches[5], 10), components.path = matches[6] || "", 
                components.query = matches[7], components.fragment = matches[8], isNaN(components.port) && (components.port = matches[5])) : (components.scheme = matches[1] || void 0, 
                components.userinfo = -1 !== uriString.indexOf("@") ? matches[3] : void 0, components.host = -1 !== uriString.indexOf("//") ? matches[4] : void 0, 
                components.port = parseInt(matches[5], 10), components.path = matches[6] || "", 
                components.query = -1 !== uriString.indexOf("?") ? matches[7] : void 0, components.fragment = -1 !== uriString.indexOf("#") ? matches[8] : void 0, 
                isNaN(components.port) && (components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0)), 
                components.host && (components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol)), 
                void 0 !== components.scheme || void 0 !== components.userinfo || void 0 !== components.host || void 0 !== components.port || components.path || void 0 !== components.query ? void 0 === components.scheme ? components.reference = "relative" : void 0 === components.fragment ? components.reference = "absolute" : components.reference = "uri" : components.reference = "same-document", 
                options.reference && "suffix" !== options.reference && options.reference !== components.reference && (components.error = components.error || "URI is not a " + options.reference + " reference.");
                var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
                if (options.unicodeSupport || schemeHandler && schemeHandler.unicodeSupport) _normalizeComponentEncoding(components, protocol); else {
                    if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) try {
                        components.host = punycode_toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                    } catch (e) {
                        components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                    }
                    _normalizeComponentEncoding(components, URI_PROTOCOL);
                }
                schemeHandler && schemeHandler.parse && schemeHandler.parse(components, options);
            } else components.error = components.error || "URI can not be parsed.";
            return components;
        }
        function _recomposeAuthority(components, options) {
            var protocol = !1 !== options.iri ? IRI_PROTOCOL : URI_PROTOCOL, uriTokens = [];
            return void 0 !== components.userinfo && (uriTokens.push(components.userinfo), uriTokens.push("@")), 
            void 0 !== components.host && uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (function(_, $1, $2) {
                return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
            }))), "number" == typeof components.port && (uriTokens.push(":"), uriTokens.push(components.port.toString(10))), 
            uriTokens.length ? uriTokens.join("") : void 0;
        }
        var RDS1 = /^\.\.?\//, RDS2 = /^\/\.(\/|$)/, RDS3 = /^\/\.\.(\/|$)/, RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
        function removeDotSegments(input) {
            for (var output = []; input.length; ) if (input.match(RDS1)) input = input.replace(RDS1, ""); else if (input.match(RDS2)) input = input.replace(RDS2, "/"); else if (input.match(RDS3)) input = input.replace(RDS3, "/"), 
            output.pop(); else if ("." === input || ".." === input) input = ""; else {
                var im = input.match(RDS5);
                if (!im) throw new Error("Unexpected dot segment condition");
                var s = im[0];
                input = input.slice(s.length), output.push(s);
            }
            return output.join("");
        }
        function serialize(components) {
            var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL, uriTokens = [], schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
            if (schemeHandler && schemeHandler.serialize && schemeHandler.serialize(components, options), 
            components.host) if (protocol.IPV6ADDRESS.test(components.host)) ; else if (options.domainHost || schemeHandler && schemeHandler.domainHost) try {
                components.host = options.iri ? punycode_toUnicode(components.host) : punycode_toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (options.iri ? "Unicode" : "ASCII") + " via punycode: " + e;
            }
            _normalizeComponentEncoding(components, protocol), "suffix" !== options.reference && components.scheme && (uriTokens.push(components.scheme), 
            uriTokens.push(":"));
            var authority = _recomposeAuthority(components, options);
            if (void 0 !== authority && ("suffix" !== options.reference && uriTokens.push("//"), 
            uriTokens.push(authority), components.path && "/" !== components.path.charAt(0) && uriTokens.push("/")), 
            void 0 !== components.path) {
                var s = components.path;
                options.absolutePath || schemeHandler && schemeHandler.absolutePath || (s = removeDotSegments(s)), 
                void 0 === authority && (s = s.replace(/^\/\//, "/%2F")), uriTokens.push(s);
            }
            return void 0 !== components.query && (uriTokens.push("?"), uriTokens.push(components.query)), 
            void 0 !== components.fragment && (uriTokens.push("#"), uriTokens.push(components.fragment)), 
            uriTokens.join("");
        }
        function resolveComponents(base, relative) {
            var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, target = {};
            return arguments[3] || (base = parse(serialize(base, options), options), relative = parse(serialize(relative, options), options)), 
            !(options = options || {}).tolerant && relative.scheme ? (target.scheme = relative.scheme, 
            target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, 
            target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (void 0 !== relative.userinfo || void 0 !== relative.host || void 0 !== relative.port ? (target.userinfo = relative.userinfo, 
            target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), 
            target.query = relative.query) : (relative.path ? ("/" === relative.path.charAt(0) ? target.path = removeDotSegments(relative.path) : (void 0 === base.userinfo && void 0 === base.host && void 0 === base.port || base.path ? base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path : target.path = "/" + relative.path, 
            target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, 
            void 0 !== relative.query ? target.query = relative.query : target.query = base.query), 
            target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), 
            target.scheme = base.scheme), target.fragment = relative.fragment, target;
        }
        function unescapeComponent(str, options) {
            return str && str.toString().replace(options && options.iri ? IRI_PROTOCOL.PCT_ENCODED : URI_PROTOCOL.PCT_ENCODED, pctDecChars);
        }
        var handler = {
            scheme: "http",
            domainHost: !0,
            parse: function(components, options) {
                return components.host || (components.error = components.error || "HTTP URIs must have a host."), 
                components;
            },
            serialize: function(components, options) {
                return components.port !== ("https" !== String(components.scheme).toLowerCase() ? 80 : 443) && "" !== components.port || (components.port = void 0), 
                components.path || (components.path = "/"), components;
            }
        }, handler$1 = {
            scheme: "https",
            domainHost: handler.domainHost,
            parse: handler.parse,
            serialize: handler.serialize
        }, O = {}, UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", HEXDIG$$ = "[0-9A-Fa-f]", PCT_ENCODED$ = subexp(subexp("%[EFef][0-9A-Fa-f]%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f][0-9A-Fa-f]%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)), VCHAR$$ = merge("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), UNRESERVED = new RegExp(UNRESERVED$$, "g"), PCT_ENCODED = new RegExp(PCT_ENCODED$, "g"), NOT_LOCAL_PART = new RegExp(merge("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', VCHAR$$), "g"), NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), NOT_HFVALUE = NOT_HFNAME;
        function decodeUnreserved(str) {
            var decStr = pctDecChars(str);
            return decStr.match(UNRESERVED) ? decStr : str;
        }
        var handler$2 = {
            scheme: "mailto",
            parse: function(components, options) {
                var mailtoComponents = components, to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
                if (mailtoComponents.path = void 0, mailtoComponents.query) {
                    for (var unknownHeaders = !1, headers = {}, hfields = mailtoComponents.query.split("&"), x = 0, xl = hfields.length; x < xl; ++x) {
                        var hfield = hfields[x].split("=");
                        switch (hfield[0]) {
                          case "to":
                            for (var toAddrs = hfield[1].split(","), _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) to.push(toAddrs[_x]);
                            break;

                          case "subject":
                            mailtoComponents.subject = unescapeComponent(hfield[1], options);
                            break;

                          case "body":
                            mailtoComponents.body = unescapeComponent(hfield[1], options);
                            break;

                          default:
                            unknownHeaders = !0, headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        }
                    }
                    unknownHeaders && (mailtoComponents.headers = headers);
                }
                mailtoComponents.query = void 0;
                for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
                    var addr = to[_x2].split("@");
                    if (addr[0] = unescapeComponent(addr[0]), options.unicodeSupport) addr[1] = unescapeComponent(addr[1], options).toLowerCase(); else try {
                        addr[1] = punycode_toASCII(unescapeComponent(addr[1], options).toLowerCase());
                    } catch (e) {
                        mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                    }
                    to[_x2] = addr.join("@");
                }
                return mailtoComponents;
            },
            serialize: function(mailtoComponents, options) {
                var obj, components = mailtoComponents, to = null != (obj = mailtoComponents.to) ? obj instanceof Array ? obj : "number" != typeof obj.length || obj.split || obj.setInterval || obj.call ? [ obj ] : Array.prototype.slice.call(obj) : [];
                if (to) {
                    for (var x = 0, xl = to.length; x < xl; ++x) {
                        var toAddr = String(to[x]), atIdx = toAddr.lastIndexOf("@"), localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar), domain = toAddr.slice(atIdx + 1);
                        try {
                            domain = options.iri ? punycode_toUnicode(domain) : punycode_toASCII(unescapeComponent(domain, options).toLowerCase());
                        } catch (e) {
                            components.error = components.error || "Email address's domain name can not be converted to " + (options.iri ? "Unicode" : "ASCII") + " via punycode: " + e;
                        }
                        to[x] = localPart + "@" + domain;
                    }
                    components.path = to.join(",");
                }
                var headers = mailtoComponents.headers = mailtoComponents.headers || {};
                mailtoComponents.subject && (headers.subject = mailtoComponents.subject), mailtoComponents.body && (headers.body = mailtoComponents.body);
                var fields = [];
                for (var name in headers) headers[name] !== O[name] && fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
                return fields.length && (components.query = fields.join("&")), components;
            }
        }, URN_PARSE = /^([^\:]+)\:(.*)/, handler$3 = {
            scheme: "urn",
            parse: function(components, options) {
                var matches = components.path && components.path.match(URN_PARSE), urnComponents = components;
                if (matches) {
                    var scheme = options.scheme || urnComponents.scheme || "urn", nid = matches[1].toLowerCase(), nss = matches[2], urnScheme = scheme + ":" + (options.nid || nid), schemeHandler = SCHEMES[urnScheme];
                    urnComponents.nid = nid, urnComponents.nss = nss, urnComponents.path = void 0, schemeHandler && (urnComponents = schemeHandler.parse(urnComponents, options));
                } else urnComponents.error = urnComponents.error || "URN can not be parsed.";
                return urnComponents;
            },
            serialize: function(urnComponents, options) {
                var scheme = options.scheme || urnComponents.scheme || "urn", nid = urnComponents.nid, urnScheme = scheme + ":" + (options.nid || nid), schemeHandler = SCHEMES[urnScheme];
                schemeHandler && (urnComponents = schemeHandler.serialize(urnComponents, options));
                var uriComponents = urnComponents, nss = urnComponents.nss;
                return uriComponents.path = (nid || options.nid) + ":" + nss, uriComponents;
            }
        }, UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, handler$4 = {
            scheme: "urn:uuid",
            parse: function(urnComponents, options) {
                var uuidComponents = urnComponents;
                return uuidComponents.uuid = uuidComponents.nss, uuidComponents.nss = void 0, options.tolerant || uuidComponents.uuid && uuidComponents.uuid.match(UUID) || (uuidComponents.error = uuidComponents.error || "UUID is not valid."), 
                uuidComponents;
            },
            serialize: function(uuidComponents, options) {
                var urnComponents = uuidComponents;
                return urnComponents.nss = (uuidComponents.uuid || "").toLowerCase(), urnComponents;
            }
        };
        SCHEMES[handler.scheme] = handler, SCHEMES[handler$1.scheme] = handler$1, SCHEMES[handler$2.scheme] = handler$2, 
        SCHEMES[handler$3.scheme] = handler$3, SCHEMES[handler$4.scheme] = handler$4, exports.SCHEMES = SCHEMES, 
        exports.pctEncChar = pctEncChar, exports.pctDecChars = pctDecChars, exports.parse = parse, 
        exports.removeDotSegments = removeDotSegments, exports.serialize = serialize, exports.resolveComponents = resolveComponents, 
        exports.resolve = function(baseURI, relativeURI, options) {
            var schemelessOptions = (function(target, source) {
                var obj = target;
                if (source) for (var key in source) obj[key] = source[key];
                return obj;
            })({
                scheme: "null"
            }, options);
            return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, !0), schemelessOptions);
        }, exports.normalize = function(uri, options) {
            return "string" == typeof uri ? uri = serialize(parse(uri, options), options) : "object" === typeOf(uri) && (uri = parse(serialize(uri, options), options)), 
            uri;
        }, exports.equal = function(uriA, uriB, options) {
            return "string" == typeof uriA ? uriA = serialize(parse(uriA, options), options) : "object" === typeOf(uriA) && (uriA = serialize(uriA, options)), 
            "string" == typeof uriB ? uriB = serialize(parse(uriB, options), options) : "object" === typeOf(uriB) && (uriB = serialize(uriB, options)), 
            uriA === uriB;
        }, exports.escapeComponent = function(str, options) {
            return str && str.toString().replace(options && options.iri ? IRI_PROTOCOL.ESCAPE : URI_PROTOCOL.ESCAPE, pctEncChar);
        }, exports.unescapeComponent = unescapeComponent, Object.defineProperty(exports, "__esModule", {
            value: !0
        });
    })(exports);
}, function(module, exports, __webpack_require__) {
    "use strict";
    module.exports = function(str) {
        for (var value, length = 0, len = str.length, pos = 0; pos < len; ) length++, (value = str.charCodeAt(pos++)) >= 55296 && value <= 56319 && pos < len && 56320 == (64512 & (value = str.charCodeAt(pos))) && pos++;
        return length;
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
        "function" == typeof opts && (cb = opts, opts = {}), _traverse(opts, "function" == typeof (cb = opts.cb || cb) ? cb : cb.pre || function() {}, cb.post || function() {}, schema, "", schema);
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (schema && "object" == typeof schema && !Array.isArray(schema)) {
            for (var key in pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex), 
            schema) {
                var sch = schema[key];
                if (Array.isArray(sch)) {
                    if (key in traverse.arrayKeywords) for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
                } else if (key in traverse.propsKeywords) {
                    if (sch && "object" == typeof sch) for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + prop.replace(/~/g, "~0").replace(/\//g, "~1"), rootSchema, jsonPtr, key, schema, prop);
                } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
            }
            post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        }
    }
    traverse.keywords = {
        additionalItems: !0,
        items: !0,
        contains: !0,
        additionalProperties: !0,
        propertyNames: !0,
        not: !0
    }, traverse.arrayKeywords = {
        items: !0,
        allOf: !0,
        anyOf: !0,
        oneOf: !0
    }, traverse.propsKeywords = {
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0
    }, traverse.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var Cache = module.exports = function() {
        this._cache = {};
    };
    Cache.prototype.put = function(key, value) {
        this._cache[key] = value;
    }, Cache.prototype.get = function(key) {
        return this._cache[key];
    }, Cache.prototype.del = function(key) {
        delete this._cache[key];
    }, Cache.prototype.clear = function() {
        this._cache = {};
    };
}, function(module, exports, __webpack_require__) {
    "use strict";
    var util = __webpack_require__(80), DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ], TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i, HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/, JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    function formats(mode) {
        return mode = "full" == mode ? "full" : "fast", util.copy(formats[mode]);
    }
    function date(str) {
        var matches = str.match(DATE);
        if (!matches) return !1;
        var year = +matches[1], month = +matches[2], day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= (2 == month && (function(year) {
            return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
        })(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
        var matches = str.match(TIME);
        if (!matches) return !1;
        var hour = matches[1], minute = matches[2], second = matches[3], timeZone = matches[5];
        return (hour <= 23 && minute <= 59 && second <= 59 || 23 == hour && 59 == minute && 60 == second) && (!full || timeZone);
    }
    module.exports = formats, formats.fast = {
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
        uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        "uri-template": URITEMPLATE,
        url: URL,
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: HOSTNAME,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: regex,
        uuid: UUID,
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        "relative-json-pointer": RELATIVE_JSON_POINTER
    }, formats.full = {
        date: date,
        time: time,
        "date-time": function(str) {
            var dateTime = str.split(DATE_TIME_SEPARATOR);
            return 2 == dateTime.length && date(dateTime[0]) && time(dateTime[1], !0);
        },
        uri: function(str) {
            return NOT_URI_FRAGMENT.test(str) && URI.test(str);
        },
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        "uri-template": URITEMPLATE,
        url: URL,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: function(str) {
            return str.length <= 255 && HOSTNAME.test(str);
        },
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: regex,
        uuid: UUID,
        "json-pointer": JSON_POINTER,
        "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
        "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    var DATE_TIME_SEPARATOR = /t|\s/i, NOT_URI_FRAGMENT = /\/|:/, Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
        if (Z_ANCHOR.test(str)) return !1;
        try {
            return new RegExp(str), !0;
        } catch (e) {
            return !1;
        }
    }
}
